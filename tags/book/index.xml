<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Book on Jimmy&#39;s blog</title>
    <link>http://rootsongjc.github.io/tags/book/index.xml</link>
    <description>Recent content in Book on Jimmy&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://rootsongjc.github.io/tags/book/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>TensorFlow实战（才云郑泽宇著）读书笔记——第三章TensorFlow入门</title>
      <link>http://rootsongjc.github.io/blogs/tensorflow-practice-03/</link>
      <pubDate>Thu, 30 Mar 2017 21:34:33 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/tensorflow-practice-03/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2015052401.jpg&#34; alt=&#34;扬州东关&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：扬州东关 May 24,2015）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这是我阅读&lt;a href=&#34;caicloud.io&#34;&gt;才云科技&lt;/a&gt;郑泽宇的《TensorFlow实战Google深度学习框架》的读书笔记系列文章，按照文章的章节顺序来写的。整本书的笔记归档在&lt;a href=&#34;http://rootsongjc.github.io/tags/tensorflow-practice-reading-notes/&#34;&gt;这里&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;P.S 本书的&lt;strong&gt;官方读者交流微信群（作者也在群里）&lt;/strong&gt;已经超过100人，您可以先加我微信后我拉您进去，我的二维码在&lt;a href=&#34;rootsongjc.github.io/about&#34;&gt;这里&lt;/a&gt;，或者直接搜索我的微信号jimmysong。&lt;/p&gt;

&lt;p&gt;这一章从三个角度带大家入门。&lt;/p&gt;

&lt;p&gt;分别是TensorFlow的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算模型&lt;/li&gt;
&lt;li&gt;数据模型&lt;/li&gt;
&lt;li&gt;运行模型&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-1-tensorflow的计算模型-图计算&#34;&gt;3.1 TensorFlow的计算模型——图计算&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;计算图&lt;/strong&gt;是TensorFlow中的一个最基本的概念，&lt;u&gt;TensorFlow中的所有计算都会转化成计算图上的节点&lt;/u&gt;。&lt;/p&gt;

&lt;p&gt;其实TensorFlow的名字已经暗示了它的实现方式了，&lt;strong&gt;Tensor&lt;/strong&gt;表示的是数据结构——张量，&lt;strong&gt;Flow&lt;/strong&gt;表示数据流——Tensor通过数据流相互转化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用的方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在python中导入tensorflow：import tensorflow as tf&lt;/li&gt;
&lt;li&gt;获取当前默认的计算图：tf.get_default_graph()&lt;/li&gt;
&lt;li&gt;生成新的计算图：tf.Graph()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;书中这里都有例子讲解，可以从Github中&lt;a href=&#34;https://github.com/caicloud/tensorflow-tutorial&#34;&gt;下载代码&lt;/a&gt;，或者如果你使用才云提供的docker镜像的方式安装的话，在jupyter中可以看到各个章节的代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义两个不同的图&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import tensorflow as tf

g1 = tf.Graph()
with g1.as_default():
    v = tf.get_variable(&amp;quot;v&amp;quot;, [1], initializer = tf.zeros_initializer) # 设置初始值为0

g2 = tf.Graph()
with g2.as_default():
    v = tf.get_variable(&amp;quot;v&amp;quot;, [1], initializer = tf.ones_initializer())  # 设置初始值为1
    
with tf.Session(graph = g1) as sess:
    tf.global_variables_initializer().run()
    with tf.variable_scope(&amp;quot;&amp;quot;, reuse=True):
        print(sess.run(tf.get_variable(&amp;quot;v&amp;quot;)))

with tf.Session(graph = g2) as sess:
    tf.global_variables_initializer().run()
    with tf.variable_scope(&amp;quot;&amp;quot;, reuse=True):
        print(sess.run(tf.get_variable(&amp;quot;v&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到这里面用了&lt;a href=&#34;https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/&#34;&gt;python中的with语法&lt;/a&gt;，不了解的可以到前面那个链接看看。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;TensorFlow中维护的集合列表&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;集合名称&lt;/th&gt;
&lt;th&gt;集合内容&lt;/th&gt;
&lt;th&gt;使用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.VARIABLES&lt;/td&gt;
&lt;td&gt;所有变量&lt;/td&gt;
&lt;td&gt;持久化TensorFlow模型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.TRAINABLE_VARIABLES&lt;/td&gt;
&lt;td&gt;可学习的变量（一般指神经网络中的参数）&lt;/td&gt;
&lt;td&gt;模型训练、生活从呢个模型可视化内容&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.SUMMARIES&lt;/td&gt;
&lt;td&gt;与日志有关的张量&lt;/td&gt;
&lt;td&gt;TensorFlow计算可视化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.QUEUE_RUNNERS&lt;/td&gt;
&lt;td&gt;处理输入的QueueRunner&lt;/td&gt;
&lt;td&gt;输入处理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.MOVING_AVERAGE_VARIABLES&lt;/td&gt;
&lt;td&gt;所有计算了滑动平均值的变量&lt;/td&gt;
&lt;td&gt;计算变量的滑动平均值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;所谓的滑动平均值即移动平均值，熟悉股票的应该都知道均线的概念吧，5日均线，20日均线，30日均线啥的，一般称作MA(Moving Average)。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-2-tensorflow数据模型-张量&#34;&gt;3.2 TensorFlow数据模型——张量&lt;/h2&gt;

&lt;p&gt;张量（Tensor）是TensorFlow中所有数据的表现形式。我们可以简单的将Tensor理解为&lt;strong&gt;多维数组&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0阶的话就是一个标量（Scalar），可以是一个数也可以是一个字符串&lt;/li&gt;
&lt;li&gt;一阶的话是向量（Vector）&lt;/li&gt;
&lt;li&gt;n阶的话就是n维数组&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tensor在TensorFlow中并不是直接采用数组的形式，而是&lt;strong&gt;对TF中计算结果的引用&lt;/strong&gt;，保存的是如何得到这些数字的过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;举个例子&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;import tensorflow as tf
a = tf.constant([1.0, 2.0], name=&amp;quot;a&amp;quot;)
b = tf.constant([2.0, 3.0], name=&amp;quot;b&amp;quot;)
result = tf.add(a,b,name=&amp;quot;add&amp;quot;)
print result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Tensor(&amp;quot;add:0&amp;quot;, shape=(2,), dtype=float32)
[ 3.  5.]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子只是简单的做了个加法，下面结合上面的例子来讲解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tensor的3个属性&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;名字（Name）&lt;/strong&gt;：Tensor的唯一标识符，如例子中的a, b, result，这是我们手动指定的，实际上Tensor是与计算图上的每个节点一一对应的，tensor的命名可以通过&lt;code&gt;node:src_output&lt;/code&gt;的形式给出，如例子输出中的计算结果名字为&lt;strong&gt;add:0&lt;/strong&gt;，0表示的是计算节点&lt;strong&gt;add&lt;/strong&gt;输出的第一个结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;维度（Shape）&lt;/strong&gt;：如上面例子结果输出中的&lt;strong&gt;shape=(2,)&lt;/strong&gt;，表示这个张量是一维数组，数组的长度是2。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型（Type）&lt;/strong&gt;：所有参与运算的张量的类型必须是相同的，比如不能float和int之间运算。TensorFlow会自动检查张量的类型，可以通过&lt;strong&gt;dtype=df.float32&lt;/strong&gt;这样的声明来指定类型，如果不指定的话，TF会根据值确定默认类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Tensor的用途&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;作为对计算中间结果的引用，比如上面例子中的a和b，在复杂计算中使用tensor能够增加代码的可阅读性。&lt;/li&gt;
&lt;li&gt;用来获取计算结果。张量本身没有存储具体的数字，但是可以使用&lt;strong&gt;会话&lt;/strong&gt;的tf.Session().run(result)来获取计算结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-3-tensorflow的运行模型-会话&#34;&gt;3.3 TensorFlow的运行模型——会话&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;会话（Session）拥有和管理TensorFlow中所有的运算，可以执行定义好的运算。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建和关闭会话&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 创建一个会话。
sess = tf.Session()

# 使用会话得到之前计算的结果。
print(sess.run(result))

# 关闭会话使得本次运行中使用到的资源可以被释放。
sess.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议使用Python的&lt;strong&gt;上下文管理器&lt;/strong&gt;，即通过&lt;strong&gt;with&lt;/strong&gt;语法来创建会话，能够避免资源泄漏。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with tf.Session() as sess:
    print(sess.run(result))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在交互式环境下（比如Jupyter）直接使用&lt;strong&gt;tf.InteractiveSession&lt;/strong&gt;函数创建&lt;strong&gt;交互式会话&lt;/strong&gt;，将产生的会话直接注册为默认会话。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sess = tf.InteractiveSession ()
print(result.eval())
sess.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不论使用哪种会话都可以通过&lt;strong&gt;ConfigProto&lt;/strong&gt;来配置&lt;code&gt;并行线程数&lt;/code&gt;、&lt;code&gt;GPU分配策略&lt;/code&gt;、&lt;code&gt;运算超时时间&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;常用的两个配置有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;allow_soft_placement&lt;/strong&gt;：布尔值，默认false，以下任何一个条件满足时则为true，允许将GPU上的运算放到CPU上进行。

&lt;ul&gt;
&lt;li&gt;运算无法在GPU上运行&lt;/li&gt;
&lt;li&gt;GPU资源不足（没有GPU或者指定的GPU个数不够）&lt;/li&gt;
&lt;li&gt;运算输入包括对CPU计算结果的引用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;log_device_placement&lt;/strong&gt;：布尔值，默认值是？如果为true的话，日志中将会记录每个节点被安排在哪个设备上，这方便调试。生产环境中一般设置为false，能够减少日志量。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-4-tensorflow实现神经网络&#34;&gt;3.4 TensorFlow实现神经网络&lt;/h2&gt;

&lt;p&gt;To be continued…&lt;/p&gt;

&lt;p&gt;10:39 p.m Thu Mar 30,2017&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TensorFlow实战（才云郑泽宇著）读书笔记——第二章TensorFlow环境搭建</title>
      <link>http://rootsongjc.github.io/blogs/tensorflow-practice-02/</link>
      <pubDate>Thu, 23 Mar 2017 19:34:33 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/tensorflow-practice-02/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20140810002.jpg&#34; alt=&#34;广州海珠桥&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：广州海珠桥 Aug 10,2014）&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这是我阅读&lt;a href=&#34;caicloud.io&#34;&gt;才云科技&lt;/a&gt;郑泽宇的《TensorFlow实战Google深度学习框架》的读书笔记系列文章，按照文章的章节顺序来写的。整本书的笔记归档在&lt;a href=&#34;http://rootsongjc.github.io/tags/tensorflow-practice-reading-notes/&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;P.S 本书的&lt;strong&gt;官方读者交流微信群（作者也在群里）&lt;/strong&gt;已经超过100人，您可以先加我微信后我拉您进去，我的二维码在&lt;a href=&#34;rootsongjc.github.io/about&#34;&gt;这里&lt;/a&gt;，或者直接搜索我的微信号jimmysong。&lt;/p&gt;

&lt;p&gt;睇完这一章后应该就可以自己搭建出一个TensorFlow的环境，我之前在docker里玩过，镜像比较大，下载慢一点，不过用起来很方便，如果你仅仅是想试用一下TensorFlow，看看它能干什么的话，可以直接在docker里试用一下。在Mac上安装的详细步骤，&lt;a href=&#34;https://www.tensorflow.org/install/install_mac&#34;&gt;官方安装说明文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;2-1-tensorflow的主要依赖包&#34;&gt;2.1 TensorFlow的主要依赖包&lt;/h2&gt;

&lt;p&gt;TensorFlow主要用到以下两个依赖：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/protocol-buffers/&#34;&gt;Protocol buffer&lt;/a&gt;：数据结构化工具。Google开源的结构化数据格式，用于网络传输数据时候的序列化和反序列化，使用的时候需要先定义schema，github地址&lt;a href=&#34;https://github.com/google/protobuf。分布式TensorFlow使用到额gRPC也是使用Protocol&#34;&gt;https://github.com/google/protobuf。分布式TensorFlow使用到额gRPC也是使用Protocol&lt;/a&gt; Buffer来组织的，&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bazel.build/&#34;&gt;Bazel&lt;/a&gt;:自动化编译构建工具。Google开源的，github地址&lt;a href=&#34;https://github.com/bazelbuild/bazel，它支持多语言、多平台、可重复编译和可伸缩，构建大型软件速度也是很快的。Bazel使用**项目空间**的形式管理编译的，每个项目空间需要包含[BUILD文件](https://github.com/tensorflow/tensorflow/blob/master/bower.BUILD)（定义编译目标）和[WORKSPACE](https://github.com/tensorflow/tensorflow/blob/master/WORKSPACE)文件（定义编译的依赖环境）。这两个文件都有点类似python语法。&#34;&gt;https://github.com/bazelbuild/bazel，它支持多语言、多平台、可重复编译和可伸缩，构建大型软件速度也是很快的。Bazel使用**项目空间**的形式管理编译的，每个项目空间需要包含[BUILD文件](https://github.com/tensorflow/tensorflow/blob/master/bower.BUILD)（定义编译目标）和[WORKSPACE](https://github.com/tensorflow/tensorflow/blob/master/WORKSPACE)文件（定义编译的依赖环境）。这两个文件都有点类似python语法。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-2-tensorflow安装&#34;&gt;2.2 TensorFlow安装&lt;/h2&gt;

&lt;p&gt;TensorFlow的安装方式包括docker镜像、pip安装、源码编译安装。&lt;/p&gt;

&lt;p&gt;&lt;u&gt;我选择最方便的docker镜像方式&lt;/u&gt;，其他方式对本地环境做很多配置，折腾起来比较麻烦。&lt;/p&gt;

&lt;p&gt;我早就在docker中安装过TensorFlow0.9小试过牛刀。现在&lt;a href=&#34;https://github.com/tensorflow/tensorflow/releases&#34;&gt;1.0.1版本&lt;/a&gt;已经released了。TensorFlow的所有版本都有对应的docker镜像发布在&lt;a href=&#34;https://hub.docker.com/r/tensorflow/tensorflow/tags/&#34;&gt;docker hub&lt;/a&gt;，可以直接&lt;code&gt;docker pull&lt;/code&gt;安装。&lt;/p&gt;

&lt;p&gt;为了和书中所用的镜像保持统一，我将使用caicloud提供的镜像，基于TensorFlow0.12.0（这个版本是2016年12月20日发布的），他们增加了一些其他机器学习工具包和TensorFlow可视化工具TensorBoard。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker镜像方式安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先下载镜像，这个image比较大，下载下来比较费时间，我用了差不多15分钟吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull cargo.caicloud.io/tensorflow/tensorflow:0.12.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载下来后我们再check下这个大小为&lt;strong&gt;1.41GB&lt;/strong&gt;镜像的layers。&lt;/p&gt;

&lt;p&gt;另外还有个&lt;a href=&#34;https://github.com/NVIDIA/nvidia-docker&#34;&gt;&lt;strong&gt;nvidia&lt;/strong&gt;版本的docker&lt;/a&gt;，可以将你电脑的&lt;strong&gt;GPU&lt;/strong&gt;派山用场，我暂时没用到GPU，我电脑装的是&lt;code&gt;docker17.03-ce&lt;/code&gt;，就不折腾GPU版本的TensorFlow了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
c8a8409297f2        5 weeks ago         /bin/sh -c #(nop)  CMD [&amp;quot;/run_tf.sh&amp;quot;]           0 B                 
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c #(nop) COPY file:78332d36244852...   122 B               
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c #(nop) COPY dir:8b6ab7d235e3975...   21 MB               
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c #(nop) COPY dir:fca915671040399...   360 MB              
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c #(nop) COPY dir:69314aa937be649...   89.9 kB             
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c rm -rf /notebooks/*                  0 B                 
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c pip install caicloud.tensorflow      21.4 MB             
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c pip install -U scikit-learn          39.9 kB             
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c apt-get update &amp;amp;&amp;amp; apt-get insta...   23.9 MB             
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c #(nop)  ENV LANG=C.UTF-8             0 B                 
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop)  CMD [&amp;quot;/run_jupyter.sh&amp;quot;]      0 B                 
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop)  WORKDIR /notebooks           0 B                 
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop)  EXPOSE 8888/tcp              0 B                 
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop)  EXPOSE 6006/tcp              0 B                 
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop) COPY file:5485384c641ba7...   733 B               
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop) COPY dir:388d24701b3b5bc...   400 kB              
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop) COPY file:822af972b63c44...   1.06 kB             
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c pip --no-cache-dir install http...   191 MB              
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c pip --no-cache-dir install     ...   379 MB              
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c curl -O https://bootstrap.pypa....   11.4 MB             
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c apt-get update &amp;amp;&amp;amp; apt-get insta...   212 MB              
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop)  MAINTAINER Craig Citro ...   0 B                 
&amp;lt;missing&amp;gt;           9 months ago        /bin/sh -c #(nop) CMD [&amp;quot;/bin/bash&amp;quot;]             0 B                 
&amp;lt;missing&amp;gt;           9 months ago        /bin/sh -c sed -i &#39;s/^#\s*\(deb.*universe\...   1.9 kB              
&amp;lt;missing&amp;gt;           9 months ago        /bin/sh -c rm -rf /var/lib/apt/lists/*          0 B                 
&amp;lt;missing&amp;gt;           9 months ago        /bin/sh -c set -xe   &amp;amp;&amp;amp; echo &#39;#!/bin/sh&#39; &amp;gt;...   195 kB              
&amp;lt;missing&amp;gt;           9 months ago        /bin/sh -c #(nop) ADD file:aca501360d0937b...   188 MB 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这是一个基于&lt;strong&gt;Ubuntu&lt;/strong&gt;的docker image，这其中还包含了一个&lt;strong&gt;Jupyter notebook&lt;/strong&gt;和一些python packages。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;docker image history —no-trunc $IMAGE_ID&lt;/code&gt;命令可以看到每一层的详细信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启动TensorFlow&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;直接在docker中启动。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;docker run -it -d -p 8888:8888 -p 6006:6006 --name tf-dev cargo.caicloud.io/tensorflow/tensorflow:0.12.0 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动后进入&lt;code&gt;localhost:8888&lt;/code&gt;页面，发现登陆jupyter居然还要输入密码，书中没说要输入密码啊，也没说密码是什么，密码在哪里呢？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如何获取Jupyter的登录密码书中没有介绍。其实没必要修改镜像活着进入容器中需钙jupyter的配置，直接查看刚启动的&lt;code&gt;tf-dev&lt;/code&gt;容器的日志即可，里面包含了登录密码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;docker logs tf-dev
[I 10:52:46.200 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret
[W 10:52:46.244 NotebookApp] WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended.
[I 10:52:46.267 NotebookApp] Serving notebooks from local directory: /notebooks
[I 10:52:46.267 NotebookApp] 0 active kernels 
[I 10:52:46.267 NotebookApp] The Jupyter Notebook is running at: http://[all ip addresses on your system]:8888/?token=e64afc31eec843717733d6e4527aecf833ce18383214dc47
[I 10:52:46.267 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).
Starting TensorBoard 39 on port 6006
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到了吗，&lt;code&gt;tf-dev&lt;/code&gt;容器的日志输出里就包括了密码，我的容器的jupyter的密码是&lt;strong&gt;token后面的那个字符串&lt;/strong&gt;e64afc31eec843717733d6e4527aecf833ce18383214dc47。&lt;/p&gt;

&lt;p&gt;现在用刚才从日志里看到的密码就可以登录了，Jupyter页面上可以看到本书所有章节的代码了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-practice-chapter2-jupyter-web.jpg&#34; alt=&#34;jupyter页面&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用pip安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外我在mac上也用pip方式安装了。我安装的是最新版的1.0.1的CPU-only，加上&lt;code&gt;—user -U&lt;/code&gt;是为了规避mac上的各种权限问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip install --upgrade tensorflow --user -U
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载的整个软件包只有39.3MB，速度还是很快的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TensorFlow实战（才云郑泽宇著）读书笔记——第一章深度学习简介</title>
      <link>http://rootsongjc.github.io/blogs/tensorflow-practice-01/</link>
      <pubDate>Mon, 20 Mar 2017 22:04:33 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/tensorflow-practice-01/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-book-page.jpg&#34; alt=&#34;tensorflow实战图书封面&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：TensofFlow实战图书封面）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;🙏电子工业出版社编辑赠书，能够这么快的拿到这本书，也🙏&lt;a href=&#34;www.caicloud.io&#34;&gt;才云科技&lt;/a&gt;的郑泽宇大哥耐心的写了这本书，能够让我等小白一窥深度学习的真容。另外要强烈推荐下这本书，这是本TensorFlow深度学习很好的入门书。书中提供的代码&lt;a href=&#34;https://github.com/caicloud/tensorflow-tutorial&#34;&gt;下载地址&lt;/a&gt;，整本书的笔记归档在&lt;a href=&#34;http://rootsongjc.github.io/tags/tensorflow-practice-reading-notes&#34;&gt;这里&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;P.S 本书的&lt;strong&gt;官方读者交流微信群（作者也在群里）&lt;/strong&gt;已经超过100人，您可以先加我微信后我拉您进去，我的二维码在&lt;a href=&#34;rootsongjc.github.io/about&#34;&gt;这里&lt;/a&gt;，或者直接搜索我的微信号jimmysong。&lt;/p&gt;

&lt;h2 id=&#34;1-1-人工智能-机器学习与深度学习&#34;&gt;1.1 人工智能、机器学习与深度学习&lt;/h2&gt;

&lt;p&gt;这一节是讲解三者之间的关系。&lt;/p&gt;

&lt;p&gt;首先以&lt;strong&gt;垃圾邮件分类问题&lt;/strong&gt;引入机器学习的&lt;strong&gt;逻辑回归算法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;逻辑回归算法的准确性取决于训练数据中的特征的提取，以及训练的数据数量。&lt;/p&gt;

&lt;p&gt;文章中又提了一个从实体中提取特征的例子：通过笛卡尔坐标系活极角坐标系来表示不同颜色的点，看看能否用一条直线划分。这个例子用来说明&lt;strong&gt;一旦解决了数据表达和特征提取，很多人工智能的问题就能迎刃而解&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;深度学习是机器学习的一个分支，除了能够学习特征和任务之间的关联之外，还能&lt;strong&gt;自动从简单特征中提取更加复杂的特征&lt;/strong&gt;，这是其区别于机器学习的关键点。&lt;/p&gt;

&lt;p&gt;总的来说，人工智能&amp;gt;机器学习&amp;gt;深度学习。&lt;/p&gt;

&lt;h2 id=&#34;1-2深度学习的发展历程&#34;&gt;1.2深度学习的发展历程&lt;/h2&gt;

&lt;p&gt;本节介绍了深度网络历史的三个发展阶段。&lt;/p&gt;

&lt;p&gt;2012年的&lt;strong&gt;ImageNet&lt;/strong&gt;图像分类竞赛上，深度学习系统&lt;strong&gt;AlexNet&lt;/strong&gt;赢得冠军，自此深度学习作为深层神经网络的代名词而被人熟知。&lt;/p&gt;

&lt;h2 id=&#34;1-3深度学习的应用&#34;&gt;1.3深度学习的应用&lt;/h2&gt;

&lt;p&gt;这一节讲的是深度学习的应用，首先还是从ImageNet的图像识别开始，应用到了OCR（提到了卷积神经网络）、语音识别（提到了混合搞高斯模型）、自然语言处理（提到了语料库、单词向量、机器翻译、情感分析）、人机对弈（提到了AlphaGO）。&lt;/p&gt;

&lt;h2 id=&#34;1-4-深度学习工具介绍与对比&#34;&gt;1.4 深度学习工具介绍与对比&lt;/h2&gt;

&lt;p&gt;TensorFlow的渊源是Google大脑团队在2011年开发，在内部使用的&lt;strong&gt;DistBelief&lt;/strong&gt;，并赢得了ImageNet 2014年的比赛，TF是其开源版本，还发表了一篇论文&lt;code&gt;TensorFlow: Large-Scale Machine Learning on Heteogeneous Distributed systems&lt;/code&gt;，这就跟当年的&lt;strong&gt;HDFS&lt;/strong&gt;、&lt;strong&gt;MapReduce&lt;/strong&gt;一个套路啊。&lt;/p&gt;

&lt;p&gt;Google还把它用来做&lt;strong&gt;RankBrain&lt;/strong&gt;和很多其他的产品线上使用。&lt;/p&gt;

&lt;p&gt;当然，还有很多其他的深度学习工具，比如&lt;strong&gt;Caffe&lt;/strong&gt;、&lt;strong&gt;Deeplearning4j&lt;/strong&gt;、&lt;strong&gt;Torch&lt;/strong&gt;等不一而足。从各种指标来看，TensorFlow都是目前最受关注的深度学习框架。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>微服务设计读书笔记</title>
      <link>http://rootsongjc.github.io/talks/microservice-reading-notes/</link>
      <pubDate>Sat, 11 Mar 2017 15:45:27 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/talks/microservice-reading-notes/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20160625036.jpg&#34; alt=&#34;青海湖畔&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(题图：青海湖畔  Jun 25,2016)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;最近在看&lt;strong&gt;《微服务设计（Sam Newman著）》&lt;/strong&gt;这本书，&lt;a href=&#34;http://olz1di9xf.bkt.clouddn.com/docs/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E4%B8%AD%E6%96%87%E5%AE%8C%E6%95%B4%E7%89%88-Sam%20Newman-%E4%BA%BA%E6%B0%91%E9%82%AE%E7%94%B5%E5%87%BA%E7%89%88%E7%A4%BE.pdf&#34;&gt;下载本书PDF&lt;/a&gt;(扫描版，高清49.17M)。作者是&lt;strong&gt;ThoughtWorks&lt;/strong&gt;的Sam Newman。这本书中包括很多业界是用案例，比如&lt;strong&gt;Netflix&lt;/strong&gt;和&lt;strong&gt;亚马逊&lt;/strong&gt;。有兴趣的话大家一起看看讨论一下。😄&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E4%B9%A6%E7%9A%AE%E7%85%A7.jpg&#34; alt=&#34;微服务设计书皮照片&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本书读者交流微信群二维码，扫码入群（3月18日前有效）&lt;/strong&gt;，如果二维码失效，请移步&lt;a href=&#34;http://rootsongjc.github.io/about/&#34;&gt;这里&lt;/a&gt;加我微信，拉你入群。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E4%BA%A4%E6%B5%81%E7%BE%A4%E5%BE%AE%E4%BF%A1%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg&#34; alt=&#34;二维码&#34; /&gt;&lt;/p&gt;

&lt;p&gt;P.S 这本书比较偏理论，另外还有一本中国人写的书，&lt;strong&gt;《微服务架构与实践，王磊著，电子工业出版社》&lt;/strong&gt;，&lt;a href=&#34;http://olz1di9xf.bkt.clouddn.com/docs/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E7%8E%8B%E7%A3%8A%E8%91%97-%E7%94%B5%E5%AD%90%E5%B7%A5%E4%B8%9A%E5%87%BA%E7%89%88%E7%A4%BE.pdf&#34;&gt;下载本书的pdf&lt;/a&gt;，文字版，大小28.08M。这个人同样也是&lt;strong&gt;ThoughtWorks&lt;/strong&gt;的，两个人的观点不谋而合，依然是便理论的东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cloud Native Go - 基于Go和React的web云服务构建指南&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这本书是我最近在翻译的，将由&lt;strong&gt;电子工业出版社&lt;/strong&gt;出版，本书根据实际案例教你如何构建一个web微服务，是实践为服务架构的很好的参考。&lt;a href=&#34;http://rootsongjc.github.io/talks/cloud-native-go/&#34;&gt;查看本书介绍&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;1-微服务初探&#34;&gt;1.微服务初探&lt;/h2&gt;

&lt;h3 id=&#34;什么是微服务&#34;&gt;什么是微服务？&lt;/h3&gt;

&lt;p&gt;微服务（Microservices）这个词比较新颖，但是其实这种架构设计理念早就有了。&lt;em&gt;微服务是一种分布式架构设计理念，为了推动细粒度服务的使用，这些服务要能协同工作，每个服务都有自己的生命周期。一个为服务就是一个独立的实体，可以独立的部署在PAAS平台上，也可以作为一个独立的进程在主机中运行。服务之间通过API访问，修改一个服务不会影响其它服务。&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;微服务的好处&#34;&gt;微服务的好处&lt;/h3&gt;

&lt;p&gt;微服务的好处有很多，包括:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;帮助你更快的采用新技术&lt;/li&gt;
&lt;li&gt;解决技术异构的问题，因为是用API网络通信，可以使用不同的语言和技术开发不同的服务&lt;/li&gt;
&lt;li&gt;增强系统弹性，服务的边界比较清晰，便于故障处理&lt;/li&gt;
&lt;li&gt;方便扩展，比如使用容器技术，可以很方便的一次性启动很多个微服务&lt;/li&gt;
&lt;li&gt;方便部署，因为微服务之间彼此独立，所以能够独立的部署单个服务而不影响其它服务，如果部署失败的话还可以回滚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;别忘了康为定律，微服务可以很好契合解决组织架构问题&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可重用，可随意组合&lt;/li&gt;
&lt;li&gt;便于维护，可以随时重写服务，不必担心历史遗留问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;与面向服务架构soa的关系&#34;&gt;与面向服务架构SOA的关系&lt;/h3&gt;

&lt;p&gt;可以说微服务架构师SOA的一种，但是目前的大多数SOA做的都不好，在&lt;code&gt;通信协议的选择&lt;/code&gt;、&lt;code&gt;第三方中间件的选择&lt;/code&gt;、&lt;code&gt;服务力度如何划分&lt;/code&gt;方面做的都不够好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;微服务与SOA的共同点&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;都使用共享库，比如可重用的代码库&lt;/li&gt;
&lt;li&gt;模块化，比如Java中的OSGI(Open Source Gateway Initiative)、Erlang中的模块化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-架构师的职责&#34;&gt;2.架构师的职责&lt;/h2&gt;

&lt;h3 id=&#34;架构师应该关心是什么&#34;&gt;架构师应该关心是什么&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;架构师（Architect）&lt;/strong&gt;在英文中和&lt;strong&gt;建筑师&lt;/strong&gt;是同一个词，他们之间也有很多相同之处，架构师构建的是软件，而建筑师构建的是建筑。&lt;/p&gt;

&lt;p&gt;终于看到了我翻译的*Cloud Native Go*第14章中引用的这本书的原话了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%BC%95%E7%94%A8%E7%BF%BB%E8%AF%91.jpg&#34; alt=&#34;原话&#34; /&gt;&lt;/p&gt;

&lt;p&gt;软件的需求变更是&lt;strong&gt;来的那么快来的那么直接&lt;/strong&gt;，不像建筑那样可以在设计好后按照设计图纸一步步的去建设。&lt;/p&gt;

&lt;p&gt;架构师应该关心的是什么呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;保证系统适合开发人员在上面工作&lt;/li&gt;
&lt;li&gt;关注服务之间的交互，不需要过于关注各个服务内部发生的事情，比如服务之间互相调用的接口，是使用&lt;code&gt;protocol buffer&lt;/code&gt;呢，还是使用&lt;code&gt;RESTful API&lt;/code&gt;，还是使用&lt;code&gt;Java RMI&lt;/code&gt;，这个才是架构师需要关注的问题，至于服务内部究竟使用什么，那就看开发人员自己了，&lt;strong&gt;架构师更需要关注系统的边界和分区&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;架构师应该与团队在一起，&lt;strong&gt;结对编程&lt;/strong&gt; 🤓🤓 了解普通工作，知道普通的工作是什么样子，做一个&lt;em&gt;代码架构师&lt;/em&gt; 😂&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;架构师应该做什么&#34;&gt;架构师应该做什么&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;提供原则指导实践，比如Heroku的&lt;a href=&#34;http://rootsongjc.github.io/blogs/12-factor-app/&#34;&gt;12因素法则&lt;/a&gt;用来指导SAAS应用架构一样，微服务架构设计也要有一套原则。&lt;/li&gt;
&lt;li&gt;提供要求标准，通过日志功能和监控对服务进行集中式管理，明确接口标准，提供安全性建议。&lt;/li&gt;
&lt;li&gt;代码治理。为开发人员提供范例和服务代码模板。&lt;/li&gt;
&lt;li&gt;解决技术债务。&lt;/li&gt;
&lt;li&gt;集中治理和领导。维持良好的团队关系，当团队跑偏的时候及时纠正。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-服务建模&#34;&gt;3.服务建模&lt;/h2&gt;

&lt;p&gt;以&lt;strong&gt;MusicCorp&lt;/strong&gt;这家公司的服务为例子讲解。&lt;/p&gt;

&lt;p&gt;服务建模的两个指导原则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;高内聚：关键是找出问题的边界，把相关的问题放在同一个服务中。&lt;/li&gt;
&lt;li&gt;松耦合：修改一个服务不需要修改另一个。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用&lt;strong&gt;限定上下文&lt;/strong&gt;（一个由显示边界限定的特定指责）的方法将服务拆分，比如MusicCorp的服务可以拆分为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;财务部门&lt;/li&gt;
&lt;li&gt;仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;他们都不需要知道各自的具体实现，只要给它们提供特定的输入就会有你想要的产出。&lt;/p&gt;

&lt;p&gt;过早的将一个系统划分成微服务的代价非常高，尤其是在面对新领域时，将一个已有的代码库划分成微服务会比葱头开始建设微服务要简单的多。&lt;/p&gt;

&lt;h2 id=&#34;4-集成&#34;&gt;4.集成&lt;/h2&gt;

&lt;p&gt;使用共享数据库，为用户创建好接口，可以使用RPC（protocol buffer、thrift）或者REST。服务端和客户端消息格式可以用Json或XML。当然每种技术都有各自的适用场景，结合自己的业务选择。&lt;/p&gt;

&lt;p&gt;微服务的协作方式是什么样的呢？基于事件的异步通信，使用消息中间件来实现事件发布和消费者接收机制。比如用Kafka或RabbitMQ。&lt;/p&gt;

&lt;h2 id=&#34;5-分解单块系统&#34;&gt;5.分解单块系统&lt;/h2&gt;

&lt;p&gt;分解巨大无比没人感动的单块系统，首先要做的是理清代码库，找到&lt;strong&gt;接缝&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;分解系统带来的好处：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;加快以后系统开发速度&lt;/li&gt;
&lt;li&gt;划清了团队结构（又是康威定律）&lt;/li&gt;
&lt;li&gt;增加安全审计功能后，保障安全性&lt;/li&gt;
&lt;li&gt;利于开展新技术&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-部署&#34;&gt;6. 部署&lt;/h2&gt;

&lt;p&gt;这一块跟传统服务的部署并没有太大的不同，无非是微服务的短平快，加快了CI（持续集成）的速度。如果将微服务打包为docker镜像，使用Jenkins、ansible、puppet等技术来部署微服务可以实现部署自动和效率的显著提高。&lt;/p&gt;

&lt;h2 id=&#34;其它&#34;&gt;其它&lt;/h2&gt;

&lt;p&gt;该书的后面还讲了&lt;strong&gt;测试&lt;/strong&gt;、&lt;strong&gt;监控&lt;/strong&gt;、&lt;strong&gt;安全&lt;/strong&gt;、&lt;strong&gt;康威定律&lt;/strong&gt;、最后还上升到&lt;strong&gt;人本&lt;/strong&gt;，给予广大的软件开发人员强烈的人文关怀，可见提倡架构师要融入团队，最一个&lt;strong&gt;代码架构师&lt;/strong&gt;和&lt;strong&gt;结对编程&lt;/strong&gt;的作者是多么博爱❤️。&lt;/p&gt;

&lt;p&gt;该书的核心部分是&lt;strong&gt;第11章规模化微服务&lt;/strong&gt;，为将在下篇中来探讨一下。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cloud Native Go - 基于Go和React的web云服务构建指南</title>
      <link>http://rootsongjc.github.io/talks/cloud-native-go/</link>
      <pubDate>Fri, 03 Mar 2017 17:29:54 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/talks/cloud-native-go/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20160326003.jpg&#34; alt=&#34;北京植物园桃花&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(题图：北京植物园桃花 Mar 26,2016)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;更新于Apr 3,2017&lt;/p&gt;

&lt;p&gt;最近在翻译Kevin Hoffman和Dan Nemeth的书《Cloud Native Go - 基于Go和React的web云服务构建指南》。目前已经完成图书的翻译，已交给编辑校对。本书将由&lt;strong&gt;电子工业出版社&lt;/strong&gt;出版。&lt;/p&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Cloud Native Go向开发人员展示如何构建大规模云应用程序，在满足当今客户的强大需求的同时还可以动态扩展来处理几乎任何规模的数据量、流量或用户。&lt;/p&gt;

&lt;p&gt;Kevin Hoffman和Dan Nemeth详细描述了现代云原生应用程序，阐明了与快速、可靠的云原生开发相关的因素、规则和习惯。他们还介绍了Go这种“简单优雅”的高性能语言，它特别适合于云开发。&lt;/p&gt;

&lt;p&gt;在本书中你将使用Go语言创建微服务，使用ReactJS和Flux添加前端Web组件，并掌握基于Go的高级云原生技术。Hoffman和Nemeth展示了如何使用Wercker、Docker和Dockerhub等工具构建持续交付管道; 自动推送应用程序到平台上; 并系统地监控生产中的应用程序性能。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;学习“云之道”：为什么开发好的云软件基本上是关于心态和规则&lt;/li&gt;
&lt;li&gt;了解为什么使用Go语言是云本地微服务开发的理想选择&lt;/li&gt;
&lt;li&gt;规划支持持续交付和部署的云应用程序&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设计服务生态系统，然后以test-first的方式构建它们&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将正在进行的工作推送到云&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用事件源和CQRS模式来响应大规模和高吞吐量&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安全的基于云的Web应用程序：做与不做的选择&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用第三方消息传递供应商创建响应式云应用程序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用React和Flux构建大规模，云友好的GUI&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;监控云中的动态扩展，故障转移和容错&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面先罗列下目录，以飨读者。&lt;/p&gt;

&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;

&lt;p&gt;Cloud Native Go. 1&lt;/p&gt;

&lt;p&gt;构建基于Go和React的云原生Web应用&amp;hellip; 1&lt;/p&gt;

&lt;p&gt;云服务构建完全指南&amp;hellip; 1&lt;/p&gt;

&lt;p&gt;目录&amp;hellip; 4&lt;/p&gt;

&lt;p&gt;前言&amp;hellip; 8&lt;/p&gt;

&lt;p&gt;关于作者&amp;hellip; 9&lt;/p&gt;

&lt;p&gt;致谢&amp;hellip; 9&lt;/p&gt;

&lt;h3 id=&#34;第1章-云之道-10&#34;&gt;第1章        云之道&amp;hellip; 10&lt;/h3&gt;

&lt;p&gt;云的优势&amp;hellip; 10&lt;/p&gt;

&lt;p&gt;崇尚简洁&amp;hellip; 11&lt;/p&gt;

&lt;p&gt;测试优先，测试一切&amp;hellip; 11&lt;/p&gt;

&lt;p&gt;尽早发布, 频繁发布&amp;hellip; 12&lt;/p&gt;

&lt;p&gt;自动化一切&amp;hellip; 13&lt;/p&gt;

&lt;p&gt;建立服务生态系统&amp;hellip; 13&lt;/p&gt;

&lt;p&gt;为什么使用GO?. 14&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 15&lt;/p&gt;

&lt;h3 id=&#34;第2章-开始-16&#34;&gt;第2章        开始… 16&lt;/h3&gt;

&lt;p&gt;正确的工具&amp;hellip; 16&lt;/p&gt;

&lt;p&gt;配置Git 16&lt;/p&gt;

&lt;p&gt;建立Go. 18&lt;/p&gt;

&lt;p&gt;配置您的Go工作区&amp;hellip; 18&lt;/p&gt;

&lt;p&gt;检查环境&amp;hellip; 19&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 19&lt;/p&gt;

&lt;h3 id=&#34;第3章-go入门-20&#34;&gt;第3章        Go入门&amp;hellip; 20&lt;/h3&gt;

&lt;p&gt;建立Hello Cloud. 20&lt;/p&gt;

&lt;p&gt;使用基本函数&amp;hellip; 21&lt;/p&gt;

&lt;p&gt;使用结构体&amp;hellip; 23&lt;/p&gt;

&lt;p&gt;介绍Go接口&amp;hellip; 24&lt;/p&gt;

&lt;p&gt;向结构体添加方法&amp;hellip; 24&lt;/p&gt;

&lt;p&gt;Go中的接口动态类型检查&amp;hellip; 25&lt;/p&gt;

&lt;p&gt;使用第三方包&amp;hellip; 27&lt;/p&gt;

&lt;p&gt;创建自己的包&amp;hellip; 28&lt;/p&gt;

&lt;p&gt;导出函数和数据&amp;hellip; 28&lt;/p&gt;

&lt;p&gt;创建包&amp;hellip; 28&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 30&lt;/p&gt;

&lt;h3 id=&#34;第4章-持续交付-31&#34;&gt;第4章        持续交付&amp;hellip; 31&lt;/h3&gt;

&lt;p&gt;Docker介绍&amp;hellip; 31&lt;/p&gt;

&lt;p&gt;为什么要使用Docker？&amp;hellip; 31&lt;/p&gt;

&lt;p&gt;安装Docker 32&lt;/p&gt;

&lt;p&gt;运行Docker镜像&amp;hellip; 33&lt;/p&gt;

&lt;p&gt;与Wercker的持续集成&amp;hellip; 33&lt;/p&gt;

&lt;p&gt;持续集成最佳实践&amp;hellip; 34&lt;/p&gt;

&lt;p&gt;为什么使用Wercker？&amp;hellip; 34&lt;/p&gt;

&lt;p&gt;安装Wercker CLI 36&lt;/p&gt;

&lt;p&gt;创建Wercker配置文件&amp;hellip; 36&lt;/p&gt;

&lt;p&gt;使用Wercker进行构建&amp;hellip; 40&lt;/p&gt;

&lt;p&gt;部署到DockerHub. 41&lt;/p&gt;

&lt;p&gt;读者练习：创建完整的开发管道&amp;hellip; 42&lt;/p&gt;

&lt;p&gt;高级挑战：集成第三方库&amp;hellip; 42&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 43&lt;/p&gt;

&lt;h3 id=&#34;第5章-在go中构建微服务-44&#34;&gt;第5章        在Go中构建微服务&amp;hellip; 44&lt;/h3&gt;

&lt;p&gt;设计API First的服务&amp;hellip; 44&lt;/p&gt;

&lt;p&gt;通过Apiary测试和发布文档&amp;hellip; 46&lt;/p&gt;

&lt;p&gt;架设微服务&amp;hellip; 46&lt;/p&gt;

&lt;p&gt;构建Test First的服务&amp;hellip; 48&lt;/p&gt;

&lt;p&gt;创建第一个失败测试&amp;hellip; 49&lt;/p&gt;

&lt;p&gt;测试Location Header 51&lt;/p&gt;

&lt;p&gt;壮丽的蒙太奇 - 迭代测试&amp;hellip; 52&lt;/p&gt;

&lt;p&gt;在云中部署和运行&amp;hellip; 53&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 55&lt;/p&gt;

&lt;h3 id=&#34;第6章-运用后端服务-56&#34;&gt;第6章        运用后端服务&amp;hellip; 56&lt;/h3&gt;

&lt;p&gt;设计服务系统&amp;hellip; 56&lt;/p&gt;

&lt;p&gt;测试优先构建依赖服务&amp;hellip; 57&lt;/p&gt;

&lt;p&gt;构建Fulfillment服务&amp;hellip; 57&lt;/p&gt;

&lt;p&gt;构建Catalog服务&amp;hellip; 60&lt;/p&gt;

&lt;p&gt;在服务之间共享结构化数据&amp;hellip; 64&lt;/p&gt;

&lt;p&gt;使用服务捆绑去外部化地址与元数据&amp;hellip; 65&lt;/p&gt;

&lt;p&gt;服务发现&amp;hellip; 67&lt;/p&gt;

&lt;p&gt;读者练习&amp;hellip; 69&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 70&lt;/p&gt;

&lt;h3 id=&#34;第7章-构建数据服务-71&#34;&gt;第7章        构建数据服务&amp;hellip; 71&lt;/h3&gt;

&lt;p&gt;构建MongoDB存储库&amp;hellip; 71&lt;/p&gt;

&lt;p&gt;集成测试一个Mongo-Backed服务&amp;hellip; 76&lt;/p&gt;

&lt;p&gt;在云中运行&amp;hellip; 80&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 81&lt;/p&gt;

&lt;h3 id=&#34;第8章-事件源和cqrs-83&#34;&gt;第8章        事件源和CQRS.. 83&lt;/h3&gt;

&lt;p&gt;现实源自事件&amp;hellip; 83&lt;/p&gt;

&lt;p&gt;最终还是一致的&amp;hellip; 85&lt;/p&gt;

&lt;p&gt;介绍命令查询责任分离&amp;hellip; 86&lt;/p&gt;

&lt;p&gt;事件源案例&amp;hellip; 87&lt;/p&gt;

&lt;p&gt;代码示例：管理无人机军队&amp;hellip; 88&lt;/p&gt;

&lt;p&gt;构建命令处理程序服务&amp;hellip; 88&lt;/p&gt;

&lt;p&gt;构建事件处理器&amp;hellip; 92&lt;/p&gt;

&lt;p&gt;构建查询处理程序服务&amp;hellip; 95&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 96&lt;/p&gt;

&lt;h3 id=&#34;第9章-使用go构建web应用程序-97&#34;&gt;第9章 使用Go构建web应用程序&amp;hellip; 97&lt;/h3&gt;

&lt;p&gt;处理静态文件和资产&amp;hellip; 97&lt;/p&gt;

&lt;p&gt;支持javascript客户端&amp;hellip; 98&lt;/p&gt;

&lt;p&gt;使用服务端模板&amp;hellip; 100&lt;/p&gt;

&lt;p&gt;处理表单&amp;hellip; 102&lt;/p&gt;

&lt;p&gt;使用Cookie和会话状态&amp;hellip; 102&lt;/p&gt;

&lt;p&gt;使用Wercker构建和部署&amp;hellip; 104&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 105&lt;/p&gt;

&lt;h3 id=&#34;第10章-云安全-106&#34;&gt;第10章 云安全&amp;hellip; 106&lt;/h3&gt;

&lt;p&gt;保护一个web应用程序&amp;hellip; 106&lt;/p&gt;

&lt;p&gt;保护微服务&amp;hellip; 111&lt;/p&gt;

&lt;p&gt;隐私和数据安全&amp;hellip; 113&lt;/p&gt;

&lt;p&gt;阅读练习&amp;hellip; 114&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 115&lt;/p&gt;

&lt;h3 id=&#34;第11章-使用websockets-116&#34;&gt;第11章 使用WebSockets. 116&lt;/h3&gt;

&lt;p&gt;解析WebSockets. 116&lt;/p&gt;

&lt;p&gt;WebSockets和云的诞生&amp;hellip; 117&lt;/p&gt;

&lt;p&gt;使用消息传递提供程序构建WebSocket应用程序&amp;hellip; 119&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 122&lt;/p&gt;

&lt;h3 id=&#34;第12章-使用react构建web视图-123&#34;&gt;第12章 使用React构建web视图… 123&lt;/h3&gt;

&lt;p&gt;JavaScript State of the Union JavaScript  . 123&lt;/p&gt;

&lt;p&gt;为什么选择React？&amp;hellip; 123&lt;/p&gt;

&lt;p&gt;React应用程序的解剖&amp;hellip; 125&lt;/p&gt;

&lt;p&gt;构建一个简单的React应用程序&amp;hellip; 127&lt;/p&gt;

&lt;p&gt;测试React应用程序&amp;hellip; 132&lt;/p&gt;

&lt;p&gt;进一步阅读&amp;hellip; 132&lt;/p&gt;

&lt;p&gt;总结. 133&lt;/p&gt;

&lt;h3 id=&#34;第13章-使用flux构建高可扩展性ui-134&#34;&gt;第13章      使用Flux构建高可扩展性UI 134&lt;/h3&gt;

&lt;p&gt;Flux介绍&amp;hellip; 134&lt;/p&gt;

&lt;p&gt;创建Flux应用程序&amp;hellip; 136&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 141&lt;/p&gt;

&lt;h3 id=&#34;第14章-创建完整应用world-of-fluxcraft-143&#34;&gt;第14章      创建完整应用World of FluxCraft 143&lt;/h3&gt;

&lt;p&gt;World of FluxCraft介绍&amp;hellip; 143&lt;/p&gt;

&lt;p&gt;架构概览&amp;hellip; 145&lt;/p&gt;

&lt;p&gt;Flux GUI 146&lt;/p&gt;

&lt;p&gt;命令处理&amp;hellip; 148&lt;/p&gt;

&lt;p&gt;事件处理&amp;hellip; 149&lt;/p&gt;

&lt;p&gt;维持现实服务的状态&amp;hellip; 149&lt;/p&gt;

&lt;p&gt;地图管理&amp;hellip; 150&lt;/p&gt;

&lt;p&gt;自动验收测试&amp;hellip; 150&lt;/p&gt;

&lt;p&gt;总结&amp;hellip; 151&lt;/p&gt;

&lt;h3 id=&#34;第15章-结论-152&#34;&gt;第15章     结论&amp;hellip; 152&lt;/h3&gt;

&lt;p&gt;我们学到了什么？&amp;hellip; 152&lt;/p&gt;

&lt;p&gt;下一步&amp;hellip; 153&lt;/p&gt;

&lt;h3 id=&#34;a云应用的故障排查-154&#34;&gt;A云应用的故障排查… 154&lt;/h3&gt;

&lt;p&gt;使用日志流&amp;hellip; 154&lt;/p&gt;

&lt;p&gt;健康和性能监控&amp;hellip; 154&lt;/p&gt;

&lt;p&gt;在云中调试应用程序&amp;hellip; 155&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>