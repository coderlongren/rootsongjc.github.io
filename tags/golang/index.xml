<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Jimmy Song&#39;s Blog</title>
    <link>http://rootsongjc.github.io/tags/golang/</link>
    <description>Recent content in Golang on Jimmy Song&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Mar 2017 08:36:29 +0800</lastBuildDate>
    
	<atom:link href="http://rootsongjc.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go语言中的并发编程总结</title>
      <link>http://rootsongjc.github.io/projects/golang-concurrency-summary/</link>
      <pubDate>Fri, 24 Mar 2017 08:36:29 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/projects/golang-concurrency-summary/</guid>
      <description>Go语言并发编程总结  Golang :不要通过共享内存来通信，而应该通过通信来共享内存。这句风靡在Go社区的话,说的就是 goroutine中的 channel。他在go并发编程中充当着类型安全的管道作用。
 1、通过golang中的 goroutine 与sync.Mutex进行并发同步 import( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; &amp;quot;runtime&amp;quot; ) var count int =0; func counter(lock * sync.Mutex){ lock.Lock() count++ fmt.Println(count) lock.Unlock() } func main(){ lock:=&amp;amp;sync.Mutex{} for i:=0;i&amp;lt;10;i++{ //传递指针是为了防止 函数内的锁和 调用锁不一致 go counter(lock) } for{ lock.Lock() c:=count lock.Unlock() ///把时间片给别的goroutine 未来某个时刻运行该routine runtime.Gosched() if c&amp;gt;=10{ fmt.Println(&amp;quot;goroutine end&amp;quot;) break } } }  2、goroutine之间通过 channel进行通信 channel是和类型相关的 可以理解为 是一种类型安全的管道。
简单的channel 使用
package main import &amp;quot;fmt&amp;quot; func Count(ch chan int) { ch &amp;lt;- 1 fmt.</description>
    </item>
    
    <item>
      <title>Cloud Native Go - 基于Go和React的web云服务构建指南</title>
      <link>http://rootsongjc.github.io/talks/cloud-native-go/</link>
      <pubDate>Fri, 03 Mar 2017 17:29:54 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/talks/cloud-native-go/</guid>
      <description>(题图：北京植物园桃花 Mar 26,2016)
最近在翻译Kevin Hoffman和Dan Nemeth的书《Cloud Native Go - 基于Go和React的web云原生应用构建指南》。正在进行最终的校对。本书将由电子工业出版社出版。
简介 Cloud Native Go向开发人员展示如何构建大规模云应用程序，在满足当今客户的强大需求的同时还可以动态扩展来处理几乎任何规模的数据量、流量或用户。
Kevin Hoffman和Dan Nemeth详细描述了现代云原生应用程序，阐明了与快速、可靠的云原生开发相关的因素、规则和习惯。他们还介绍了Go这种“简单优雅”的高性能语言，它特别适合于云开发。
在本书中你将使用Go语言创建微服务，使用ReactJS和Flux添加前端Web组件，并掌握基于Go的高级云原生技术。Hoffman和Nemeth展示了如何使用Wercker、Docker和Dockerhub等工具构建持续交付管道; 自动推送应用程序到平台上; 并系统地监控生产中的应用程序性能。
 学习“云之道”：为什么开发好的云软件基本上是关于心态和规则 了解为什么使用Go语言是云本地微服务开发的理想选择 规划支持持续交付和部署的云应用程序 设计服务生态系统，然后以test-first的方式构建它们
 将正在进行的工作推送到云
 使用事件源和CQRS模式来响应大规模和高吞吐量
 安全的基于云的Web应用程序：做与不做的选择
 使用第三方消息传递供应商创建响应式云应用程序
 使用React和Flux构建大规模，云友好的GUI
 监控云中的动态扩展，故障转移和容错
  下面先罗列下目录，以飨读者。
目录 Cloud Native Go. 1
构建基于Go和React的云原生Web应用&amp;hellip; 1
云服务构建完全指南&amp;hellip; 1
目录&amp;hellip; 4
前言&amp;hellip; 8
关于作者&amp;hellip; 9
致谢&amp;hellip; 9
第1章 云之道&amp;hellip; 10 云的优势&amp;hellip; 10
崇尚简洁&amp;hellip; 11
测试优先，测试一切&amp;hellip; 11
尽早发布, 频繁发布&amp;hellip; 12</description>
    </item>
    
  </channel>
</rss>