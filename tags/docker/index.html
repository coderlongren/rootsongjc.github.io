<!DOCTYPE html>
<html class="no-js" lang="en-US" prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#">
<head>
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="description" content="">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="keywords" content="">

 
<meta property="og:type" content="article"/>
<meta property="og:description" content=""/>
<meta property="og:title" content="Docker : rootsongjc.github.io"/>
<meta property="og:site_name" content="rootsongjc is Jimmy Song"/>
<meta property="og:image" content="" />
<meta property="og:image:type" content="image/jpeg" />
<meta property="og:image:width" content="" />
<meta property="og:image:height" content="" />
<meta property="og:url" content="http://rootsongjc.github.io/tags/docker/">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2017-03-10"/>
<meta property="article:modified_time" content="2017-03-10"/>





<meta name="twitter:card" content="summary">

<meta name="twitter:site" content="@rootsongjc">
<meta name="twitter:title" content="Docker : rootsongjc.github.io">
<meta name="twitter:creator" content="@rootsongjc">
<meta name="twitter:description" content="">
<meta name="twitter:image:src" content="">
<meta name="twitter:domain" content="rootsongjc.github.io">


    <base href="http://rootsongjc.github.io/">
    <title> Docker - rootsongjc.github.io </title>
    <link rel="canonical" href="http://rootsongjc.github.io/tags/docker/">
    <link href="http://rootsongjc.github.io/tags/docker/index.xml" rel="alternate" type="application/rss+xml" title="Docker" />

    
<link rel="stylesheet" href="/static/css/style.css">
<script src="https://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://yandex.st/highlightjs/8.0/styles/default.min.css">
<script>hljs.initHighlightingOnLoad();</script>

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
</head>

<body lang="en">
<header id="header">
    <figure>
      <a href="/" border=0 id="logolink"><div class="icon-octocat" id="logo"> </div></a>
    </figure>
    <div id="byline">by Jimmy Song</div>
    <nav id="nav">
            <ul id="mainnav">
            <li>
                <a href="/blogs/">
                <span class="icon"> <i aria-hidden="true" class="icon-quill"></i></span>
                <span> blogs </span>
            </a>
            </li>
            <li>
            <a href="/projects/">
                <span class="icon"> <i aria-hidden="true" class="icon-console"></i></span>
                <span> projects </span>
            </a>
            </li>
            <li>
            <a href="/talks/">
                <span class="icon"> <i aria-hidden="true" class="icon-stats"></i></span>
                <span> talks </span>
            </a>
            </li>
            <li>
            <a href="http://www.linkedin.com/in/rootsongjc">
                <span class="icon"> <i aria-hidden="true" class="icon-linkedin"></i></span>
                <span> me </span>
            </a>
            </li>
        </ul>

            <ul id="social">
            <li id="share">
                <span class="icon icon-bubbles"> </span>
                <span class="title"> share </span>
                <div class="dropdown share">
                    <ul class="social">
                      <li> <a href="https://twitter.com/intent/tweet?status=Docker-http%3a%2f%2frootsongjc.github.io%2ftags%2fdocker%2f" target="_blank" title="Follow me on Twitter" class="twitter"><span class="icon icon-twitter"></span>Twitter</a> </li>
                        <li> <a href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2frootsongjc.github.io%2ftags%2fdocker%2f" target="_blank" title="Join me on Facebook" class="facebook"><span class="icon icon-facebook"></span>Facebook</a> </li>
                        <li> <a href="https://plus.google.com/share?url=http%3a%2f%2frootsongjc.github.io%2ftags%2fdocker%2f" target="_blank" title="Google+" class="googleplus"><span class="icon icon-google-plus"></span>Google+</a> </li>
                        <li> <a href="http://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2frootsongjc.github.io%2ftags%2fdocker%2f&title=Docker&source=spf13" target="_blank" title="LinkedIn" class="linkedin"><span class="icon icon-linkedin"></span>LinkedIn</a> </li>
                        <li> <a href="http://del.icio.us/post?url=http%3a%2f%2frootsongjc.github.io%2ftags%2fdocker%2f" target="_blank" title="Delicious" class="delicious"><span class="icon icon-delicious"></span>Delicious</a> </li>
                        <li> <a href="http://www.reddit.com/submit?url=http%3a%2f%2frootsongjc.github.io%2ftags%2fdocker%2f" target="_blank" title="Reddit" class="reddit"><span class="icon icon-reddit"></span>Reddit</a> </li>
                    </ul>
                    <span class="subcount">sharing is caring</span>
                </div>
            </li>
            <li id="follow">
                <span class="icon icon-rocket"> </span>
                <span class="title"> follow </span>
                <div class="dropdown follow">
                    <ul class="social">
                        <li> <a href="http://www.twitter.com/rootsongjc" target="_blank" title="Follow me on Twitter" class="twitter"><span class="icon icon-twitter"></span>Twitter</a> </li>
                        <li> <a href="http://www.facebook.com/rootsongjc" target="_blank" title="Join me on Facebook" class="facebook"><span class="icon icon-facebook"></span>Facebook</a> </li>
                        <li> <a href="http://www.linkedin.com/in/rootsongjc" target="_blank" title="LinkedIn" class="linkedin"><span class="icon icon-linkedin"></span>LinkedIn</a> </li>
                        <li> <a href="http://github.com/rootsongjc" target="_blank" title="GitHub" class="github"><span class="icon icon-github"></span>GitHub</a> </li>
                        <li> <a href="https://www.douban.com/people/deamonj/" target="_blank" title="豆瓣" class="facebook"><span class="icon icon-idea"></span>Douban</a> </li>
                        <li> <a href="https://tuchong.com/1425795/" target="_blank" title="图虫" class="github"><span class="icon icon-cc-2"></span>Tuchong</a> </li>                    </ul>
                    <span class="subcount">join 10k+ subscribers &amp; followers</span>
                </div>
            </li>
          </ul>

    </nav>
</header>


<section id="main">
  <div>
   <h1 id="title">Docker</h1>
    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/docker-vs-kubernetes-part1/">Docker v.s Kubernetes part1 </a> </h2>
      <div class="post-meta">Fri, Mar 10, 2017 </div>
    </header>

     （题图：杭州西湖）
前言 这一系列文章是对比kubernetes 和docker两者之间的差异，鉴于我之前从docker1.10.3起开始使用docker，对原生docker的了解比较多，最近又正在看Kunernetes权威指南（第二版）这本书（P.S感谢电子工业出版社的编辑朋友赠送此书）。这系列文章不是为了比较孰优孰劣，适合自己的才是最好的。
此系列文章中所说的docker指的是*17.03-ce*版本。
概念性的差别 Kubernetes
了解一样东西首先要高屋建瓴的了解它的概念，kubernetes包括以下几种资源对象：
 Pod Service Volume Namespace ReplicaSet Deployment StatefulSet DaemonSet Job  Docker
Docker的资源对象相对于kubernetes来说就简单多了，只有以下几个：
 Service Node Stack Docker  就这么简单，使用一个*docker-compose.yml*即可以启动一系列服务。当然简单的好处是便于理解和管理，但是在功能方面就没有kubernetes那么强大了。
功能性差别  Kubernetes 资源限制 CPU 100m千分之一核为单位，绝对值，requests 和limits，超过这个值可能被杀掉，资源限制力度比docker更细。 Pod中有个最底层的pause 容器，其他业务容器共用他的IP，docker因为没有这层概念，所以没法共用IP，而是使用overlay网络同处于一个网络里来通信。 Kubernetes在rc中使用环境变量传递配置（1.3版本是这样的，后续版本还没有研究过） Kuberentes Label 可以在开始和动态的添加修改，所有的资源对象都有，这一点docker也有，但是资源调度因为没有kubernetes那么层级，所有还是相对比较弱一些。 Kubernetes对象选择机制继续通过label selector，用于对象调度 HPA horizontal pod autoscaling 横向移动扩容，也是一种资源对象，根据负载变化情况针对性的调整pod目标副本数。 Kubernetes中有三个IP，Node,Pod,Cluster IP的关系比较复杂，docker中没有Cluster IP的概念。 持久化存储，在Kubernetes中有Persistent volume 只能是网络存储，不属于任何node，独立于pod之外，而docker只能使用volume plugin。 多租户管理，kubernetes中有`Namespace，docker暂时没有多租户管理功能。  总体来说Docker架构更加简单，使用起来也没有那么多的配置，只需要每个结点都安装docker即可，调度和管理功能没kubernetes那么复杂。但是kubernetes本身就是一个通用的数据中心管理工具，不仅可以用来管理docker，*pod*这个概念里就可以运行不仅是docker了。
 以后的文章中将结合docker着重讲Kubernetes，基于1.3版本。
 
    <footer>
        <a href='http://rootsongjc.github.io/blogs/docker-vs-kubernetes-part1/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/docker-plugin-develop/">Docker插件开发-sshfs示例 </a> </h2>
      <div class="post-meta">Fri, Mar 10, 2017 </div>
    </header>

    （题图：杭州吴山步道旁的墙壁）
官方示例文档
官方以开发一个sshfs的volume plugin为例。
$ git clone https://github.com/vieux/docker-volume-sshfs $ cd docker-volume-sshfs $ go get github.com/docker/go-plugins-helpers/volume $ go build -o docker-volume-sshfs main.go $ docker build -t rootfsimage . $ id=$(docker create rootfsimage true) # id was cd851ce43a403 when the image was created $ sudo mkdir -p myplugin/rootfs $ sudo docker export &quot;$id&quot; | sudo tar -x -C myplugin/rootfs $ docker rm -vf &quot;$id&quot; $ docker rmi rootfsimage  我们可以看到sshfs的Dockerfile是这样的：
FROM alpine RUN apk update &amp;&amp; apk add sshfs RUN mkdir -p /run/docker/plugins /mnt/state /mnt/volumes COPY docker-volume-sshfs docker-volume-sshfs CMD [&quot;docker-volume-sshfs&quot;]  实际上是讲编译好的可执行文件复制到alpine linux容器中运行。
    <footer>
        <a href='http://rootsongjc.github.io/blogs/docker-plugin-develop/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/contiv-v2plugin/">Contiv入坑指南-v2plugin </a> </h2>
      <div class="post-meta">Fri, Mar 10, 2017 </div>
    </header>

    (题图：上海交通大学)
继续趟昨天挖的坑。
昨天的issue-776已经得到@gkvijay的回复，原来是因为没有安装contiv/v2plugin的缘故，所以create contiv network失败，我需要自己build一个docker plugin。
查看下这个commit里面有build v2plugin的脚本更改，所以直接调用以下命令就可以build自己的v2plugin。
前提你需要先build出netctl、netmaster、netplugin三个二进制文件并保存到bin目录下，如果你没自己build直接下载release里面的文件保存进去也行。
编译v2plugin插件 修改config.json插件配置文件
{ &quot;manifestVersion&quot;: &quot;v0&quot;, &quot;description&quot;: &quot;Contiv network plugin for Docker&quot;, &quot;documentation&quot;: &quot;https://contiv.github.io&quot;, &quot;entrypoint&quot;: [&quot;/startcontiv.sh&quot;], &quot;network&quot;: { &quot;type&quot;: &quot;host&quot; }, &quot;env&quot;: [ { &quot;Description&quot;: &quot;To enable debug mode, set to '-debug'&quot;, &quot;Name&quot;: &quot;dbg_flag&quot;, &quot;Settable&quot;: [ &quot;value&quot; ], &quot;Value&quot;: &quot;-debug&quot; }, { &quot;Description&quot;: &quot;VLAN uplink interface used by OVS&quot;, &quot;Name&quot;: &quot;iflist&quot;, &quot;Settable&quot;: [ &quot;value&quot; ], &quot;Value&quot;: &quot;&quot; }, { &quot;Description&quot;: &quot;Etcd or Consul cluster store url&quot;, &quot;Name&quot;: &quot;cluster_store&quot;, &quot;Settable&quot;: [ &quot;value&quot; ], &quot;Value&quot;: &quot;etcd://172.
    <footer>
        <a href='http://rootsongjc.github.io/blogs/contiv-v2plugin/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/contiv-tryout/">Contiv入坑指南-试用全记录 </a> </h2>
      <div class="post-meta">Thu, Mar 9, 2017 </div>
    </header>

    (题图：北纬37度黄海之滨风力发电场，冬天的大风持续给人类提供清洁的能源）
关于contiv的介绍请看我的上一篇文章Contiv Intro。
开发环境使用Vagrant搭建，昨天试用了下，真不知道它们是怎么想的，即然是docker插件为啥不直接在docker中开发呢，我有篇文章介绍如何搭建docker开发环境，可以在docker中开发docker，当然也可以用来开发contiv啊😄，只要下载一个docker镜像dockercore/docker:latest即可，不过有点大2.31G，使用阿里云的mirror下载倒是也划算，总比你自己部署一个开发环境节省时间。
Contiv概念解析 Contiv用于给容器创建和分配网路，可以创建策略管理容器的安全、带宽、优先级等，相当于一个SDN。
Group 按容器或Pod的功能给容器分配策略组，通常是按照容器/Pod的label来分组，应用组跟contiv的network不是一一对应的，可以很多应用组属于同一个network或IP subnet。
Polices 用来限定group的行为，contiv支持两种类型的policy：
 Bandwidth 限定应用组的资源使用上限 Isolation 资源组的访问权限  Group可以同时应用一个或多个policy，当有容器调度到该group里就会适用该group的policy。
Network IPv4或IPv6网络，可以配置subnet和gateway。
Contiv中的网络
在contiv中可以配置两种类型的网络
 application network：容器使用的网络 infrastructure network：host namespace的虚拟网络，比如基础设施监控网络  网络封装
Contiv中有两种类型的网络封装
 Routed：overlay topology和L3-routed BGP topology Bridged：layer2 VLAN  Tenant Tenant提供contiv中的namespace隔离。一个tenant可以有很多个network，每个network都有个subnet。该tenant中的用户可以使用它的任意network和subnet的IP。
物理网络中的tenant称作虚拟路由转发(VRF)。Contiv使用VLAN和VXLAN ID来实现外部网络访问，这取决你使用的是layer2、layer3还是Cisco ACI。
Contiv下载 Contiv的编译安装比较复杂，我们直接下载github上的release-1.0.0-beta.3-03-08-2017.18-51-20.UTC文件解压获得二进制文件安装。
 https://github.com/contiv/install/blob/master/README.md这个官方文档已经过时，不要看了。
 如果试用可以的话，我会后续写contiv开发环境搭建的文章。
这个release是2017年3月8日发布的，就在我写这篇文章的前一天。有个最重要的更新是支持docker1.13 swarm mode。
官方安装文档
下载解压后会得到如下几个文件：
 contivk8s k8s专用的 contrib 文件夹，里面有个netctl的bash脚本 netcontiv 这个命令就一个-version选项用来查看contiv的版本😓 netctl contiv命令行工具，用来配置网络、策略、服务负载均衡，使用说明 netmaster contiv的主节点服务 netplugin  下面的安装中用到的只有netctl、netmaster和netplugin这三个二进制文件。
    <footer>
        <a href='http://rootsongjc.github.io/blogs/contiv-tryout/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/contiv-guide/">Contiv Intro </a> </h2>
      <div class="post-meta">Thu, Mar 9, 2017 </div>
    </header>

    (题图：北京蓝色港湾夜景)
Contiv是思科开发的docker网络插件，从2015年就开源了，业界通常拿它和Calico比较。貌似Contiv以前还开发过volume plugin，现在销声匿迹了，只有netplugin仍在活跃开发。
容器网络插件 Calico 与 Contiv Netplugin深入比较
还有篇文章讲解了docker网络方案的改进
Contiv Netplugin 简介 Contiv Netplugin 是来自思科的解决方案。编程语言为 Go。它基于 OpenvSwitch，以插件化的形式支持容器访问网络，支持 VLAN，Vxlan，多租户，主机访问控制策略等。作为思科整体支持容器基础设施contiv项目的网络部分，最大的亮点在于容器被赋予了 SDN 能力，实现对容器更细粒度，更丰富的访问控制功能。另外，对 Docker CNM 网络模型的支持，并内置了 IPAM 接口，不仅仅提供了一容器一 IP，而且容器的网络信息被记录的容器配置中，伴随着容器的整个生命周期，减低因为状态不同步造成网络信息丢失的风险。有别于 CNI，这种内聚化的设计有利于减少对第三方模块的依赖。随着项目的发展，除了 Docker，还提供了对 Kubernetes 以及 Mesos 的支持，即 CNI 接口。

 Netmaster 后台进程负责记录所有节点状态，保存网络信息，分配 IP 地址 Netplugin 后台进程作为每个宿主机上的 Agent 与 Docker 及 OVS 通信，处理来自 Docker 的请求，管理 OVS。Docker 方面接口为 remote driver，包括一系列 Docker 定义的 JSON-RPC(POST) 消息。OVS 方面接口为 remote ovsdb，也是 JSON-RPC 消息。以上消息都在 localhost 上处理。 集群管理依赖 etcd/serf
    <footer>
        <a href='http://rootsongjc.github.io/blogs/contiv-guide/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/projects/docker_tech_selection/">docker技术选型 </a> </h2>
      <div class="post-meta">Wed, Mar 8, 2017 </div>
    </header>

    回顾历史  多少次我回过头看看走过的路，你还在小村旁。
 去年基于docker1.11对Hadoop yarn进行了docker化改造，详情请看大数据集群虚拟化-Yarn on docker始末，我将这个事件命名为magpie，因为它就像是喜鹊一样收集着各种各样的资源搭建自己的小窝。magpie还是有很多事情可以做的，大数据集群的虚拟化也不会止步，它仅仅是对其做了初步的探索，对于资源利用率和管理方面的优化还有很长的路要走，Yarn本身就是做为大数据集群的资源管理调度角色出现的，一开始是为调度MapReduce，后来的spark、hive、tensrflow、HAWQ、slide等等不一而足陆续出现。但是用它来管理docker似乎还是有点过重，还不如用kubernetes、marathon、nomad、swarm等。
但是在微服务方面docker1.11的很多弊端或者说缺点就暴露了出来，首先docker1.11原生并不带cluster管理，需要配合·docker swarm、kubernetes、marathon等才能管理docker集群。之前的对于docker的使用方式基本就是按照虚拟机的方式使用的，固定IP有悖于微服务的原则。
我们基于docker1.11和shrike二层网络模式，还有shipyard来做集群管理，shipyard只是一个简单的docker集群管理的WebUI，基本都是调用docker API，唯一做了一点docker原生没有的功能就是scale容器，而且只支持到docker1.11，早已停止开发。我抛弃了shipyard，它的页面功能基本可有可无，我自己开发的magpie一样可以管理yarn on docker集群。
Docker Swarm有如下几个缺点
 对于大规模集群的管理效率太低，当管理上百个node的时候经常出现有节点状态不同步的问题，比如主机重启后容器已经Exited了，但是master让然认为是Running状态，必须重启所有master节点才行。 没有中心化Node管理功能，必须登录到每台node上手动启停swarm-agent。 集群管理功能实在太太太简陋，查看所有node状态只能用docker info而且那个格式就不提了，shipyard里有处理这个格式的代码，我copy到了magpie里，彻底抛弃shipyard了。 Docker swarm的集群管理概念缺失，因为docker一开始设计的时候就不是用来管理集群的，所以出现了swarm，但是只能使用docker-compose来编排服务，但是无法在swarm集群中使用我们自定义的mynet网络，compose issue-4233，compose也已经被docker官方废弃（最近一年docker发展的太快了，原来用python写的compose已经被用go重构为libcompose直接集成到swarm mode里了），而且docker1.11里也没有像kubernetes那样service的单位，在docker1.11所有的管理都是基于docker容器的。  Docker Swarm的问题也是shipyard的问题，谁让shipyard直接调用docker的API呢。当然，在后续版本的docker里以上问题都已经不是问题，docker已经越来越像kubernetes，不论是在设计理念上还是在功能上，甚至还发行了企业版，以后每个月发布一个版本。
技术选型 主要对比Docker1.11和Docker17.03-ce版本。
首先有一点需要了解的是，docker1.12+带来的swarm mode，你可以使用一个命令直接启动一个复杂的stack，其中包括了服务编排和所有的服务配置，这是一个投票应用的例子。
下表对比了docker1.11和docker17.03-ce
   版本 docker1.11 docker17.03-ce     基本单位 docker容器 docker容器、service、stack   服务编排 compose，不支持docker swarm的mynet网络 改造后的compose，支持stack中完整的服务编排   网络模型 Host、bridge、overlay、mynet 默认支持跨主机的overlay网络，创建单个容器时也可以attach到已有的overla网络中   插件 没有插件管理命令，但是可以手动创建和管理 有插件管理命令，可以手动创建和从docker hub中下载，上传插件到自己的私有镜像仓库   升级 不支持平滑升级，重启docker原来的容器也会停掉 可以停止docker engine但不影响已启动的容器   弹性伸缩 不支持 service内置功能   服务发现 监听docker event增删DNS 内置服务发现，根据DNS负载均衡   节点管理 手动启停 中心化管理node节点   服务升级 手动升级 service内置功能   负载均衡 本身不支持 Swarm mode内部DNS轮寻    基于以上对比，使用docker17.
    <footer>
        <a href='http://rootsongjc.github.io/projects/docker_tech_selection/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/docker-dev-env/">docker源码编译和开发环境搭建 </a> </h2>
      <div class="post-meta">Mon, Mar 6, 2017 </div>
    </header>

    看了下网上其他人写的docker开发环境搭建，要么是在ubuntu下搭建，要么就是使用官方说明的build docker-dev镜像的方式一步步搭建的，甚是繁琐，docker hub上有一个docker官方推出的dockercore/docker镜像，其实这就是官网上所说的docker-dev镜像，不过以前的那个deprecated了，使用目前这个镜像搭建docker开发环境是最快捷的了。
想要修改docker源码和做docker定制开发的同学可以参考下。
官方指导文档：https://docs.docker.com/opensource/code/
设置docker开发环境：https://docs.docker.com/opensource/project/set-up-dev-env/
docker的编译实质上是在docker容器中运行docker。
因此在本地编译docker的前提是需要安装了docker，还需要用git把代码pull下来。
创建分支 为了方便以后给docker提交更改，我们从docker官方fork一个分支。
git clone https://github.com/rootsongjc/docker.git git config --local user.name &quot;Jimmy Song&quot; git config --local user.email &quot;rootsongjc@gmail.com&quot; git remote add upstream https://github.com/docker/docker.git git config --local -l git remote -v git checkout -b dry-run-test touch TEST.md vim TEST.md git status git add TEST.md git commit -am &quot;Making a dry run test.&quot; git push --set-upstream origin dry-run-test  然后就可以在dry-run-test这个分支下工作了。
配置docker开发环境 官网上说需要先清空自己电脑上已有的容器和镜像。
docker开发环境本质上是创建一个docker镜像，镜像里包含了docker的所有开发运行环境，本地代码通过挂载的方式放到容器中运行，下面这条命令会自动创建这样一个镜像。
在dry-run-test分支下执行
make BIND_DIR=.
    <footer>
        <a href='http://rootsongjc.github.io/blogs/docker-dev-env/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/talks/cloud-native-go/">cloud native go </a> </h2>
      <div class="post-meta">Fri, Mar 3, 2017 </div>
    </header>

    最近在翻译Kevin Hoffman和Dan Nemeth的书《Cloud Native Go》。预计本月将完成，将由电子工业出版社出版。
    <footer>
        <a href='http://rootsongjc.github.io/talks/cloud-native-go/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/docker-service-discovery/">docker service discovery </a> </h2>
      <div class="post-meta">Mon, Feb 27, 2017 </div>
    </header>

    Prior to Docker 1.12 release, setting up Swarm cluster needed some sort of service discovery backend. There are multiple discovery backends available like hosted discovery service, using a static file describing the cluster, etcd, consul, zookeeper or using static list of IP address.

Thanks to Docker 1.12 Swarm Mode, we don’t have to depend upon these external tools and complex configurations. Docker Engine 1.12 runs it’s own internal DNS service to route services by name.
    <footer>
        <a href='http://rootsongjc.github.io/blogs/docker-service-discovery/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/docker-embedded-dns/">docker embedded dns </a> </h2>
      <div class="post-meta">Mon, Feb 27, 2017 </div>
    </header>

    本文主要介绍了Docker容器的DNS配置及其注意点，重点对docker 1.10发布的embedded DNS server进行了源码分析，看看embedded DNS server到底是个啥，它是如何工作的。
Configure container DNS DNS in default bridge network    Options Description     -h HOSTNAME or –hostname=HOSTNAME 在该容器启动时，将HOSTNAME设置到容器内的/etc/hosts, /etc/hostname, /bin/bash提示中。   –link=CONTAINER_NAME or ID:ALIAS 在该容器启动时，将ALIAS和CONTAINER_NAME/ID对应的容器IP添加到/etc/hosts. 如果 CONTAINER_NAME/ID有多个IP地址 ？   –dns=IP_ADDRESS… 在该容器启动时，将nameserver IP_ADDRESS添加到容器内的/etc/resolv.conf中。可以配置多个。   –dns-search=DOMAIN… 在该容器启动时，将DOMAIN添加到容器内/etc/resolv.conf的dns search列表中。可以配置多个。   –dns-opt=OPTION… 在该容器启动时，将OPTION添加到容器内/etc/resolv.conf中的options选项中，可以配置多个。     说明：
 如果docker run时不含--dns=IP_ADDRESS..., --dns-search=DOMAIN..., or --dns-opt=OPTION...参数，docker daemon会将copy本主机的/etc/resolv.conf，然后对该copy进行处理（将那些/etc/resolv.conf中ping不通的nameserver项给抛弃）,处理完成后留下的部分就作为该容器内部的/etc/resolv.conf。因此，如果你想利用宿主机中的/etc/resolv.conf配置的nameserver进行域名解析，那么你需要宿主机中该dns service配置一个宿主机内容器能ping通的IP。 如果宿主机的/etc/resolv.conf内容发生改变，docker daemon有一个对应的file change notifier会watch到这一变化，然后根据容器状态采取对应的措施：  如果容器状态为stopped，则立刻根据宿主机的/etc/resolv.
    <footer>
        <a href='http://rootsongjc.github.io/blogs/docker-embedded-dns/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
  </div>
</section>

<aside id="meta"> </aside>

<footer>
  <div>
    <p>
    &copy; 2013-2017 <span itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Jimmy Song</span></span>
    Powered by <a href="http://gohugo.io">Hugo</a>.
    </p>
  </div>
</footer>
<script type="text/javascript">
(function(){var j=function(a,b){return window.getComputedStyle?getComputedStyle(a).getPropertyValue(b):a.currentStyle[b]};var k=function(a,b,c){if(a.addEventListener)a.addEventListener(b,c,false);else a.attachEvent('on'+b,c)};var l=function(a,b){for(key in b)if(b.hasOwnProperty(key))a[key]=b[key];return a};window.fitText=function(d,e,f){var g=l({'minFontSize':-1/0,'maxFontSize':1/0},f);var h=function(a){var b=e||1;var c=function(){a.style.fontSize=Math.max(Math.min(a.clientWidth/(b*10),parseFloat(g.maxFontSize)),parseFloat(g.minFontSize))+'px'};c();k(window,'resize',c)};if(d.length)for(var i=0;i<d.length;i++)h(d[i]);else h(d);return d}})();
fitText(document.getElementById('title'), 1)
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-7131036-1', 'rootsongj.github.io');
  ga('require', 'linkid', 'linkid.js');
  ga('require', 'displayfeatures');
  ga('send', 'pageview');
</script>
</body>
</html>

