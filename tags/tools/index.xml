<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tools on Jimmy Song&#39;s Blog</title>
    <link>http://rootsongjc.github.io/tags/tools/index.xml</link>
    <description>Recent content in Tools on Jimmy Song&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://rootsongjc.github.io/tags/tools/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>两款图片处理工具——Google Guetzli和基于AI的Deep Photo Style Transfer</title>
      <link>http://rootsongjc.github.io/talks/picture-process/</link>
      <pubDate>Sun, 02 Apr 2017 20:27:00 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/talks/picture-process/</guid>
      <description>

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;如果你看过美剧「硅谷」会记得剧中主角们所在的创业公司&lt;a href=&#34;www.piedpiper.com&#34;&gt;PiedPipper&lt;/a&gt;，他们就是靠自己发明的视频压缩算法来跟大公司Hooli竞争的，这部剧现在已经发展到第4季，在&lt;a href=&#34;http://v.qq.com/detail/d/dr2zn76oez8tyt4.html?ptag=baidu.aladdin.tv&#34;&gt;腾讯视频&lt;/a&gt;上可以免费观看。&lt;/p&gt;

&lt;p&gt;最近关注了两个&lt;strong&gt;图像处理&lt;/strong&gt;的Open Source Projects。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/google/guetzli&#34;&gt;Google Guetzli&lt;/a&gt; 图像压缩工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/luanfujun/deep-photo-styletransfer&#34;&gt;Luan Fujun&amp;rsquo;s Deep Photo Style Transfer&lt;/a&gt; 图像style转换工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外对于图像处理还处于Photoshop、Lightroom这种摄影后期和图像处理命令行工具&lt;a href=&#34;https://www.imagemagick.org/script/index.php&#34;&gt;ImageMagick&lt;/a&gt;的我来说，图像压缩，智能图像风格转换实乃上乘武功，不是我等凡夫俗子驾驭的了，但是乘兴而来，总不能败兴而归吧，下面我们来一探究竟。&lt;/p&gt;

&lt;h2 id=&#34;google-guetzli&#34;&gt;Google Guetzli&lt;/h2&gt;

&lt;p&gt;聊聊架构微信公众号上有一篇介绍&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzA5Nzc4OTA1Mw==&amp;amp;mid=2659599074&amp;amp;idx=1&amp;amp;sn=a26ae2a8becdc1f2cfbddf44d8ca1495&amp;amp;chksm=8be997f0bc9e1ee6e33f3e33c73d11884ad66085c0aedc9dd5e482063482887d0733d8e7d187#rd&#34;&gt;Google开源新算法，可将JPEG文件缩小35%&lt;/a&gt;文章。&lt;/p&gt;

&lt;p&gt;我在Mac上试用了一下，安装很简单，只要一条命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shlell&#34;&gt;brew install guetzli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是当我拿一张&lt;code&gt;22M&lt;/code&gt;大小的照片使用guetzli压缩的时候，我是绝望的，先后三次kill掉了进程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因为实在是太慢了&lt;/strong&gt;，也能是我软件对内存和CPU的利用率不高，效果你们自己看看。&lt;/p&gt;

&lt;p&gt;原图是这个样子的，拍摄地点在景山上的，俯瞰紫禁城的绝佳位置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/guetzli/IMG_5430.JPG&#34; alt=&#34;原图&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guetzli --quality 84 --verbose 20160403052.jpg output.jpg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么quality要设置成84呢？因为只能设置为84+的quality，如果要设置的更低的话需要自己修改代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/guetzli/IMG_5429.JPG&#34; alt=&#34;process&#34; /&gt;&lt;/p&gt;

&lt;p&gt;耗时了一个小时，后台进程信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/guetzli/IMG_5428.JPG&#34; alt=&#34;后台进程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个是使用&lt;strong&gt;Squash&lt;/strong&gt;压缩后的大小效果，压缩每张照片差不多只要3秒钟。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Squash的logo就是个正在被剥皮的🍊，这是&lt;a href=&#34;http://xclient.info/s/squash.html&#34;&gt;下载地址&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;压缩比分别为&lt;code&gt;70%&lt;/code&gt;和&lt;code&gt;30%&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/guetzli/IMG_5434.JPG&#34; alt=&#34;Img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;压缩比70%后的细节放大图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/guetzli/IMG_5432.JPG&#34; alt=&#34;70&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;压缩比30%的细节放大图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/guetzli/IMG_5433.JPG&#34; alt=&#34;30&#34; /&gt;&lt;/p&gt;

&lt;p&gt;你看出什么区别了吗？反正我是没有。&lt;/p&gt;

&lt;p&gt;下面再来看看耗时一个小时，千呼万唤始出来的guetzli压缩后的效果和使用squash压缩比为30%的效果对比。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/img/guetzli/FullSizeRender.jpg&#34; alt=&#34;对比&#34; /&gt;&lt;/p&gt;

&lt;p&gt;左面是使用guetzli压缩后（4.1M），右面使用的squash压缩后（3.1M）的照片。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;似乎还是没有什么区别啊？你看出来了吗？&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;guetzli总结&#34;&gt;Guetzli总结&lt;/h3&gt;

&lt;p&gt;可能是我使用Guetzli的方式不对，但是命令行里确实没有设置CPU和内存资源的选项啊，为啥压缩照片会这么慢呢？效果也并不出彩，不改代码的话照片质量只能设置成84以上，但是这个是&lt;strong&gt;Open Source&lt;/strong&gt;的，使用的C++开发，可以研究下它的图像压缩算法。&lt;/p&gt;

&lt;h1 id=&#34;deep-photo-style-transfer&#34;&gt;Deep Photo Style Transfer&lt;/h1&gt;

&lt;p&gt;来自康奈尔大学的Luan Fujun开源的图像sytle转换工具，看了&lt;a href=&#34;https://github.com/luanfujun/deep-photo-styletransfer&#34;&gt;README&lt;/a&gt;的介绍，上面有很多图像风格转换的例子，真的很惊艳，市面上好像还没有这种能够在给定任意一张照片的情况下，自动将另一张照片转换成该照片的style。&lt;/p&gt;

&lt;p&gt;这个工具使用Matlab和Lua开发，基于&lt;a href=&#34;https://github.com/torch/torch7&#34;&gt;Torch&lt;/a&gt;运行的时候需要&lt;a href=&#34;https://developer.nvidia.com/cuda-downloads&#34;&gt;CUDA&lt;/a&gt;，&lt;a href=&#34;https://developer.nvidia.com/cudnn&#34;&gt;cudnn&lt;/a&gt;，&lt;a href=&#34;https://www.mathworks.com/&#34;&gt;Matlab&lt;/a&gt;，环境实在太复杂，就没折腾，启动有人发布&lt;a href=&#34;https://github.com/luanfujun/deep-photo-styletransfer/issues/29&#34;&gt;Docker镜像&lt;/a&gt;，已经有人提了issue。&lt;/p&gt;

&lt;p&gt;如果它能够被商用，绝对是继&lt;strong&gt;Prisma&lt;/strong&gt;后又一人工智能照片处理应用利器。&lt;/p&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;是不是有了照片风格转换这个东西就不需要做照片后期了？只要选几张自己喜欢的风格照片，再鼠标点几下就可以完成照片处理了？摄影师要失业了？非也！照片风格东西本来就是很主观性的，每个人都有自己喜欢的风格，照相机发明后就有人说画家要失业了，其实不然，画画依然是创造性地劳动，只能说很多写实风格的画家要失业了。Deep Photo Style Transfer也许会成为Lightroom或者手机上一款app的功能，是一个不错的工具。也许还会成为像Prisma一样的现象级产品，who knows?🤷‍♂️&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Packer Intro</title>
      <link>http://rootsongjc.github.io/blogs/packer-intro/</link>
      <pubDate>Thu, 09 Mar 2017 10:58:42 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/packer-intro/</guid>
      <description>&lt;p&gt;昨天研究了下&lt;a href=&#34;https://github.com/mitchellh/vagrant&#34;&gt;&lt;strong&gt;Vagrant&lt;/strong&gt;&lt;/a&gt;，感觉它的虚拟机ruby格式定义很麻烦，经人指点还有一个叫做&lt;a href=&#34;https://github.com/mitchellh/packer&#34;&gt;&lt;strong&gt;packer&lt;/strong&gt;&lt;/a&gt;的东西，也是Hashicorp这家公司出品的，今天看了下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Packer&lt;/strong&gt;是一款开源轻量级的镜像定义工具，可以根据一份定义文件生成多个平台的镜像，支持的平台有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Amazon EC2 (AMI). Both EBS-backed and instance-store AMIs&lt;/li&gt;
&lt;li&gt;Azure&lt;/li&gt;
&lt;li&gt;DigitalOcean&lt;/li&gt;
&lt;li&gt;Docker&lt;/li&gt;
&lt;li&gt;Google Compute Engine&lt;/li&gt;
&lt;li&gt;OpenStack&lt;/li&gt;
&lt;li&gt;Parallels&lt;/li&gt;
&lt;li&gt;QEMU. Both KVM and Xen images.&lt;/li&gt;
&lt;li&gt;VirtualBox&lt;/li&gt;
&lt;li&gt;VMware&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Packer创造的镜像也能转换成&lt;strong&gt;Vagrant boxes&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Packer的镜像创建需要一个json格式的定义文件，例如&lt;code&gt;quick-start.json&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;variables&amp;quot;: {
    &amp;quot;access_key&amp;quot;: &amp;quot;{{env `AWS_ACCESS_KEY_ID`}}&amp;quot;,
    &amp;quot;secret_key&amp;quot;: &amp;quot;{{env `AWS_SECRET_ACCESS_KEY`}}&amp;quot;
  },
  &amp;quot;builders&amp;quot;: [{
    &amp;quot;type&amp;quot;: &amp;quot;amazon-ebs&amp;quot;,
    &amp;quot;access_key&amp;quot;: &amp;quot;{{user `access_key`}}&amp;quot;,
    &amp;quot;secret_key&amp;quot;: &amp;quot;{{user `secret_key`}}&amp;quot;,
    &amp;quot;region&amp;quot;: &amp;quot;us-east-1&amp;quot;,
    &amp;quot;source_ami&amp;quot;: &amp;quot;ami-af22d9b9&amp;quot;,
    &amp;quot;instance_type&amp;quot;: &amp;quot;t2.micro&amp;quot;,
    &amp;quot;ssh_username&amp;quot;: &amp;quot;ubuntu&amp;quot;,
    &amp;quot;ami_name&amp;quot;: &amp;quot;packer-example {{timestamp}}&amp;quot;
  }]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;packer build quick-start.json&lt;/code&gt;可以在AWS上build一个AIM镜像。&lt;/p&gt;

&lt;p&gt;Packer的详细文档：&lt;a href=&#34;https://www.packer.io/docs/&#34;&gt;https://www.packer.io/docs/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vagrant介绍-从使用到放弃完全指南</title>
      <link>http://rootsongjc.github.io/blogs/vagrant-intro/</link>
      <pubDate>Wed, 08 Mar 2017 20:40:08 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/vagrant-intro/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2017030513.jpg&#34; alt=&#34;光熙家园夜景&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：北京地铁13号线光熙家园夜景 Mar 5,2017）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;起源&#34;&gt;起源&lt;/h2&gt;

&lt;p&gt;久闻&lt;strong&gt;Vagrant&lt;/strong&gt;大名，之前经常看到有开源项目使用它作为分布式开发的环境配置。&lt;/p&gt;

&lt;p&gt;因为今天在看&lt;a href=&#34;https://github.com/contiv/netplugin&#34;&gt;contiv&lt;/a&gt;正好里面使用vagrant搭建的开发测试环境，所以顺便了解下。它的&lt;a href=&#34;https://github.com/contiv/netplugin/blob/master/Vagrantfile&#34;&gt;Vagrantfile&lt;/a&gt;文件中定义了三台主机。并安装了很多依赖软件，如consul、etcd、docker、go等，整的比较复杂。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;➜  netplugin git:(master) ✗ vagrant status
Current machine states:

netplugin-node1           running (virtualbox)
netplugin-node2           running (virtualbox)
netplugin-node3           running (virtualbox)

This environment represents multiple VMs. The VMs are all listed
above with their current state. For more information about a specific
VM, run `vagrant status NAME`.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vagrant是&lt;a href=&#34;https://www.hashicorp.com/&#34;&gt;hashicorp&lt;/a&gt;这家公司的产品，这家公司主要做数据中心PAAS和虚拟化，其名下大名鼎鼎的产品有&lt;code&gt;Consul&lt;/code&gt;、&lt;code&gt;Vault&lt;/code&gt;、&lt;code&gt;Nomad&lt;/code&gt;、&lt;code&gt;Terraform&lt;/code&gt;。他们的产品都是基于&lt;strong&gt;Open Source&lt;/strong&gt;的&lt;a href=&#34;https://github.com/hashicorp&#34;&gt;Github地址&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;用途&#34;&gt;用途&lt;/h2&gt;

&lt;p&gt;Vagrant是用来管理虚拟机的，如VirtualBox、VMware、AWS等，主要好处是可以提供一个可配置、可移植和复用的软件环境，可以使用shell、chef、puppet等工具部署。所以vagrant不能单独使用，如果你用它来管理自己的开发环境的话，必须在自己的电脑里安装了虚拟机软件，我使用的是&lt;strong&gt;virtualbox&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Vagrant提供一个命令行工具&lt;code&gt;vagrant&lt;/code&gt;，通过这个命令行工具可以直接启动一个虚拟机，当然你需要提前定义一个Vagrantfile文件，这有点类似Dockerfile之于docker了。&lt;/p&gt;

&lt;p&gt;跟docker类比这来看vagrant就比较好理解了，vagrant也是用来提供一致性环境的，vagrant本身也提供一个镜像源，使用&lt;code&gt;vagrant init hashicorp/precise64&lt;/code&gt;就可以初始化一个Ubuntu 12.04的镜像。&lt;/p&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;p&gt;你可以下载安装文件来安装vagrant，也可以使用RubyGem安装，它是用Ruby开发的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Vagrantfile&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Vagrantfile是用来定义vagrant project的，使用ruby语法，不过你不必了解ruby就可以写一个Vagrantfile。&lt;/p&gt;

&lt;p&gt;看个例子，选自&lt;a href=&#34;https://github.com/fenbox/Vagrantfile&#34;&gt;https://github.com/fenbox/Vagrantfile&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ruby&#34;&gt;# -*- mode: ruby -*-
# vi: set ft=ruby :

# All Vagrant configuration is done below. The &amp;quot;2&amp;quot; in Vagrant.configure
# configures the configuration version (we support older styles for
# backwards compatibility). Please don&#39;t change it unless you know what
# you&#39;re doing.
Vagrant.configure(&amp;quot;2&amp;quot;) do |config|
  # The most common configuration options are documented and commented below.
  # For a complete reference, please see the online documentation at
  # https://docs.vagrantup.com.

  # Every Vagrant development environment requires a box. You can search for
  # boxes at https://atlas.hashicorp.com/search.
  config.vm.box = &amp;quot;ubuntu/trusty64&amp;quot;

  # Disable automatic box update checking. If you disable this, then
  # boxes will only be checked for updates when the user runs
  # `vagrant box outdated`. This is not recommended.
  # config.vm.box_check_update = false

  # Create a forwarded port mapping which allows access to a specific port
  # within the machine from a port on the host machine. In the example below,
  # accessing &amp;quot;localhost:8080&amp;quot; will access port 80 on the guest machine.
  # config.vm.network &amp;quot;forwarded_port&amp;quot;, guest: 80, host: 8080

  # Create a private network, which allows host-only access to the machine
  # using a specific IP.
  config.vm.network &amp;quot;private_network&amp;quot;, ip: &amp;quot;192.168.33.10&amp;quot;

  # Create a public network, which generally matched to bridged network.
  # Bridged networks make the machine appear as another physical device on
  # your network.
  # config.vm.network &amp;quot;public_network&amp;quot;

  # Share an additional folder to the guest VM. The first argument is
  # the path on the host to the actual folder. The second argument is
  # the path on the guest to mount the folder. And the optional third
  # argument is a set of non-required options.
  # config.vm.synced_folder &amp;quot;../data&amp;quot;, &amp;quot;/vagrant_data&amp;quot;

  # Provider-specific configuration so you can fine-tune various
  # backing providers for Vagrant. These expose provider-specific options.
  # Example for VirtualBox:
  #
  # config.vm.provider &amp;quot;virtualbox&amp;quot; do |vb|
  #   # Display the VirtualBox GUI when booting the machine
  #   vb.gui = true
  #
  #   # Customize the amount of memory on the VM:
  #   vb.memory = &amp;quot;1024&amp;quot;
  # end
  #
  # View the documentation for the provider you are using for more
  # information on available options.

  # Define a Vagrant Push strategy for pushing to Atlas. Other push strategies
  # such as FTP and Heroku are also available. See the documentation at
  # https://docs.vagrantup.com/v2/push/atlas.html for more information.
  # config.push.define &amp;quot;atlas&amp;quot; do |push|
  #   push.app = &amp;quot;YOUR_ATLAS_USERNAME/YOUR_APPLICATION_NAME&amp;quot;
  # end

  # Enable provisioning with a shell script. Additional provisioners such as
  # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the
  # documentation for more information about their specific syntax and use.
  # config.vm.provision &amp;quot;shell&amp;quot;, inline: &amp;lt;&amp;lt;-SHELL
  #   apt-get update
  #   apt-get install -y apache2
  # SHELL
  config.vm.provision :shell, path: &amp;quot;bootstrap.sh&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Boxes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Vagrant的基础镜像，相当于docker images。可以在这些基础镜像的基础上制作自己的虚拟机镜像。&lt;/p&gt;

&lt;p&gt;添加一个box&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ vagrant box add hashicorp/precise64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Vagrantfile中指定box&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ruby&#34;&gt;Vagrant.configure(&amp;quot;2&amp;quot;) do |config|
  config.vm.box = &amp;quot;hashicorp/precise64&amp;quot;
  config.vm.box_version = &amp;quot;1.1.0&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用ssh进入vagrant&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vagrant up&lt;/code&gt;后就可以用&lt;code&gt;vagrant ssh $name&lt;/code&gt;进入虚拟机内，如果主机上就一个vagrant可以不指定名字。默认进入的用户是vagrant。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;文件同步&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vagrant up&lt;/code&gt;后在虚拟机中会有一个&lt;code&gt;/vagrant&lt;/code&gt;目录，这跟你定义&lt;code&gt;Vagrantfile&lt;/code&gt;是同一级目录。&lt;/p&gt;

&lt;p&gt;这个目录跟你宿主机上的目录文件是同步的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;软件安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Vagrantfile中定义要安装的软件和操作。&lt;/p&gt;

&lt;p&gt;例如安装apache&lt;/p&gt;

&lt;p&gt;在与Vagrantfile同级的目录下创建一个&lt;code&gt;bootstrap.sh&lt;/code&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/usr/bin/env bash

apt-get update
apt-get install -y apache2
if ! [ -L /var/www ]; then
  rm -rf /var/www
  ln -fs /vagrant /var/www
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在Vagrantfile中使用它。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ruby&#34;&gt;Vagrant.configure(&amp;quot;2&amp;quot;) do |config|
  config.vm.box = &amp;quot;hashicorp/precise64&amp;quot;
  config.vm.box_version = &amp;quot;1.1.0&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;网络&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;端口转发&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Vagrant.configure(&amp;quot;2&amp;quot;) do |config|
  config.vm.box = &amp;quot;hashicorp/precise64&amp;quot;
  config.vm.provision :shell, path: &amp;quot;bootstrap.sh&amp;quot;
  config.vm.network :forwarded_port, guest: 80, host: 4567
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行&lt;code&gt;vagrant reload&lt;/code&gt;或者&lt;code&gt;vagrant up&lt;/code&gt;可以生效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分享&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你自己做的vagrant是可以分享给别人的用的，只要你有一个hashicorp账号，&lt;code&gt;vagrant login&lt;/code&gt;后就可以执行&lt;code&gt;vagrant share&lt;/code&gt;分享，会生成一个URL，其它人也可以访问到你的vagrant里的服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中止&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;vagrant suspend&lt;/li&gt;
&lt;li&gt;Vagrant halt&lt;/li&gt;
&lt;li&gt;Vagrant destroy&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;重构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;再次执行&lt;code&gt;vagrant up&lt;/code&gt;即可。&lt;/p&gt;

&lt;h2 id=&#34;分布式环境&#34;&gt;分布式环境&lt;/h2&gt;

&lt;p&gt;开发分布式环境下的应用时往往需要多个虚拟机用于测试，这时候才是vagrant显威力的时候。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义多个主机&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Vagrant.configure(&amp;quot;2&amp;quot;) do |config|
  config.vm.provision &amp;quot;shell&amp;quot;, inline: &amp;quot;echo Hello&amp;quot;

  config.vm.define &amp;quot;web&amp;quot; do |web|
    web.vm.box = &amp;quot;apache&amp;quot;
  end

  config.vm.define &amp;quot;db&amp;quot; do |db|
    db.vm.box = &amp;quot;mysql&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个比较复杂，详见&lt;a href=&#34;https://www.vagrantup.com/docs/multi-machine/&#34;&gt;https://www.vagrantup.com/docs/multi-machine/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;还有一些其它功能，如push、plugins、providers按下不表。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;总的来说说Vagrant没有Docker好用，但是对于协同开发，用它来定义分布式开发环境还可以，ruby的语法看着有点不习惯，好在也不复杂，如果是团队几个人开发，弄几个虚拟机大家互相拷贝一下也没那么复杂吧？&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>