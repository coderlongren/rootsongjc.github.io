<!DOCTYPE html>
<html class="no-js" lang="en-US" prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="baidu-site-verification" content="g8IYR9SNLF" />
    <meta name="uyan_auth" content="419f63884b" /> <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="description" content="">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="keywords" content="kubernetes, ">

 
<meta property="og:type" content="article"/>
<meta property="og:description" content=""/>
<meta property="og:title" content="Kubernetes中Pod的生命周期 : jimmysong.io"/>
<meta property="og:site_name" content="rootsongjc is Jimmy Song"/>
<meta property="og:image" content="" />
<meta property="og:image:type" content="image/jpeg" />
<meta property="og:image:width" content="" />
<meta property="og:image:height" content="" />
<meta property="og:url" content="https://jimmysong.io/blogs/pod-lifecycle/">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2017-09-19"/>
<meta property="article:modified_time" content="2017-09-19"/>



<meta property="article:tag" content="kubernetes">




<meta name="twitter:card" content="summary">

<meta name="twitter:site" content="@rootsongjc">
<meta name="twitter:title" content="Kubernetes中Pod的生命周期 : jimmysong.io">
<meta name="twitter:creator" content="@rootsongjc">
<meta name="twitter:description" content="">
<meta name="twitter:image:src" content="">
<meta name="twitter:domain" content="jimmysong.io">

    <base href="https://jimmysong.io/">
    <title> Kubernetes中Pod的生命周期 - jimmysong.io focus on Cloud Native & Big Data </title>
    <link rel="canonical" href="https://jimmysong.io/blogs/pod-lifecycle/"> <link rel="stylesheet" href="https://jimmysong.io/static/css/style.css">


<link href="https://jimmysong.io/static/css/prism.css" rel="stylesheet" />
<script type="text/javascript" src="https://jimmysong.io/static/js/prism.js"></script>


<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>




    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
</head>


<body lang="en" itemscope itemtype="http://schema.org/Article">
    <header id="header">
    <figure>
      <a href="/" border=0 id="logolink"><div class="icon-octocat" id="logo"> </div></a>
    </figure>
    <div id="byline">by Jimmy Song</div>
    <nav id="nav">
    <ul id="mainnav">
    <li>
        <a href="/blogs/">
            <span class="icon"> <i aria-hidden="true" class="icon-quill"></i></span>
            <span> blogs </span>
        </a>
    </li>
    <li>
        <a href="/projects/">
            <span class="icon"> <i aria-hidden="true" class="icon-console"></i></span>
            <span> projects </span>
        </a>
    </li>
    <li>
        <a href="/talks/">
            <span class="icon"> <i aria-hidden="true" class="icon-stats"></i></span>
            <span> talks </span>
        </a>
    </li>
    <li>
        <a href="http://www.linkedin.com/in/rootsongjc">
            <span class="icon"> <i aria-hidden="true" class="icon-linkedin"></i></span>
            <span> me </span>
        </a>
    </li>
</ul>
    <ul id="social">
    <li id="share">
        <span class="icon icon-bubbles"> </span>
        <span class="title"> share </span>
        <div class="dropdown share">
            <ul class="social">
                <li> <a href="https://twitter.com/intent/tweet?status=Kubernetes%e4%b8%adPod%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f-https%3a%2f%2fjimmysong.io%2fblogs%2fpod-lifecycle%2f" target="_blank" title="Follow me on Twitter" class="twitter"><span class="icon icon-twitter"></span>Twitter</a> </li>
                <li> <a href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fjimmysong.io%2fblogs%2fpod-lifecycle%2f" target="_blank" title="Join me on Facebook" class="facebook"><span class="icon icon-facebook"></span>Facebook</a> </li>
                <li> <a href="https://plus.google.com/share?url=https%3a%2f%2fjimmysong.io%2fblogs%2fpod-lifecycle%2f" target="_blank" title="Google+" class="googleplus"><span class="icon icon-google-plus"></span>Google+</a> </li>
                <li> <a href="http://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjimmysong.io%2fblogs%2fpod-lifecycle%2f&title=Kubernetes%e4%b8%adPod%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&source=spf13" target="_blank" title="LinkedIn" class="linkedin"><span class="icon icon-linkedin"></span>LinkedIn</a> </li>
                <li> <a href="http://del.icio.us/post?url=https%3a%2f%2fjimmysong.io%2fblogs%2fpod-lifecycle%2f" target="_blank" title="Delicious" class="delicious"><span class="icon icon-delicious"></span>Delicious</a> </li>
                <li> <a href="http://www.reddit.com/submit?url=https%3a%2f%2fjimmysong.io%2fblogs%2fpod-lifecycle%2f" target="_blank" title="Reddit" class="reddit"><span class="icon icon-reddit"></span>Reddit</a> </li>
            </ul>
            <span class="subcount">sharing is caring</span>
        </div>
    </li>
    <li id="follow">
        <span class="icon icon-rocket"> </span>
        <span class="title"> follow </span>
        <div class="dropdown follow">
            <ul class="social">
                <li> <a href="http://www.twitter.com/jimmysongio" target="_blank" title="Follow me on Twitter" class="twitter"><span class="icon icon-twitter"></span>Twitter</a> </li>
                <li> <a href="http://www.facebook.com/jimmysongio" target="_blank" title="Join me on Facebook" class="facebook"><span class="icon icon-facebook"></span>Facebook</a> </li>
                <li> <a href="http://www.linkedin.com/in/jimmysongio" target="_blank" title="LinkedIn" class="linkedin"><span class="icon icon-linkedin"></span>LinkedIn</a> </li>
                <li> <a href="http://github.com/rootsongjc" target="_blank" title="GitHub" class="github"><span class="icon icon-github"></span>GitHub</a> </li>
                <li> <a href="https://www.douban.com/people/deamonj/" target="_blank" title="豆瓣" class="facebook"><span class="icon icon-idea"></span>Douban</a> </li>
                <li> <a href="https://jimmysongio.tuchong.com/" target="_blank" title="图虫" class="github"><span class="icon icon-cc-2"></span>Tuchong</a> </li>
            </ul>
            <span class="subcount">join 10k+ subscribers &amp; followers</span>
        </div>
    </li>
</ul>

    </nav>
</header>
 

    <section id="main">
        <h1 itemprop="name" id="title">Kubernetes中Pod的生命周期</h1>
        <div>
            <article itemprop="articleBody" id="content">
                

<p>Pod 的生命周期对于应用的状态查询、故障检测和恢复是十分重要，比如在 <a href="https://jimmysong.io/blogs/running-spark-with-kubernetes-native-scheduler/">spark on kubernetes</a> 的例子中，spark 任务的状态其实就可以通过查询 driver pod 的状态来获得。这篇文章关注的是 Pod 的状态和在 Pod 中的容器状态变化后，Pod 的状态究竟如何改变（因为不一定所有的 Pod 内都只运行一个容器）。</p>

<h2 id="pod-phase">Pod phase</h2>

<p>Pod 的 <code>status</code> 在信息保存在 <a href="https://kubernetes.io/docs/resources-reference/v1.7/#podstatus-v1-core">PodStatus</a> 中定义，其中有一个 <code>phase</code> 字段。</p>

<p>Pod 的相位（phase）是 Pod 在其生命周期中的简单宏观概述。该阶段并不是对容器或 Pod 的综合汇总，也不是为了做为综合状态机。</p>

<p>Pod 相位的数量和含义是严格指定的。除了本文档中列举的状态外，不应该再假定 Pod 有其他的 <code>phase</code> 值。</p>

<p>下面是 <code>phase</code> 可能的值：</p>

<ul>
<li>挂起（Pending）：Pod 已被 Kubernetes 系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod 的时间和通过网络下载镜像的时间，这可能需要花点时间。</li>
<li>运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态。</li>
<li>成功（Successed）：Pod 中的所有容器都被成功终止，并且不会再重启。</li>
<li>失败（Failed）：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。</li>
<li>未知（Unkonwn）：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。</li>
</ul>

<h2 id="pod-状态">Pod 状态</h2>

<p>Pod 有一个 PodStatus 对象，其中包含一个 <a href="https://kubernetes.io/docs/resources-reference/v1.7/#podcondition-v1-core">PodCondition</a> 数组。 PodCondition 数组的每个元素都有一个 <code>type</code> 字段和一个 <code>status</code> 字段。<code>type</code> 字段是字符串，可能的值有 PodScheduled、Ready、Initialized 和 Unschedulable。<code>status</code> 字段是一个字符串，可能的值有 True、False 和 Unknown。</p>

<h2 id="容器探针">容器探针</h2>

<p><a href="https://kubernetes.io/docs/resources-reference/v1.7/#probe-v1-core">探针</a> 是由 <a href="https://kubernetes.io/docs/admin/kubelet/">kubelet</a> 对容器执行的定期诊断。要执行诊断，kubelet 调用由容器实现的 <a href="https://godoc.org/k8s.io/kubernetes/pkg/api/v1#Handler">Handler</a>。有三种类型的处理程序：</p>

<ul>
<li><a href="https://kubernetes.io/docs/resources-reference/v1.7/#execaction-v1-core">ExecAction</a>：在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</li>
<li><a href="https://kubernetes.io/docs/resources-reference/v1.7/#tcpsocketaction-v1-core">TCPSocketAction</a>：对指定端口上的容器的 IP 地址进行 TCP 检查。如果端口打开，则诊断被认为是成功的。</li>
<li><a href="https://kubernetes.io/docs/resources-reference/v1.7/#httpgetaction-v1-core">HTTPGetAction</a>：对指定的端口和路径上的容器的 IP 地址执行 HTTP Get 请求。如果响应的状态码大于等于200 且小于 400，则诊断被认为是成功的。</li>
</ul>

<p>每次探测都将获得以下三种结果之一：</p>

<ul>
<li>成功：容器通过了诊断。</li>
<li>失败：容器未通过诊断。</li>
<li>未知：诊断失败，因此不会采取任何行动。</li>
</ul>

<p>Kubelet 可以选择是否执行在容器上运行的两种探针执行和做出反应：</p>

<ul>
<li><code>livenessProbe</code>：指示容器是否正在运行。如果存活探测失败，则 kubelet 会杀死容器，并且容器将受到其 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy">重启策略</a> 的影响。如果容器不提供存活探针，则默认状态为 <code>Success</code>。</li>
<li><code>readinessProbe</code>：指示容器是否准备好服务请求。如果就绪探测失败，端点控制器将从与 Pod 匹配的所有 Service 的端点中删除该 Pod 的 IP 地址。初始延迟之前的就绪状态默认为 <code>Failure</code>。如果容器不提供就绪探针，则默认状态为 <code>Success</code>。</li>
</ul>

<h3 id="该什么时候使用存活-liveness-和就绪-readiness-探针">该什么时候使用存活（liveness）和就绪（readiness）探针?</h3>

<p>如果容器中的进程能够在遇到问题或不健康的情况下自行崩溃，则不一定需要存活探针; kubelet 将根据 Pod 的<code>restartPolicy</code> 自动执行正确的操作。</p>

<p>如果您希望容器在探测失败时被杀死并重新启动，那么请指定一个存活探针，并指定<code>restartPolicy</code> 为 Always 或 OnFailure。</p>

<p>如果要仅在探测成功时才开始向 Pod 发送流量，请指定就绪探针。在这种情况下，就绪探针可能与存活探针相同，但是 spec 中的就绪探针的存在意味着 Pod 将在没有接收到任何流量的情况下启动，并且只有在探针探测成功后才开始接收流量。</p>

<p>如果您希望容器能够自行维护，您可以指定一个就绪探针，该探针检查与存活探针不同的端点。</p>

<p>请注意，如果您只想在 Pod 被删除时能够排除请求，则不一定需要使用就绪探针；在删除 Pod 时，Pod 会自动将自身置于未完成状态，无论就绪探针是否存在。当等待 Pod 中的容器停止时，Pod 仍处于未完成状态。</p>

<h2 id="pod-和容器状态">Pod 和容器状态</h2>

<p>有关 Pod 容器状态的详细信息，请参阅 <a href="https://kubernetes.io/docs/resources-reference/v1.7/#podstatus-v1-core">PodStatus</a> 和 <a href="https://kubernetes.io/docs/resources-reference/v1.7/#containerstatus-v1-core">ContainerStatus</a>。请注意，报告的 Pod 状态信息取决于当前的 <a href="https://kubernetes.io/docs/resources-reference/v1.7/#containerstatus-v1-core">ContainerState</a>。</p>

<h2 id="重启策略">重启策略</h2>

<p>PodSpec 中有一个 <code>restartPolicy</code> 字段，可能的值为 Always、OnFailure 和 Never。默认为 Always。 <code>restartPolicy</code> 适用于 Pod 中的所有容器。<code>restartPolicy</code> 仅指通过同一节点上的 kubelet 重新启动容器。失败的容器由 kubelet 以五分钟为上限的指数退避延迟（10秒，20秒，40秒&hellip;）重新启动，并在成功执行十分钟后重置。如 <a href="https://kubernetes.io/docs/user-guide/pods/#durability-of-pods-or-lack-thereof">Pod 文档</a> 中所述，一旦绑定到一个节点，Pod 将永远不会重新绑定到另一个节点。</p>

<h2 id="pod-的生命">Pod 的生命</h2>

<p>一般来说，Pod 不会消失，直到人为销毁他们。这可能是一个人或控制器。这个规则的唯一例外是成功或失败的 <code>phase</code> 超过一段时间（由 master 确定）的Pod将过期并被自动销毁。</p>

<p>有三种可用的控制器：</p>

<ul>
<li><p>使用 <a href="https://kubernetes.io/docs/concepts/jobs/run-to-completion-finite-workloads/">Job</a> 运行预期会终止的 Pod，例如批量计算。Job 仅适用于重启策略为 <code>OnFailure</code> 或 <code>Never</code> 的 Pod。</p></li>

<li><p>对预期不会终止的 Pod 使用 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/">ReplicationController</a>、<a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> 和 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a> ，例如 Web 服务器。 ReplicationController 仅适用于具有 <code>restartPolicy</code> 为 Always 的 Pod。</p></li>

<li><p>提供特定于机器的系统服务，使用 <a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a> 为每台机器运行一个 Pod 。</p></li>
</ul>

<p>所有这三种类型的控制器都包含一个 PodTemplate。建议创建适当的控制器，让它们来创建 Pod，而不是直接自己创建 Pod。这是因为单独的 Pod 在机器故障的情况下没有办法自动复原，而控制器却可以。</p>

<p>如果节点死亡或与集群的其余部分断开连接，则 Kubernetes 将应用一个策略将丢失节点上的所有 Pod 的 <code>phase</code> 设置为 Failed。</p>

<h2 id="示例">示例</h2>

<h3 id="高级-liveness-探针示例">高级 liveness 探针示例</h3>

<p>存活探针由 kubelet 来执行，因此所有的请求都在 kubelet 的网络命名空间中进行。</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-http
spec:
  containers:
  - args:
    - /server
    image: gcr.io/google_containers/liveness
    livenessProbe:
      httpGet:
        # when &quot;host&quot; is not defined, &quot;PodIP&quot; will be used
        # host: my-host
        # when &quot;scheme&quot; is not defined, &quot;HTTP&quot; scheme will be used. Only &quot;HTTP&quot; and &quot;HTTPS&quot; are allowed
        # scheme: HTTPS
        path: /healthz
        port: 8080
        httpHeaders:
          - name: X-Custom-Header
            value: Awesome
      initialDelaySeconds: 15
      timeoutSeconds: 1
    name: liveness
</code></pre>

<h3 id="状态示例">状态示例</h3>

<ul>
<li>Pod 中只有一个容器并且正在运行。容器成功退出。

<ul>
<li>记录完成事件。</li>
<li>如果 <code>restartPolicy</code> 为：</li>
<li>Always：重启容器；Pod <code>phase</code> 仍为 Running。</li>
<li>OnFailure：Pod <code>phase</code> 变成 Succeeded。</li>
<li>Never：Pod <code>phase</code> 变成 Succeeded。</li>
</ul></li>
<li>Pod 中只有一个容器并且正在运行。容器退出失败。

<ul>
<li>记录失败事件。</li>
<li>如果 <code>restartPolicy</code> 为：</li>
<li>Always：重启容器；Pod <code>phase</code> 仍为 Running。</li>
<li>OnFailure：重启容器；Pod <code>phase</code> 仍为 Running。</li>
<li>Never：Pod <code>phase</code> 变成 Failed。</li>
</ul></li>
<li>Pod 中有两个容器并且正在运行。有一个容器退出失败。

<ul>
<li>记录失败事件。</li>
<li>如果 restartPolicy 为：</li>
<li>Always：重启容器；Pod <code>phase</code> 仍为 Running。</li>
<li>OnFailure：重启容器；Pod <code>phase</code> 仍为 Running。</li>
<li>Never：不重启容器；Pod <code>phase</code> 仍为 Running。</li>
<li>如果有一个容器没有处于运行状态，并且两个容器退出：</li>
<li>记录失败事件。</li>
<li>如果 <code>restartPolicy</code> 为：

<ul>
<li>Always：重启容器；Pod <code>phase</code> 仍为 Running。</li>
<li>OnFailure：重启容器；Pod <code>phase</code> 仍为 Running。</li>
<li>Never：Pod <code>phase</code> 变成 Failed。</li>
</ul></li>
</ul></li>
<li>Pod 中只有一个容器并处于运行状态。容器运行时内存超出限制：

<ul>
<li>容器以失败状态终止。</li>
<li>记录 OOM 事件。</li>
<li>如果 <code>restartPolicy</code> 为：</li>
<li>Always：重启容器；Pod <code>phase</code> 仍为 Running。</li>
<li>OnFailure：重启容器；Pod <code>phase</code> 仍为 Running。</li>
<li>Never: 记录失败事件；Pod <code>phase</code> 仍为 Failed。</li>
</ul></li>
<li>Pod 正在运行，磁盘故障：

<ul>
<li>杀掉所有容器。</li>
<li>记录适当事件。</li>
<li>Pod <code>phase</code> 变成 Failed。</li>
<li>如果使用控制器来运行，Pod 将在别处重建。</li>
</ul></li>
<li>Pod 正在运行，其节点被分段。

<ul>
<li>节点控制器等待直到超时。</li>
<li>节点控制器将 Pod <code>phase</code> 设置为 Failed。</li>
<li>如果是用控制器来运行，Pod 将在别处重建。</li>
</ul></li>
</ul>

<p>原文地址：<a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/">https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/</a></p>

<p>翻译：<a href="https://github.com/rootsongjc">rootsongjc</a></p>

            </article>
             
            <h2>See Also</h2>
            <ul>
                
                <li><a href="/blogs/docker-cli-to-kubectl/">docker用户过度到kubectl命令行指南</a></li>
                
                <li><a href="/blogs/creating-cloud-native-app-with-kubernetes/">如何开发部署kubernetes native应用</a></li>
                
                <li><a href="/blogs/running-spark-with-kubernetes-native-scheduler/">运行支持kubernetes原生调度的spark程序-Spark on Kubernetes</a></li>
                
                <li><a href="/blogs/3-things-every-cto-should-know-about-kubernetes/">每位CTO都该知道的关于kubernetes的三件事</a></li>
                
                <li><a href="/blogs/kubectl-user-authentication-authorization/">kubectl的用户认证授权</a></li>
                
            </ul>
            
        </div>
    </section>

    
    

<aside id="meta">

<div>
    <section id="datecount">
        <h4 id="date"> Tue Sep 19, 2017 </h4>
        <h5 id="wc"> 3200 Words </h5>
        <h5 id="readtime"> Read in about 7 Min </h5>
    </section>
    <ul id="categories">
        
    </ul>
    <ul id="tags">
        
        <li> <a href="https://jimmysong.io//tags/kubernetes">kubernetes</a> </li>
        
    </ul>
</div>

<div>
    <section id="prev">
        &nbsp;<a class="previous" href="https://jimmysong.io/projects/istio-service-mesh-doc-zh/"><i class="icon-arrow-left"></i> Istio Service Mesh官方文档中文版</a><br>
    </section>
    <section id="next">
        &nbsp;<a class="next" href="https://jimmysong.io/blogs/docker-cli-to-kubectl/">docker用户过度到kubectl命令行指南 <i class="icon-arrow-right"></i></a>
    </section>
</div>

<div>
    <section id="author">
        <h4>About the Author</h4>
        <p>
            <a href="https://jimmysong.io/about/">Jimmy Song</a> is a software engineer in Beijing, also an open source enthusiast and Big Data, Cloud Native fans. If you not see him front of computer, he must be traveling or taking pictures outside,
            visit the amazing pictures at <a href=https://jimmysongio.tuchong.com/>tuchong(图虫)</a>. Feel free to <a href=https://twitter.com/jimmysongio>follow him on twitter</a>.
        </p>
    </section>

</div>

</aside>

<meta itemprop="wordCount" content="3126">
<meta itemprop="datePublished" content="2017-09-19">
<meta itemprop="url" content="https://jimmysong.io/blogs/pod-lifecycle/">
 <footer>
    <div>
        <p>
            <a href="https://jimmysong.io/kubernetes-handbook">Kubernetes Handbook中文指南/实践手册</a> |
            <a href="https://jimmysong.io/cloud-native-go">Cloud Native Go</a> |
            <a href="https://jimmysong.io/awesome-cloud-native">Awesome Cloud Native</a> |
            <a href="https://jimmysong.io/migrating-to-cloud-native-application-architectures">迁移到云原生应用架构手册</a> |
            <a href="https://istio.doczh.cn/">Istio Service Mesh中文文档</a>
    </div>
    <div>
        <p>

        </p>
        <p> &copy; 2013-2017 <span itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Jimmy Song</span><span>
            Powered by <a href="https://gohugo.io">Hugo</a></span>
            </span>
    </div>
</footer>
</body>

</html>
