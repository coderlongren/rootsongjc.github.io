<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Jimmy Song&#39;s Blog</title>
    <link>http://rootsongjc.github.io/blogs/index.xml</link>
    <description>Recent content in Blogs on Jimmy Song&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 19 Apr 2017 21:05:47 +0800</lastBuildDate>
    <atom:link href="http://rootsongjc.github.io/blogs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Kubernetes ingress解析</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-ingress-resource/</link>
      <pubDate>Wed, 19 Apr 2017 21:05:47 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-ingress-resource/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20160131054.jpg&#34; alt=&#34;银河soho&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：朝阳门银河SOHO Jan 31,2016）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这是kubernete官方文档中&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34;&gt;Ingress Resource&lt;/a&gt;的翻译，因为最近工作中用到，文章也不长，也很好理解，索性翻译一下，也便于自己加深理解，同时造福&lt;a href=&#34;https://www.kubernetes.org.cn/&#34;&gt;kubernetes中文社区&lt;/a&gt;。后续准备使用&lt;a href=&#34;https://github.com/containous/traefik&#34;&gt;Traefik&lt;/a&gt;来做Ingress controller，文章末尾给出了几个相关链接，实际使用案例正在摸索中，届时相关安装文档和配置说明将同步更新到&lt;a href=&#34;https://github.com/rootsongjc/kubernetes-handbook&#34;&gt;kubernetes-handbook&lt;/a&gt;中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;术语&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在本篇文章中你将会看到一些在其他地方被交叉使用的术语，为了防止产生歧义，我们首先来澄清下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;节点：Kubernetes集群中的一台物理机或者虚拟机。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;集群：位于Internet防火墙后的节点，这是kubernetes管理的主要计算资源。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;边界路由器：为集群强制执行防火墙策略的路由器。 这可能是由云提供商或物理硬件管理的网关。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;集群网络：一组逻辑或物理链接，可根据Kubernetes&lt;a href=&#34;https://kubernetes.io/docs/admin/networking/&#34;&gt;网络模型&lt;/a&gt;实现群集内的通信。 集群网络的实现包括Overlay模型的 &lt;a href=&#34;https://github.com/coreos/flannel#flannel&#34;&gt;flannel&lt;/a&gt; 和基于SDN的&lt;a href=&#34;https://kubernetes.io/docs/admin/ovs-networking/&#34;&gt;OVS&lt;/a&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务：使用标签选择器标识一组pod成为的Kubernetes&lt;a href=&#34;https://kubernetes.io/docs/user-guide/services/&#34;&gt;服务&lt;/a&gt;。 除非另有说明，否则服务假定在集群网络内仅可通过虚拟IP访问。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;什么是ingress&#34;&gt;什么是Ingress？&lt;/h2&gt;

&lt;p&gt;通常情况下，service和pod仅可在集群内部网络中通过IP地址访问。所有到达边界路由器的流量或被丢弃或被转发到其他地方。从概念上讲，可能像下面这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    internet
        |
  ------------
  [ Services ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ingress是授权入站连接到达集群服务的规则集合。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    internet
        |
   [ Ingress ]
   --|-----|--
   [ Services ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以给Ingress配置提供外部可访问的URL、负载均衡、SSL、基于名称的虚拟主机等。用户通过POST Ingress资源到API server的方式来请求ingress。 &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/#ingress-controllers&#34;&gt;Ingress controller&lt;/a&gt;负责实现Ingress，通常使用负载平衡器，它还可以配置边界路由和其他前端，这有助于以HA方式处理流量。&lt;/p&gt;

&lt;h2 id=&#34;先决条件&#34;&gt;先决条件&lt;/h2&gt;

&lt;p&gt;在使用Ingress resource之前，有必要先了解下面几件事情。Ingress是beta版本的resource，在kubernetes1.1之前还没有。你需要一个&lt;code&gt;Ingress Controller&lt;/code&gt;来实现&lt;code&gt;Ingress&lt;/code&gt;，单纯的创建一个&lt;code&gt;Ingress&lt;/code&gt;没有任何意义。&lt;/p&gt;

&lt;p&gt;GCE/GKE会在master节点上部署一个ingress controller。你可以在一个pod中部署任意个自定义的ingress controller。你必须正确地annotate每个ingress，比如 &lt;a href=&#34;https://github.com/kubernetes/ingress/tree/master/controllers/nginx#running-multiple-ingress-controllers&#34;&gt;运行多个ingress controller&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/kubernetes/ingress/blob/master/controllers/gce/BETA_LIMITATIONS.md#disabling-glbc&#34;&gt;关闭glbc&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;确定你已经阅读了Ingress controller的&lt;a href=&#34;https://github.com/kubernetes/ingress/blob/master/controllers/gce/BETA_LIMITATIONS.md&#34;&gt;beta版本限制&lt;/a&gt;。在非GCE/GKE的环境中，你需要在pod中&lt;a href=&#34;https://github.com/kubernetes/ingress/tree/master/controllers&#34;&gt;部署一个controller&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;ingress-resource&#34;&gt;Ingress Resource&lt;/h2&gt;

&lt;p&gt;最简化的Ingress配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;1: apiVersion: extensions/v1beta1
2: kind: Ingress
3: metadata:
4:   name: test-ingress
5: spec:
6:   rules:
7:   - http:
8:       paths:
9:       - path: /testpath
10:        backend:
11:           serviceName: test
12:           servicePort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;如果你没有配置Ingress controller就将其POST到API server不会有任何用处&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;配置说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1-4行&lt;/strong&gt;：跟Kubernetes的其他配置一样，ingress的配置也需要&lt;code&gt;apiVersion&lt;/code&gt;，&lt;code&gt;kind&lt;/code&gt;和&lt;code&gt;metadata&lt;/code&gt;字段。配置文件的详细说明请查看&lt;a href=&#34;https://kubernetes.io/docs/user-guide/deploying-applications&#34;&gt;部署应用&lt;/a&gt;, &lt;a href=&#34;https://kubernetes.io/docs/user-guide/configuring-containers&#34;&gt;配置容器&lt;/a&gt;和 &lt;a href=&#34;https://kubernetes.io/docs/user-guide/working-with-resources&#34;&gt;使用resources&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5-7行&lt;/strong&gt;: Ingress &lt;a href=&#34;https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status&#34;&gt;spec&lt;/a&gt; 中包含配置一个loadbalancer或proxy server的所有信息。最重要的是，它包含了一个匹配所有入站请求的规则列表。目前ingress只支持http规则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8-9行&lt;/strong&gt;：每条http规则包含以下信息：一个&lt;code&gt;host&lt;/code&gt;配置项（比如for.bar.com，在这个例子中默认是*），&lt;code&gt;path&lt;/code&gt;列表（比如：/testpath），每个path都关联一个&lt;code&gt;backend&lt;/code&gt;(比如test:80)。在loadbalancer将流量转发到backend之前，所有的入站请求都要先匹配host和path。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10-12行&lt;/strong&gt;：正如 &lt;a href=&#34;https://kubernetes.io/docs/user-guide/services&#34;&gt;services doc&lt;/a&gt;中描述的那样，backend是一个&lt;code&gt;service:port&lt;/code&gt;的组合。Ingress的流量被转发到它所匹配的backend。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;全局参数&lt;/strong&gt;：为了简单起见，Ingress示例中没有全局参数，请参阅资源完整定义的&lt;a href=&#34;https://releases.k8s.io/master/pkg/apis/extensions/v1beta1/types.go&#34;&gt;api参考&lt;/a&gt;。 在所有请求都不能跟spec中的path匹配的情况下，请求被发送到Ingress controller的默认后端，可以指定全局缺省backend。&lt;/p&gt;

&lt;h2 id=&#34;ingress-controllers&#34;&gt;Ingress controllers&lt;/h2&gt;

&lt;p&gt;为了使Ingress正常工作，集群中必须运行Ingress controller。 这与其他类型的控制器不同，其他类型的控制器通常作为&lt;code&gt;kube-controller-manager&lt;/code&gt;二进制文件的一部分运行，在集群启动时自动启动。 你需要选择最适合自己集群的Ingress controller或者自己实现一个。 示例和说明可以在&lt;a href=&#34;https://github.com/kubernetes/ingress/tree/master/controllers&#34;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;

&lt;h2 id=&#34;在你开始前&#34;&gt;在你开始前&lt;/h2&gt;

&lt;p&gt;以下文档描述了Ingress资源中公开的一组跨平台功能。 理想情况下，所有的Ingress controller都应该符合这个规范，但是我们还没有实现。 GCE和nginx控制器的文档分别在&lt;a href=&#34;https://github.com/kubernetes/ingress/blob/master/controllers/gce/README.md&#34;&gt;这里&lt;/a&gt;和&lt;a href=&#34;https://github.com/kubernetes/ingress/blob/master/controllers/nginx/README.md&#34;&gt;这里&lt;/a&gt;。&lt;strong&gt;确保您查看控制器特定的文档，以便您了解每个文档的注意事项。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;ingress类型&#34;&gt;Ingress类型&lt;/h2&gt;

&lt;h3 id=&#34;单service-ingress&#34;&gt;单Service Ingress&lt;/h3&gt;

&lt;p&gt;Kubernetes中已经存在一些概念可以暴露单个service（查看&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/#alternatives&#34;&gt;替代方案&lt;/a&gt;），但是你仍然可以通过Ingress来实现，通过指定一个没有rule的默认backend的方式。&lt;/p&gt;

&lt;p&gt;ingress.yaml定义文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: test-ingress
spec:
  backend:
    serviceName: testsvc
    servicePort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;kubectl create -f&lt;/code&gt;命令创建，然后查看ingress：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get ing
NAME                RULE          BACKEND        ADDRESS
test-ingress        -             testsvc:80     107.178.254.228
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;107.178.254.228&lt;/code&gt;就是Ingress controller为了实现Ingress而分配的IP地址。&lt;code&gt;RULE&lt;/code&gt;列表示所有发送给该IP的流量都被转发到了&lt;code&gt;BACKEND&lt;/code&gt;所列的Kubernetes service上。&lt;/p&gt;

&lt;h3 id=&#34;简单展开&#34;&gt;简单展开&lt;/h3&gt;

&lt;p&gt;如前面描述的那样，kubernete pod中的IP只在集群网络内部可见，我们需要在边界设置一个东西，让它能够接收ingress的流量并将它们转发到正确的端点上。这个东西一般是高可用的loadbalancer。使用Ingress能够允许你将loadbalancer的个数降低到最少，例如，嫁入你想要创建这样的一个设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo.bar.com -&amp;gt; 178.91.123.132 -&amp;gt; / foo    s1:80
                                 / bar    s2:80

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你需要一个这样的ingress：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: test
spec:
  rules:
  - host: foo.bar.com
    http:
      paths:
      - path: /foo
        backend:
          serviceName: s1
          servicePort: 80
      - path: /bar
        backend:
          serviceName: s2
          servicePort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;kubectl create -f&lt;/code&gt;创建完ingress后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get ing
NAME      RULE          BACKEND   ADDRESS
test      -
          foo.bar.com
          /foo          s1:80
          /bar          s2:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要服务（s1，s2）存在，Ingress controller就会将提供一个满足该Ingress的特定loadbalancer实现。 这一步完成后，您将在Ingress的最后一列看到loadbalancer的地址。&lt;/p&gt;

&lt;h3 id=&#34;基于名称的虚拟主机&#34;&gt;基于名称的虚拟主机&lt;/h3&gt;

&lt;p&gt;Name-based的虚拟主机在同一个IP地址下拥有多个主机名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo.bar.com --|                 |-&amp;gt; foo.bar.com s1:80
              | 178.91.123.132  |
bar.foo.com --|                 |-&amp;gt; bar.foo.com s2:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面这个ingress说明基于&lt;a href=&#34;https://tools.ietf.org/html/rfc7230#section-5.4&#34;&gt;Host header&lt;/a&gt;的后端loadbalancer的路由请求：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: test
spec:
  rules:
  - host: foo.bar.com
    http:
      paths:
      - backend:
          serviceName: s1
          servicePort: 80
  - host: bar.foo.com
    http:
      paths:
      - backend:
          serviceName: s2
          servicePort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;默认backend&lt;/strong&gt;：一个没有rule的ingress，如前面章节中所示，所有流量都将发送到一个默认backend。你可以用该技巧通知loadbalancer如何找到你网站的404页面，通过制定一些列rule和一个默认backend的方式。如果请求header中的host不能跟ingress中的host匹配，并且/或请求的URL不能与任何一个path匹配，则流量将路由到你的默认backend。&lt;/p&gt;

&lt;h3 id=&#34;tls&#34;&gt;TLS&lt;/h3&gt;

&lt;p&gt;你可以通过指定包含TLS私钥和证书的&lt;a href=&#34;https://kubernetes.io/docs/user-guide/secrets&#34;&gt;secret&lt;/a&gt;来加密Ingress。 目前，Ingress仅支持单个TLS端口443，并假定TLS termination。 如果Ingress中的TLS配置部分指定了不同的主机，则它们将根据通过SNI TLS扩展指定的主机名（假如Ingress controller支持SNI）在多个相同端口上进行复用。 TLS secret中必须包含名为&lt;code&gt;tls.crt&lt;/code&gt;和&lt;code&gt;tls.key&lt;/code&gt;的密钥，这里面包含了用于TLS的证书和私钥，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: v1
data:
  tls.crt: base64 encoded cert
  tls.key: base64 encoded key
kind: Secret
metadata:
  name: testsecret
  namespace: default
type: Opaque
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Ingress中引用这个secret将通知Ingress controller使用TLS加密从将客户端到loadbalancer的channel：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: no-rules-map
spec:
  tls:
    - secretName: testsecret
  backend:
    serviceName: s1
    servicePort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请注意，各种Ingress controller支持的TLS功能之间存在差距。 请参阅有关&lt;a href=&#34;https://github.com/kubernetes/ingress/blob/master/controllers/nginx/README.md#https&#34;&gt;nginx&lt;/a&gt;，&lt;a href=&#34;https://github.com/kubernetes/ingress/blob/master/controllers/gce/README.md#tls&#34;&gt;GCE&lt;/a&gt;或任何其他平台特定Ingress controller的文档，以了解TLS在你的环境中的工作原理。&lt;/p&gt;

&lt;p&gt;Ingress controller启动时附带一些适用于所有Ingress的负载平衡策略设置，例如负载均衡算法，后端权重方案等。更高级的负载平衡概念（例如持久会话，动态权重）尚未在Ingress中公开。 你仍然可以通过&lt;a href=&#34;https://github.com/kubernetes/contrib/tree/master/service-loadbalancer&#34;&gt;service loadbalancer&lt;/a&gt;获取这些功能。 随着时间的推移，我们计划将适用于跨平台的负载平衡模式加入到Ingress资源中。&lt;/p&gt;

&lt;p&gt;还值得注意的是，尽管健康检查不直接通过Ingress公开，但Kubernetes中存在并行概念，例如&lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/&#34;&gt;准备探查&lt;/a&gt;，可以使你达成相同的最终结果。 请查看特定控制器的文档，以了解他们如何处理健康检查（&lt;a href=&#34;https://github.com/kubernetes/ingress/blob/master/controllers/nginx/README.md&#34;&gt;nginx&lt;/a&gt;，&lt;a href=&#34;https://github.com/kubernetes/ingress/blob/master/controllers/gce/README.md#health-checks&#34;&gt;GCE&lt;/a&gt;）。&lt;/p&gt;

&lt;h2 id=&#34;更新ingress&#34;&gt;更新Ingress&lt;/h2&gt;

&lt;p&gt;假如你想要向已有的ingress中增加一个新的Host，你可以编辑和更新该ingress：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;$ kubectl get ing
NAME      RULE          BACKEND   ADDRESS
test      -                       178.91.123.132
          foo.bar.com
          /foo          s1:80
$ kubectl edit ing test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这会弹出一个包含已有的yaml文件的编辑器，修改它，增加新的Host配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;spec:
  rules:
  - host: foo.bar.com
    http:
      paths:
      - backend:
          serviceName: s1
          servicePort: 80
        path: /foo
  - host: bar.baz.com
    http:
      paths:
      - backend:
          serviceName: s2
          servicePort: 80
        path: /foo
..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存它会更新API server中的资源，这会触发ingress controller重新配置loadbalancer。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get ing
NAME      RULE          BACKEND   ADDRESS
test      -                       178.91.123.132
          foo.bar.com
          /foo          s1:80
          bar.baz.com
          /foo          s2:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在一个修改过的ingress yaml文件上调用&lt;code&gt;kubectl replace -f&lt;/code&gt;命令一样可以达到同样的效果。&lt;/p&gt;

&lt;h2 id=&#34;跨可用域故障&#34;&gt;跨可用域故障&lt;/h2&gt;

&lt;p&gt;在不通云供应商之间，跨故障域的流量传播技术有所不同。 有关详细信息，请查看相关Ingress controller的文档。 有关在federation集群中部署Ingress的详细信息，请参阅[federation文档]()。&lt;/p&gt;

&lt;h2 id=&#34;未来计划&#34;&gt;未来计划&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;多样化的HTTPS/TLS模型支持（如SNI，re-encryption）&lt;/li&gt;
&lt;li&gt;通过声明来请求IP或者主机名&lt;/li&gt;
&lt;li&gt;结合L4和L7 Ingress&lt;/li&gt;
&lt;li&gt;更多的Ingress controller&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;请跟踪&lt;a href=&#34;https://github.com/kubernetes/kubernetes/pull/12827&#34;&gt;L7和Ingress的proposal&lt;/a&gt;，了解有关资源演进的更多细节，以及&lt;a href=&#34;https://github.com/kubernetes/ingress/tree/master&#34;&gt;Ingress repository&lt;/a&gt;，了解有关各种Ingress controller演进的更多详细信息。&lt;/p&gt;

&lt;h2 id=&#34;替代方案&#34;&gt;替代方案&lt;/h2&gt;

&lt;p&gt;你可以通过很多种方式暴露service而不必直接使用ingress：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href=&#34;https://kubernetes.io/docs/user-guide/services/#type-loadbalancer&#34;&gt;Service.Type=LoadBalancer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;a href=&#34;https://kubernetes.io/docs/user-guide/services/#type-nodeport&#34;&gt;Service.Type=NodePort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;a href=&#34;https://github.com/kubernetes/contrib/tree/master/for-demos/proxy-to-service&#34;&gt;Port Proxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;部署一个&lt;a href=&#34;https://github.com/kubernetes/contrib/tree/master/service-loadbalancer&#34;&gt;Service loadbalancer&lt;/a&gt; 这允许你在多个service之间共享单个IP，并通过Service Annotations实现更高级的负载平衡。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34;&gt;Kubernetes Ingress Resource&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dockone.io/article/957&#34;&gt;使用NGINX Plus负载均衡Kubernetes服务&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/276815076/p/6407101.html&#34;&gt;使用 NGINX 和 NGINX Plus 的 Ingress Controller 进行 Kubernetes 的负载均衡&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.osones.com/en/kubernetes-ingress-controller-with-traefik-and-lets-encrypt.html&#34;&gt;Kubernetes : Ingress Controller with Træfɪk and Let&amp;rsquo;s Encrypt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.osones.com/en/kubernetes-traefik-and-lets-encrypt-at-scale.html&#34;&gt;Kubernetes : Træfɪk and Let&amp;rsquo;s Encrypt at scale&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.traefik.io/user-guide/kubernetes/&#34;&gt;Kubernetes Ingress Controller-Træfɪk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.kubernetes.io/2016/03/Kubernetes-1.2-and-simplifying-advanced-networking-with-Ingress.html&#34;&gt;Kubernetes 1.2 and simplifying advanced networking with Ingress&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在开启TLS的Kubernetes1.6集群上安装EFK</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-efk-installation-with-tls/</link>
      <pubDate>Thu, 13 Apr 2017 12:28:10 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-efk-installation-with-tls/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2016061706.jpg&#34; alt=&#34;簋街&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：簋街 Jun 17,2016）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这是&lt;a href=&#34;https://github.com/rootsongjc/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;项目(fork自&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;opsnull&lt;/a&gt;)中的一篇文章，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;产生的kuberentes环境，在开启了TLS验证的集群中部署EFK日志收集监控插件。&lt;/p&gt;

&lt;h1 id=&#34;配置和安装-efk&#34;&gt;配置和安装 EFK&lt;/h1&gt;

&lt;p&gt;官方文件目录：&lt;code&gt;cluster/addons/fluentd-elasticsearch&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls *.yaml
es-controller.yaml  es-service.yaml  fluentd-es-ds.yaml  kibana-controller.yaml  kibana-service.yaml efk-rbac.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样EFK服务也需要一个&lt;code&gt;efk-rbac.yaml&lt;/code&gt;文件，配置serviceaccount为&lt;code&gt;efk&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;已经修改好的 yaml 文件见：&lt;a href=&#34;./manifests/EFK&#34;&gt;EFK&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;配置-es-controller-yaml&#34;&gt;配置 es-controller.yaml&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ diff es-controller.yaml.orig es-controller.yaml
24c24
&amp;lt;       - image: gcr.io/google_containers/elasticsearch:v2.4.1-2
---
&amp;gt;       - image: sz-pg-oam-docker-hub-001.tendcloud.com/library/elasticsearch:v2.4.1-2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置-es-service-yaml&#34;&gt;配置 es-service.yaml&lt;/h2&gt;

&lt;p&gt;无需配置；&lt;/p&gt;

&lt;h2 id=&#34;配置-fluentd-es-ds-yaml&#34;&gt;配置 fluentd-es-ds.yaml&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ diff fluentd-es-ds.yaml.orig fluentd-es-ds.yaml
26c26
&amp;lt;         image: gcr.io/google_containers/fluentd-elasticsearch:1.22
---
&amp;gt;         image: sz-pg-oam-docker-hub-001.tendcloud.com/library/fluentd-elasticsearch:1.22
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置-kibana-controller-yaml&#34;&gt;配置 kibana-controller.yaml&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ diff kibana-controller.yaml.orig kibana-controller.yaml
22c22
&amp;lt;         image: gcr.io/google_containers/kibana:v4.6.1-1
---
&amp;gt;         image: sz-pg-oam-docker-hub-001.tendcloud.com/library/kibana:v4.6.1-1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;给-node-设置标签&#34;&gt;给 Node 设置标签&lt;/h2&gt;

&lt;p&gt;定义 DaemonSet &lt;code&gt;fluentd-es-v1.22&lt;/code&gt; 时设置了 nodeSelector &lt;code&gt;beta.kubernetes.io/fluentd-ds-ready=true&lt;/code&gt; ，所以需要在期望运行 fluentd 的 Node 上设置该标签；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get nodes
NAME        STATUS    AGE       VERSION
172.20.0.113   Ready     1d        v1.6.0

$ kubectl label nodes 172.20.0.113 beta.kubernetes.io/fluentd-ds-ready=true
node &amp;quot;172.20.0.113&amp;quot; labeled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给其他两台node打上同样的标签。&lt;/p&gt;

&lt;h2 id=&#34;执行定义文件&#34;&gt;执行定义文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl create -f .
serviceaccount &amp;quot;efk&amp;quot; created
clusterrolebinding &amp;quot;efk&amp;quot; created
replicationcontroller &amp;quot;elasticsearch-logging-v1&amp;quot; created
service &amp;quot;elasticsearch-logging&amp;quot; created
daemonset &amp;quot;fluentd-es-v1.22&amp;quot; created
deployment &amp;quot;kibana-logging&amp;quot; created
service &amp;quot;kibana-logging&amp;quot; created
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;检查执行结果&#34;&gt;检查执行结果&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get deployment -n kube-system|grep kibana
kibana-logging         1         1         1            1           2m

$ kubectl get pods -n kube-system|grep -E &#39;elasticsearch|fluentd|kibana&#39;
elasticsearch-logging-v1-mlstp          1/1       Running   0          1m
elasticsearch-logging-v1-nfbbf          1/1       Running   0          1m
fluentd-es-v1.22-31sm0                  1/1       Running   0          1m
fluentd-es-v1.22-bpgqs                  1/1       Running   0          1m
fluentd-es-v1.22-qmn7h                  1/1       Running   0          1m
kibana-logging-1432287342-0gdng         1/1       Running   0          1m

$ kubectl get service  -n kube-system|grep -E &#39;elasticsearch|kibana&#39;
elasticsearch-logging   10.254.77.62    &amp;lt;none&amp;gt;        9200/TCP                        2m
kibana-logging          10.254.8.113    &amp;lt;none&amp;gt;        5601/TCP                        2m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kibana Pod 第一次启动时会用&lt;strong&gt;较长时间(10-20分钟)&lt;/strong&gt;来优化和 Cache 状态页面，可以 tailf 该 Pod 的日志观察进度：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl logs kibana-logging-1432287342-0gdng -n kube-system -f
ELASTICSEARCH_URL=http://elasticsearch-logging:9200
server.basePath: /api/v1/proxy/namespaces/kube-system/services/kibana-logging
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:08:06Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;info&amp;quot;,&amp;quot;optimize&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;message&amp;quot;:&amp;quot;Optimizing and caching bundles for kibana and statusPage. This may take a few minutes&amp;quot;}
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:18:17Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;info&amp;quot;,&amp;quot;optimize&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;message&amp;quot;:&amp;quot;Optimization of bundles for kibana and statusPage complete in 610.40 seconds&amp;quot;}
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:18:17Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;status&amp;quot;,&amp;quot;plugin:kibana@1.0.0&amp;quot;,&amp;quot;info&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;state&amp;quot;:&amp;quot;green&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Status changed from uninitialized to green - Ready&amp;quot;,&amp;quot;prevState&amp;quot;:&amp;quot;uninitialized&amp;quot;,&amp;quot;prevMsg&amp;quot;:&amp;quot;uninitialized&amp;quot;}
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:18:18Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;status&amp;quot;,&amp;quot;plugin:elasticsearch@1.0.0&amp;quot;,&amp;quot;info&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;state&amp;quot;:&amp;quot;yellow&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Status changed from uninitialized to yellow - Waiting for Elasticsearch&amp;quot;,&amp;quot;prevState&amp;quot;:&amp;quot;uninitialized&amp;quot;,&amp;quot;prevMsg&amp;quot;:&amp;quot;uninitialized&amp;quot;}
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:18:19Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;status&amp;quot;,&amp;quot;plugin:kbn_vislib_vis_types@1.0.0&amp;quot;,&amp;quot;info&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;state&amp;quot;:&amp;quot;green&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Status changed from uninitialized to green - Ready&amp;quot;,&amp;quot;prevState&amp;quot;:&amp;quot;uninitialized&amp;quot;,&amp;quot;prevMsg&amp;quot;:&amp;quot;uninitialized&amp;quot;}
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:18:19Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;status&amp;quot;,&amp;quot;plugin:markdown_vis@1.0.0&amp;quot;,&amp;quot;info&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;state&amp;quot;:&amp;quot;green&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Status changed from uninitialized to green - Ready&amp;quot;,&amp;quot;prevState&amp;quot;:&amp;quot;uninitialized&amp;quot;,&amp;quot;prevMsg&amp;quot;:&amp;quot;uninitialized&amp;quot;}
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:18:19Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;status&amp;quot;,&amp;quot;plugin:metric_vis@1.0.0&amp;quot;,&amp;quot;info&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;state&amp;quot;:&amp;quot;green&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Status changed from uninitialized to green - Ready&amp;quot;,&amp;quot;prevState&amp;quot;:&amp;quot;uninitialized&amp;quot;,&amp;quot;prevMsg&amp;quot;:&amp;quot;uninitialized&amp;quot;}
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:18:19Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;status&amp;quot;,&amp;quot;plugin:spyModes@1.0.0&amp;quot;,&amp;quot;info&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;state&amp;quot;:&amp;quot;green&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Status changed from uninitialized to green - Ready&amp;quot;,&amp;quot;prevState&amp;quot;:&amp;quot;uninitialized&amp;quot;,&amp;quot;prevMsg&amp;quot;:&amp;quot;uninitialized&amp;quot;}
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:18:19Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;status&amp;quot;,&amp;quot;plugin:statusPage@1.0.0&amp;quot;,&amp;quot;info&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;state&amp;quot;:&amp;quot;green&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Status changed from uninitialized to green - Ready&amp;quot;,&amp;quot;prevState&amp;quot;:&amp;quot;uninitialized&amp;quot;,&amp;quot;prevMsg&amp;quot;:&amp;quot;uninitialized&amp;quot;}
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:18:19Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;status&amp;quot;,&amp;quot;plugin:table_vis@1.0.0&amp;quot;,&amp;quot;info&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;state&amp;quot;:&amp;quot;green&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Status changed from uninitialized to green - Ready&amp;quot;,&amp;quot;prevState&amp;quot;:&amp;quot;uninitialized&amp;quot;,&amp;quot;prevMsg&amp;quot;:&amp;quot;uninitialized&amp;quot;}
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:18:19Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;listening&amp;quot;,&amp;quot;info&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;message&amp;quot;:&amp;quot;Server running at http://0.0.0.0:5601&amp;quot;}
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:18:24Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;status&amp;quot;,&amp;quot;plugin:elasticsearch@1.0.0&amp;quot;,&amp;quot;info&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;state&amp;quot;:&amp;quot;yellow&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Status changed from yellow to yellow - No existing Kibana index found&amp;quot;,&amp;quot;prevState&amp;quot;:&amp;quot;yellow&amp;quot;,&amp;quot;prevMsg&amp;quot;:&amp;quot;Waiting for Elasticsearch&amp;quot;}
{&amp;quot;type&amp;quot;:&amp;quot;log&amp;quot;,&amp;quot;@timestamp&amp;quot;:&amp;quot;2017-04-12T13:18:29Z&amp;quot;,&amp;quot;tags&amp;quot;:[&amp;quot;status&amp;quot;,&amp;quot;plugin:elasticsearch@1.0.0&amp;quot;,&amp;quot;info&amp;quot;],&amp;quot;pid&amp;quot;:7,&amp;quot;state&amp;quot;:&amp;quot;green&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Status changed from yellow to green - Kibana index ready&amp;quot;,&amp;quot;prevState&amp;quot;:&amp;quot;yellow&amp;quot;,&amp;quot;prevMsg&amp;quot;:&amp;quot;No existing Kibana index found&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;访问-kibana&#34;&gt;访问 kibana&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;通过 kube-apiserver 访问：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;获取 monitoring-grafana 服务 URL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   $ kubectl cluster-info
   Kubernetes master is running at https://172.20.0.113:6443
   Elasticsearch is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/elasticsearch-logging
   Heapster is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/heapster
   Kibana is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/kibana-logging
   KubeDNS is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/kube-dns
   kubernetes-dashboard is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/kubernetes-dashboard
   monitoring-grafana is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/monitoring-grafana
   monitoring-influxdb is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/monitoring-influxdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器访问 URL： &lt;code&gt;https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/kibana-logging/app/kibana&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过 kubectl proxy 访问：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;创建代理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   $ kubectl proxy --address=&#39;172.20.0.113&#39; --port=8086 --accept-hosts=&#39;^*$&#39;
   Starting to serve on 172.20.0.113:8086
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器访问 URL：&lt;code&gt;http://172.20.0.113:8086/api/v1/proxy/namespaces/kube-system/services/kibana-logging&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在 Settings -&amp;gt; Indices 页面创建一个 index（相当于 mysql 中的一个 database），选中 &lt;code&gt;Index contains time-based events&lt;/code&gt;，使用默认的 &lt;code&gt;logstash-*&lt;/code&gt; pattern，点击 &lt;code&gt;Create&lt;/code&gt; ;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可能遇到的问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你在这里发现Create按钮是灰色的无法点击，且Time-filed name中没有选项，fluentd要读取&lt;code&gt;/var/log/containers/&lt;/code&gt;目录下的log日志，这些日志是从&lt;code&gt;/var/lib/docker/containers/${CONTAINER_ID}/${CONTAINER_ID}-json.log&lt;/code&gt;链接过来的，查看你的docker配置，&lt;code&gt;—log-dirver&lt;/code&gt;需要设置为&lt;strong&gt;json-file&lt;/strong&gt;格式，默认的可能是&lt;strong&gt;journald&lt;/strong&gt;，参考&lt;a href=&#34;[https://docs.docker.com/engine/admin/logging/overview/#examples](https://docs.docker.com/engine/admin/logging/overview/#examples)&#34;&gt;docker logging&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/kubernetes-es-setting.png&#34; alt=&#34;es-setting&#34; /&gt;&lt;/p&gt;

&lt;p&gt;创建Index后，可以在 &lt;code&gt;Discover&lt;/code&gt; 下看到 ElasticSearch logging 中汇聚的日志；&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/kubernetes-efk-kibana.jpg&#34; alt=&#34;es-home&#34; /&gt;&lt;/p&gt;

&lt;p&gt;至此Kubernetes的所有环境都安装完成。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在开启TLS的Kubernetes1.6集群上安装heapster</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-heapster-installation-with-tls/</link>
      <pubDate>Wed, 12 Apr 2017 20:20:19 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-heapster-installation-with-tls/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2016080801.jpg&#34; alt=&#34;大喵&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：大喵 Aug 8,2016）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这是&lt;a href=&#34;https://github.com/rootsongjc/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;项目(fork自&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;opsnull&lt;/a&gt;)中的一篇文章，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;产生的kuberentes环境，在开启了TLS验证的集群中部署heapster，包括influxdb、grafana等组件。&lt;/p&gt;

&lt;h2 id=&#34;配置和安装heapster&#34;&gt;配置和安装Heapster&lt;/h2&gt;

&lt;p&gt;到 &lt;a href=&#34;https://github.com/kubernetes/heapster/releases&#34;&gt;heapster release 页面&lt;/a&gt; 下载最新版本的 heapster。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ wget https://github.com/kubernetes/heapster/archive/v1.3.0.zip
$ unzip v1.3.0.zip
$ mv v1.3.0.zip heapster-1.3.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件目录： &lt;code&gt;heapster-1.3.0/deploy/kube-config/influxdb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd heapster-1.3.0/deploy/kube-config/influxdb
$ ls *.yaml
grafana-deployment.yaml  grafana-service.yaml  heapster-deployment.yaml  heapster-service.yaml  influxdb-deployment.yaml  influxdb-service.yaml heapster-rbac.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们自己创建了heapster的rbac配置&lt;code&gt;heapster-rbac.yaml&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;已经修改好的 yaml 文件见：&lt;a href=&#34;./manifests/heapster&#34;&gt;heapster&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;配置-grafana-deployment&#34;&gt;配置 grafana-deployment&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ diff grafana-deployment.yaml.orig grafana-deployment.yaml
16c16
&amp;lt;         image: gcr.io/google_containers/heapster-grafana-amd64:v4.0.2
---
&amp;gt;         image: sz-pg-oam-docker-hub-001.tendcloud.com/library/heapster-grafana-amd64:v4.0.2
40,41c40,41
&amp;lt;           # value: /api/v1/proxy/namespaces/kube-system/services/monitoring-grafana/
&amp;lt;           value: /
---
&amp;gt;           value: /api/v1/proxy/namespaces/kube-system/services/monitoring-grafana/
&amp;gt;           #value: /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果后续使用 kube-apiserver 或者 kubectl proxy 访问 grafana dashboard，则必须将 &lt;code&gt;GF_SERVER_ROOT_URL&lt;/code&gt; 设置为 &lt;code&gt;/api/v1/proxy/namespaces/kube-system/services/monitoring-grafana/&lt;/code&gt;，否则后续访问grafana时访问时提示找不到&lt;code&gt;http://10.64.3.7:8086/api/v1/proxy/namespaces/kube-system/services/monitoring-grafana/api/dashboards/home&lt;/code&gt; 页面；&lt;/p&gt;

&lt;h2 id=&#34;配置-heapster-deployment&#34;&gt;配置 heapster-deployment&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ diff heapster-deployment.yaml.orig heapster-deployment.yaml
16c16
&amp;lt;         image: gcr.io/google_containers/heapster-amd64:v1.3.0-beta.1
---
&amp;gt;         image: sz-pg-oam-docker-hub-001.tendcloud.com/library/heapster-amd64:v1.3.0-beta.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置-influxdb-deployment&#34;&gt;配置 influxdb-deployment&lt;/h2&gt;

&lt;p&gt;influxdb 官方建议使用命令行或 HTTP API 接口来查询数据库，从 v1.1.0 版本开始默认关闭 admin UI，将在后续版本中移除 admin UI 插件。&lt;/p&gt;

&lt;p&gt;开启镜像中 admin UI的办法如下：先导出镜像中的 influxdb 配置文件，开启 admin 插件后，再将配置文件内容写入 ConfigMap，最后挂载到镜像中，达到覆盖原始配置的目的：&lt;/p&gt;

&lt;p&gt;注意：manifests 目录已经提供了 &lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster/blob/master/manifests/heapster/influxdb-cm.yaml&#34;&gt;修改后的 ConfigMap 定义文件&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ # 导出镜像中的 influxdb 配置文件
$ docker run --rm --entrypoint &#39;cat&#39;  -ti lvanneo/heapster-influxdb-amd64:v1.1.1 /etc/config.toml &amp;gt;config.toml.orig
$ cp config.toml.orig config.toml
$ # 修改：启用 admin 接口
$ vim config.toml
$ diff config.toml.orig config.toml
35c35
&amp;lt;   enabled = false
---
&amp;gt;   enabled = true
$ # 将修改后的配置写入到 ConfigMap 对象中
$ kubectl create configmap influxdb-config --from-file=config.toml  -n kube-system
configmap &amp;quot;influxdb-config&amp;quot; created
$ # 将 ConfigMap 中的配置文件挂载到 Pod 中，达到覆盖原始配置的目的
$ diff influxdb-deployment.yaml.orig influxdb-deployment.yaml
16c16
&amp;lt;         image: grc.io/google_containers/heapster-influxdb-amd64:v1.1.1
---
&amp;gt;         image: sz-pg-oam-docker-hub-001.tendcloud.com/library/heapster-influxdb-amd64:v1.1.1
19a20,21
&amp;gt;         - mountPath: /etc/
&amp;gt;           name: influxdb-config
22a25,27
&amp;gt;       - name: influxdb-config
&amp;gt;         configMap:
&amp;gt;           name: influxdb-config
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置-monitoring-influxdb-service&#34;&gt;配置 monitoring-influxdb Service&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ diff influxdb-service.yaml.orig influxdb-service.yaml
12a13
&amp;gt;   type: NodePort
15a17,20
&amp;gt;     name: http
&amp;gt;   - port: 8083
&amp;gt;     targetPort: 8083
&amp;gt;     name: admin
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;定义端口类型为 NodePort，额外增加了 admin 端口映射，用于后续浏览器访问 influxdb 的 admin UI 界面；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;执行所有定义文件&#34;&gt;执行所有定义文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pwd
/root/heapster-1.3.0/deploy/kube-config/influxdb
$ ls *.yaml
grafana-service.yaml      heapster-rbac.yaml     influxdb-cm.yaml          influxdb-service.yaml
grafana-deployment.yaml  heapster-deployment.yaml  heapster-service.yaml  influxdb-deployment.yaml
$ kubectl create -f  .
deployment &amp;quot;monitoring-grafana&amp;quot; created
service &amp;quot;monitoring-grafana&amp;quot; created
deployment &amp;quot;heapster&amp;quot; created
serviceaccount &amp;quot;heapster&amp;quot; created
clusterrolebinding &amp;quot;heapster&amp;quot; created
service &amp;quot;heapster&amp;quot; created
configmap &amp;quot;influxdb-config&amp;quot; created
deployment &amp;quot;monitoring-influxdb&amp;quot; created
service &amp;quot;monitoring-influxdb&amp;quot; created
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;检查执行结果&#34;&gt;检查执行结果&lt;/h2&gt;

&lt;p&gt;检查 Deployment&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get deployments -n kube-system | grep -E &#39;heapster|monitoring&#39;
heapster               1         1         1            1           2m
monitoring-grafana     1         1         1            1           2m
monitoring-influxdb    1         1         1            1           2m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检查 Pods&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get pods -n kube-system | grep -E &#39;heapster|monitoring&#39;
heapster-110704576-gpg8v                1/1       Running   0          2m
monitoring-grafana-2861879979-9z89f     1/1       Running   0          2m
monitoring-influxdb-1411048194-lzrpc    1/1       Running   0          2m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检查 kubernets dashboard 界面，看是显示各 Nodes、Pods 的 CPU、内存、负载等利用率曲线图；&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/kubernetes-dashboard-with-heapster.jpg&#34; alt=&#34;dashboard-heapster&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;访问-grafana&#34;&gt;访问 grafana&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;通过 kube-apiserver 访问：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;获取 monitoring-grafana 服务 URL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   $ kubectl cluster-info
   Kubernetes master is running at https://172.20.0.113:6443
   Heapster is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/heapster
   KubeDNS is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/kube-dns
   kubernetes-dashboard is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/kubernetes-dashboard
   monitoring-grafana is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/monitoring-grafana
   monitoring-influxdb is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/monitoring-influxdb

   To further debug and diagnose cluster problems, use &#39;kubectl cluster-info dump&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器访问 URL： &lt;code&gt;http://172.20.0.113:8080/api/v1/proxy/namespaces/kube-system/services/monitoring-grafana&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;通过 kubectl proxy 访问：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;创建代理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;   $ kubectl proxy --address=&#39;172.20.0.113&#39; --port=8086 --accept-hosts=&#39;^*$&#39;
   Starting to serve on 172.20.0.113:8086
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器访问 URL：&lt;code&gt;http://172.20.0.113:8086/api/v1/proxy/namespaces/kube-system/services/monitoring-grafana&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/kubernetes-heapster-grafana.jpg&#34; alt=&#34;grafana&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;访问-influxdb-admin-ui&#34;&gt;访问 influxdb admin UI&lt;/h2&gt;

&lt;p&gt;获取 influxdb http 8086 映射的 NodePort&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get svc -n kube-system|grep influxdb
monitoring-influxdb    10.254.22.46    &amp;lt;nodes&amp;gt;       8086:32299/TCP,8083:30269/TCP   9m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 kube-apiserver 的&lt;strong&gt;非安全端口&lt;/strong&gt;访问 influxdb 的 admin UI 界面： &lt;code&gt;http://172.20.0.113:8080/api/v1/proxy/namespaces/kube-system/services/monitoring-influxdb:8083/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在页面的 “Connection Settings” 的 Host 中输入 node IP， Port 中输入 8086 映射的 nodePort 如上面的 32299，点击 “Save” 即可（我的集群中的地址是172.20.0.113:32299）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/kubernetes-influxdb-heapster.jpg&#34; alt=&#34;kubernetes-influxdb-heapster&#34; /&gt;&lt;/p&gt;

&lt;p&gt;到此Heapster已经部署完成。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在开启TLS的Kubernetes1.6集群上安装dashboard</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-dashboard-installation-with-tls/</link>
      <pubDate>Wed, 12 Apr 2017 15:53:39 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-dashboard-installation-with-tls/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2016082001.jpg&#34; alt=&#34;东直门&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：东直门桥 Aug 20,2016）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;*感谢&lt;a href=&#34;github.com/opsnull&#34;&gt;opsnull&lt;/a&gt;和&lt;a href=&#34;github.com/ipchy&#34;&gt;ipchy&lt;/a&gt;的细心解答*。&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这是&lt;a href=&#34;https://github.com/rootsongjc/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;项目(fork自&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;opsnull&lt;/a&gt;)中的一篇文章，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;产生的kuberentes环境，在开启了TLS验证的集群中部署dashboard。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装环境配置信息&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CentOS 7.2.1511&lt;/li&gt;
&lt;li&gt;Docker 1.12.5&lt;/li&gt;
&lt;li&gt;Flannel 0.7&lt;/li&gt;
&lt;li&gt;Kubernetes 1.6.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置和安装-dashboard&#34;&gt;配置和安装 dashboard&lt;/h2&gt;

&lt;p&gt;官方文件目录：&lt;code&gt;kubernetes/cluster/addons/dashboard&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们使用的文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls *.yaml
dashboard-controller.yaml  dashboard-service.yaml dashboard-rbac.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;已经修改好的 yaml 文件见：&lt;a href=&#34;./manifests/dashboard&#34;&gt;dashboard&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由于 &lt;code&gt;kube-apiserver&lt;/code&gt; 启用了 &lt;code&gt;RBAC&lt;/code&gt; 授权，而官方源码目录的 &lt;code&gt;dashboard-controller.yaml&lt;/code&gt; 没有定义授权的 ServiceAccount，所以后续访问 &lt;code&gt;kube-apiserver&lt;/code&gt; 的 API 时会被拒绝，web中提示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Forbidden (403)

User &amp;quot;system:serviceaccount:kube-system:default&amp;quot; cannot list jobs.batch in the namespace &amp;quot;default&amp;quot;. (get jobs.batch)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;增加了一个&lt;code&gt;dashboard-rbac.yaml&lt;/code&gt;文件，定义一个名为 dashboard 的 ServiceAccount，然后将它和 Cluster Role view 绑定。&lt;/p&gt;

&lt;h2 id=&#34;配置dashboard-service&#34;&gt;配置dashboard-service&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ diff dashboard-service.yaml.orig dashboard-service.yaml
10a11
&amp;gt;   type: NodePort
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;指定端口类型为 NodePort，这样外界可以通过地址 nodeIP:nodePort 访问 dashboard；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置dashboard-controller&#34;&gt;配置dashboard-controller&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ diff dashboard-controller.yaml.orig dashboard-controller.yaml
23c23
&amp;lt;         image: gcr.io/google_containers/kubernetes-dashboard-amd64:v1.6.0
---
&amp;gt;         image: sz-pg-oam-docker-hub-001.tendcloud.com/library/kubernetes-dashboard-amd64:v1.6.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;执行所有定义文件&#34;&gt;执行所有定义文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pwd
/root/kubernetes/cluster/addons/dashboard
$ ls *.yaml
dashboard-controller.yaml  dashboard-service.yaml
$ kubectl create -f  .
service &amp;quot;kubernetes-dashboard&amp;quot; created
deployment &amp;quot;kubernetes-dashboard&amp;quot; created
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;检查执行结果&#34;&gt;检查执行结果&lt;/h2&gt;

&lt;p&gt;查看分配的 NodePort&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get services kubernetes-dashboard -n kube-system
NAME                   CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
kubernetes-dashboard   10.254.224.130   &amp;lt;nodes&amp;gt;       80:30312/TCP   25s
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;NodePort 30312映射到 dashboard pod 80端口；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;检查 controller&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get deployment kubernetes-dashboard  -n kube-system
NAME                   DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
kubernetes-dashboard   1         1         1            1           3m
$ kubectl get pods  -n kube-system | grep dashboard
kubernetes-dashboard-1339745653-pmn6z   1/1       Running   0          4m
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;访问dashboard&#34;&gt;访问dashboard&lt;/h2&gt;

&lt;p&gt;有以下三种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kubernetes-dashboard 服务暴露了 NodePort，可以使用 &lt;code&gt;http://NodeIP:nodePort&lt;/code&gt; 地址访问 dashboard；&lt;/li&gt;
&lt;li&gt;通过 kube-apiserver 访问 dashboard（https 6443端口和http 8080端口方式）；&lt;/li&gt;
&lt;li&gt;通过 kubectl proxy 访问 dashboard：&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;通过-kubectl-proxy-访问-dashboard&#34;&gt;通过 kubectl proxy 访问 dashboard&lt;/h3&gt;

&lt;p&gt;启动代理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl proxy --address=&#39;172.20.0.113&#39; --port=8086 --accept-hosts=&#39;^*$&#39;
Starting to serve on 172.20.0.113:8086
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;需要指定 &lt;code&gt;--accept-hosts&lt;/code&gt; 选项，否则浏览器访问 dashboard 页面时提示 “Unauthorized”；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;浏览器访问 URL：&lt;code&gt;http://172.20.0.113:8086/ui&lt;/code&gt;
自动跳转到：&lt;code&gt;http://172.20.0.113:8086/api/v1/proxy/namespaces/kube-system/services/kubernetes-dashboard/#/workload?namespace=default&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;通过-kube-apiserver-访问dashboard&#34;&gt;通过 kube-apiserver 访问dashboard&lt;/h3&gt;

&lt;p&gt;获取集群服务地址列表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl cluster-info
Kubernetes master is running at https://172.20.0.113:6443
KubeDNS is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/kube-dns
kubernetes-dashboard is running at https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/kubernetes-dashboard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器访问 URL：&lt;code&gt;https://172.20.0.113:6443/api/v1/proxy/namespaces/kube-system/services/kubernetes-dashboard&lt;/code&gt;（浏览器会提示证书验证，因为通过加密通道，以改方式访问的话，需要提前导入证书到你的计算机中）。这是我当时在这遇到的坑：&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster/issues/5&#34;&gt;通过 kube-apiserver 访问dashboard，提示User &amp;ldquo;system:anonymous&amp;rdquo; cannot proxy services in the namespace &amp;ldquo;kube-system&amp;rdquo;. #5&lt;/a&gt;，已经解决。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;导入证书&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将生成的admin.pem证书转换格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openssl pkcs12 -export -in admin.pem  -out admin.p12 -inkey admin-key.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将生成的&lt;code&gt;admin.p12&lt;/code&gt;证书导入的你的电脑，导出的时候记住你设置的密码，导入的时候还要用到。&lt;/p&gt;

&lt;p&gt;如果你不想使用&lt;strong&gt;https&lt;/strong&gt;的话，可以直接访问insecure port 8080端口:&lt;code&gt;http://172.20.0.113:8080/api/v1/proxy/namespaces/kube-system/services/kubernetes-dashboard&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/kubernetes-dashboard-raw.jpg&#34; alt=&#34;kubernetes-dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;由于缺少 Heapster 插件，当前 dashboard 不能展示 Pod、Nodes 的 CPU、内存等 metric 图形。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes安装之kubedns配置</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-kubedns-installation/</link>
      <pubDate>Wed, 12 Apr 2017 13:04:45 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-kubedns-installation/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2016082701.jpg&#34; alt=&#34;东三环&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：雨过天晴@北京定福庄 Aug 27,2016）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这是&lt;a href=&#34;https://github.com/rootsongjc/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;项目(fork自&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;opsnull&lt;/a&gt;)中的一篇文章，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;产生的kuberentes环境，使用yaml文件部署&lt;strong&gt;kubedns&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装环境配置信息&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CentOS 7.2.1511&lt;/li&gt;
&lt;li&gt;Docker 1.12.5&lt;/li&gt;
&lt;li&gt;Flannel 0.7&lt;/li&gt;
&lt;li&gt;Kubernetes 1.6.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装和配置-kubedns-插件&#34;&gt;安装和配置 kubedns 插件&lt;/h2&gt;

&lt;p&gt;官方的yaml文件目录：&lt;code&gt;kubernetes/cluster/addons/dns&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;该插件直接使用kubernetes部署，官方的配置文件中包含以下镜像：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64:1.14.1
gcr.io/google_containers/k8s-dns-kube-dns-amd64:1.14.1
gcr.io/google_containers/k8s-dns-sidecar-amd64:1.14.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我clone了上述镜像，上传到我的私有镜像仓库：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sz-pg-oam-docker-hub-001.tendcloud.com/library/k8s-dns-dnsmasq-nanny-amd64:1.14.1
sz-pg-oam-docker-hub-001.tendcloud.com/library/k8s-dns-kube-dns-amd64:1.14.1
sz-pg-oam-docker-hub-001.tendcloud.com/library/k8s-dns-sidecar-amd64:1.14.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时上传了一份到时速云备份：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;index.tenxcloud.com/jimmy/k8s-dns-dnsmasq-nanny-amd64:1.14.1
index.tenxcloud.com/jimmy/k8s-dns-kube-dns-amd64:1.14.1
index.tenxcloud.com/jimmy/k8s-dns-sidecar-amd64:1.14.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下yaml配置文件中使用的是私有镜像仓库中的镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;kubedns-cm.yaml  
kubedns-sa.yaml  
kubedns-controller.yaml  
kubedns-svc.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;已经修改好的 yaml 文件见：&lt;a href=&#34;https://github.com/rootsongjc/follow-me-install-kubernetes-cluster&#34;&gt;github项目中的manifest/kubedns/目录&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;系统预定义的-rolebinding&#34;&gt;系统预定义的 RoleBinding&lt;/h2&gt;

&lt;p&gt;预定义的 RoleBinding &lt;code&gt;system:kube-dns&lt;/code&gt; 将 kube-system 命名空间的 &lt;code&gt;kube-dns&lt;/code&gt; ServiceAccount 与 &lt;code&gt;system:kube-dns&lt;/code&gt; Role 绑定， 该 Role 具有访问 kube-apiserver DNS 相关 API 的权限；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;$ kubectl get clusterrolebindings system:kube-dns -o yaml
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: &amp;quot;true&amp;quot;
  creationTimestamp: 2017-04-11T11:20:42Z
  labels:
    kubernetes.io/bootstrapping: rbac-defaults
  name: system:kube-dns
  resourceVersion: &amp;quot;58&amp;quot;
  selfLink: /apis/rbac.authorization.k8s.io/v1beta1/clusterrolebindingssystem%3Akube-dns
  uid: e61f4d92-1ea8-11e7-8cd7-f4e9d49f8ed0
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:kube-dns
subjects:
- kind: ServiceAccount
  name: kube-dns
  namespace: kube-system
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;kubedns-controller.yaml&lt;/code&gt; 中定义的 Pods 时使用了 &lt;code&gt;kubedns-sa.yaml&lt;/code&gt; 文件定义的 &lt;code&gt;kube-dns&lt;/code&gt; ServiceAccount，所以具有访问 kube-apiserver DNS 相关 API 的权限。&lt;/p&gt;

&lt;h2 id=&#34;配置-kube-dns-serviceaccount&#34;&gt;配置 kube-dns ServiceAccount&lt;/h2&gt;

&lt;p&gt;无需修改。&lt;/p&gt;

&lt;h2 id=&#34;配置-kube-dns-服务&#34;&gt;配置 &lt;code&gt;kube-dns&lt;/code&gt; 服务&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ diff kubedns-svc.yaml.base kubedns-svc.yaml
30c30
&amp;lt;   clusterIP: __PILLAR__DNS__SERVER__
---
&amp;gt;   clusterIP: 10.254.0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;spec.clusterIP = 10.254.0.2，即明确指定了 kube-dns Service IP，这个 IP 需要和 kubelet 的 &lt;code&gt;--cluster-dns&lt;/code&gt; 参数值一致；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置-kube-dns-deployment&#34;&gt;配置 &lt;code&gt;kube-dns&lt;/code&gt; Deployment&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ diff kubedns-controller.yaml.base kubedns-controller.yaml
58c58
&amp;lt;         image: gcr.io/google_containers/k8s-dns-kube-dns-amd64:1.14.1
---
&amp;gt;         image: sz-pg-oam-docker-hub-001.tendcloud.com/library/k8s-dns-kube-dns-amd64:v1.14.1
88c88
&amp;lt;         - --domain=__PILLAR__DNS__DOMAIN__.
---
&amp;gt;         - --domain=cluster.local.
92c92
&amp;lt;         __PILLAR__FEDERATIONS__DOMAIN__MAP__
---
&amp;gt;         #__PILLAR__FEDERATIONS__DOMAIN__MAP__
110c110
&amp;lt;         image: gcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64:1.14.1
---
&amp;gt;         image: sz-pg-oam-docker-hub-001.tendcloud.com/library/k8s-dns-dnsmasq-nanny-amd64:v1.14.1
129c129
&amp;lt;         - --server=/__PILLAR__DNS__DOMAIN__/127.0.0.1#10053
---
&amp;gt;         - --server=/cluster.local./127.0.0.1#10053
148c148
&amp;lt;         image: gcr.io/google_containers/k8s-dns-sidecar-amd64:1.14.1
---
&amp;gt;         image: sz-pg-oam-docker-hub-001.tendcloud.com/library/k8s-dns-sidecar-amd64:v1.14.1
161,162c161,162
&amp;lt;         - --probe=kubedns,127.0.0.1:10053,kubernetes.default.svc.__PILLAR__DNS__DOMAIN__,5,A
&amp;lt;         - --probe=dnsmasq,127.0.0.1:53,kubernetes.default.svc.__PILLAR__DNS__DOMAIN__,5,A
---
&amp;gt;         - --probe=kubedns,127.0.0.1:10053,kubernetes.default.svc.cluster.local.,5,A
&amp;gt;         - --probe=dnsmasq,127.0.0.1:53,kubernetes.default.svc.cluster.local.,5,A
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用系统已经做了 RoleBinding 的 &lt;code&gt;kube-dns&lt;/code&gt; ServiceAccount，该账户具有访问 kube-apiserver DNS 相关 API 的权限；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;执行所有定义文件&#34;&gt;执行所有定义文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pwd
/root/kubedns
$ ls *.yaml
kubedns-cm.yaml  kubedns-controller.yaml  kubedns-sa.yaml  kubedns-svc.yaml
$ kubectl create -f .
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;检查-kubedns-功能&#34;&gt;检查 kubedns 功能&lt;/h2&gt;

&lt;p&gt;新建一个 Deployment&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat  my-nginx.yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: my-nginx
spec:
  replicas: 2
  template:
    metadata:
      labels:
        run: my-nginx
    spec:
      containers:
      - name: my-nginx
        image: sz-pg-oam-docker-hub-001.tendcloud.com/library/nginx:1.9
        ports:
        - containerPort: 80
$ kubectl create -f my-nginx.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Export 该 Deployment, 生成 &lt;code&gt;my-nginx&lt;/code&gt; 服务&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl expose deploy my-nginx
$ kubectl get services --all-namespaces |grep my-nginx
default       my-nginx     10.254.179.239   &amp;lt;none&amp;gt;        80/TCP          42m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建另一个 Pod，查看 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 是否包含 &lt;code&gt;kubelet&lt;/code&gt; 配置的 &lt;code&gt;--cluster-dns&lt;/code&gt; 和 &lt;code&gt;--cluster-domain&lt;/code&gt;，是否能够将服务 &lt;code&gt;my-nginx&lt;/code&gt; 解析到 Cluster IP &lt;code&gt;10.254.179.239&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl create -f nginx-pod.yaml
$ kubectl exec  nginx -i -t -- /bin/bash
root@nginx:/# cat /etc/resolv.conf
nameserver 10.254.0.2
search default.svc.cluster.local. svc.cluster.local. cluster.local. tendcloud.com
options ndots:5

root@nginx:/# ping my-nginx
PING my-nginx.default.svc.cluster.local (10.254.179.239): 56 data bytes
76 bytes from 119.147.223.109: Destination Net Unreachable
^C--- my-nginx.default.svc.cluster.local ping statistics ---

root@nginx:/# ping kubernetes
PING kubernetes.default.svc.cluster.local (10.254.0.1): 56 data bytes
^C--- kubernetes.default.svc.cluster.local ping statistics ---
11 packets transmitted, 0 packets received, 100% packet loss

root@nginx:/# ping kube-dns.kube-system.svc.cluster.local
PING kube-dns.kube-system.svc.cluster.local (10.254.0.2): 56 data bytes
^C--- kube-dns.kube-system.svc.cluster.local ping statistics ---
6 packets transmitted, 0 packets received, 100% packet loss
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从结果来看，service名称可以正常解析。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes node节点安装</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-node-installation/</link>
      <pubDate>Tue, 11 Apr 2017 22:20:31 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-node-installation/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2016121101.jpg&#34; alt=&#34;东三环&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：太阳宫桥@北京东北三环 Dec 11,2016）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这是&lt;a href=&#34;https://github.com/rootsongjc/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;项目(fork自&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;opsnull&lt;/a&gt;)中的一篇文章，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;产生的kuberentes环境，部署node节点上的&lt;code&gt;kube-proxy&lt;/code&gt;和&lt;code&gt;kubelet&lt;/code&gt;，同时对之前部署的flannel改造。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装环境配置信息&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CentOS7.2.1511&lt;/li&gt;
&lt;li&gt;Docker 1.12.5&lt;/li&gt;
&lt;li&gt;Flannel 0.7&lt;/li&gt;
&lt;li&gt;Kubernetes 1.6.0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;部署kubernetes-node节点&#34;&gt;部署kubernetes node节点&lt;/h2&gt;

&lt;p&gt;kubernetes node 节点包含如下组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Flanneld：参考我之前写的文章&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-network-config/&#34;&gt;Kubernetes基于Flannel的网络配置&lt;/a&gt;，之前没有配置TLS，现在需要在serivce配置文件中增加TLS配置。&lt;/li&gt;
&lt;li&gt;Docker1.12.5：docker的安装很简单，这里也不说了。&lt;/li&gt;
&lt;li&gt;kubelet&lt;/li&gt;
&lt;li&gt;kube-proxy&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面着重讲&lt;code&gt;kubelet&lt;/code&gt;和&lt;code&gt;kube-proxy&lt;/code&gt;的安装，同时还要将之前安装的flannel集成TLS验证。&lt;/p&gt;

&lt;h2 id=&#34;目录和文件&#34;&gt;目录和文件&lt;/h2&gt;

&lt;p&gt;我们再检查一下三个节点上，经过前几步操作生成的配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls /etc/kubernetes/ssl
admin-key.pem  admin.pem  ca-key.pem  ca.pem  kube-proxy-key.pem  kube-proxy.pem  kubernetes-key.pem  kubernetes.pem
$ ls /etc/kubernetes/
apiserver  bootstrap.kubeconfig  config  controller-manager  kubelet  kube-proxy.kubeconfig  proxy  scheduler  ssl  token.csv
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置flanneld&#34;&gt;配置Flanneld&lt;/h2&gt;

&lt;p&gt;参考我之前写的文章&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-network-config/&#34;&gt;Kubernetes基于Flannel的网络配置&lt;/a&gt;，之前没有配置TLS，现在需要在serivce配置文件中增加TLS配置。&lt;/p&gt;

&lt;p&gt;service配置文件&lt;code&gt;/usr/lib/systemd/system/flanneld.service&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Flanneld overlay address etcd agent
After=network.target
After=network-online.target
Wants=network-online.target
After=etcd.service
Before=docker.service

[Service]
Type=notify
EnvironmentFile=/etc/sysconfig/flanneld
EnvironmentFile=-/etc/sysconfig/docker-network
ExecStart=/usr/bin/flanneld-start $FLANNEL_OPTIONS
ExecStartPost=/usr/libexec/flannel/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/docker
Restart=on-failure

[Install]
WantedBy=multi-user.target
RequiredBy=docker.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/sysconfig/flanneld&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;# Flanneld configuration options  

# etcd url location.  Point this to the server where etcd runs
FLANNEL_ETCD_ENDPOINTS=&amp;quot;https://172.20.0.113:2379,https://172.20.0.114:2379,https://172.20.0.115:2379&amp;quot;

# etcd config key.  This is the configuration key that flannel queries
# For address range assignment
FLANNEL_ETCD_PREFIX=&amp;quot;/kube-centos/network&amp;quot;

# Any additional options that you want to pass
FLANNEL_OPTIONS=&amp;quot;-etcd-cafile=/etc/kubernetes/ssl/ca.pem -etcd-certfile=/etc/kubernetes/ssl/kubernetes.pem -etcd-keyfile=/etc/kubernetes/ssl/kubernetes-key.pem&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在FLANNEL_OPTIONS中增加TLS的配置。&lt;/p&gt;

&lt;h2 id=&#34;安装和配置-kubelet&#34;&gt;安装和配置 kubelet&lt;/h2&gt;

&lt;p&gt;kubelet 启动时向 kube-apiserver 发送 TLS bootstrapping 请求，需要先将 bootstrap token 文件中的 kubelet-bootstrap 用户赋予 system:node-bootstrapper cluster 角色(role)，
然后 kubelet 才能有权限创建认证请求(certificate signing requests)：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd /etc/kubernetes
$ kubectl create clusterrolebinding kubelet-bootstrap \
  --clusterrole=system:node-bootstrapper \
  --user=kubelet-bootstrap
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--user=kubelet-bootstrap&lt;/code&gt; 是在 &lt;code&gt;/etc/kubernetes/token.csv&lt;/code&gt; 文件中指定的用户名，同时也写入了 &lt;code&gt;/etc/kubernetes/bootstrap.kubeconfig&lt;/code&gt; 文件；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;下载最新的-kubelet-和-kube-proxy-二进制文件&#34;&gt;下载最新的 kubelet 和 kube-proxy 二进制文件&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ wget https://dl.k8s.io/v1.6.0/kubernetes-server-linux-amd64.tar.gz
$ tar -xzvf kubernetes-server-linux-amd64.tar.gz
$ cd kubernetes
$ tar -xzvf  kubernetes-src.tar.gz
$ cp -r ./server/bin/{kube-proxy,kubelet} /usr/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建-kubelet-的service配置文件&#34;&gt;创建 kubelet 的service配置文件&lt;/h3&gt;

&lt;p&gt;文件位置&lt;code&gt;/usr/lib/systemd/system/kubelet.serivce&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes Kubelet Server
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=docker.service
Requires=docker.service

[Service]
WorkingDirectory=/var/lib/kubelet
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/kubelet
ExecStart=/usr/bin/kubelet \
            $KUBE_LOGTOSTDERR \
            $KUBE_LOG_LEVEL \
            $KUBELET_API_SERVER \
            $KUBELET_ADDRESS \
            $KUBELET_PORT \
            $KUBELET_HOSTNAME \
            $KUBE_ALLOW_PRIV \
            $KUBELET_POD_INFRA_CONTAINER \
            $KUBELET_ARGS
Restart=on-failure

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kubelet的配置文件&lt;code&gt;/etc/kubernetes/kubelet&lt;/code&gt;。其中的IP地址更改为你的每台node节点的IP地址。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;###
## kubernetes kubelet (minion) config
#
## The address for the info server to serve on (set to 0.0.0.0 or &amp;quot;&amp;quot; for all interfaces)
KUBELET_ADDRESS=&amp;quot;--address=172.20.0.113&amp;quot;
#
## The port for the info server to serve on
#KUBELET_PORT=&amp;quot;--port=10250&amp;quot;
#
## You may leave this blank to use the actual hostname
KUBELET_HOSTNAME=&amp;quot;--hostname-override=172.20.0.113&amp;quot;
#
## location of the api-server
KUBELET_API_SERVER=&amp;quot;--api-servers=http://172.20.0.113:8080&amp;quot;
#
## pod infrastructure container
KUBELET_POD_INFRA_CONTAINER=&amp;quot;--pod-infra-container-image=sz-pg-oam-docker-hub-001.tendcloud.com/library/pod-infrastructure:rhel7&amp;quot;
#
## Add your own!
KUBELET_ARGS=&amp;quot;--cgroup-driver=systemd --cluster_dns=10.254.0.2 --experimental-bootstrap-kubeconfig=/etc/kubernetes/bootstrap.kubeconfig --kubeconfig=/etc/kubernetes/kubelet.kubeconfig --require-kubeconfig --cert-dir=/etc/kubernetes/ssl --cluster_domain=cluster.local. --hairpin-mode promiscuous-bridge --serialize-image-pulls=false&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--address&lt;/code&gt; 不能设置为 &lt;code&gt;127.0.0.1&lt;/code&gt;，否则后续 Pods 访问 kubelet 的 API 接口时会失败，因为 Pods 访问的 &lt;code&gt;127.0.0.1&lt;/code&gt; 指向自己而不是 kubelet；&lt;/li&gt;
&lt;li&gt;如果设置了 &lt;code&gt;--hostname-override&lt;/code&gt; 选项，则 &lt;code&gt;kube-proxy&lt;/code&gt; 也需要设置该选项，否则会出现找不到 Node 的情况；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--experimental-bootstrap-kubeconfig&lt;/code&gt; 指向 bootstrap kubeconfig 文件，kubelet 使用该文件中的用户名和 token 向 kube-apiserver 发送 TLS Bootstrapping 请求；&lt;/li&gt;
&lt;li&gt;管理员通过了 CSR 请求后，kubelet 自动在 &lt;code&gt;--cert-dir&lt;/code&gt; 目录创建证书和私钥文件(&lt;code&gt;kubelet-client.crt&lt;/code&gt; 和 &lt;code&gt;kubelet-client.key&lt;/code&gt;)，然后写入 &lt;code&gt;--kubeconfig&lt;/code&gt; 文件；&lt;/li&gt;
&lt;li&gt;建议在 &lt;code&gt;--kubeconfig&lt;/code&gt; 配置文件中指定 &lt;code&gt;kube-apiserver&lt;/code&gt; 地址，如果未指定 &lt;code&gt;--api-servers&lt;/code&gt; 选项，则必须指定 &lt;code&gt;--require-kubeconfig&lt;/code&gt; 选项后才从配置文件中读取 kube-apiserver 的地址，否则 kubelet 启动后将找不到 kube-apiserver (日志中提示未找到 API Server），&lt;code&gt;kubectl get nodes&lt;/code&gt; 不会返回对应的 Node 信息;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--cluster_dns&lt;/code&gt; 指定 kubedns 的 Service IP(可以先分配，后续创建 kubedns 服务时指定该 IP)，&lt;code&gt;--cluster_domain&lt;/code&gt; 指定域名后缀，这两个参数同时指定后才会生效；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整 unit 见 &lt;a href=&#34;./systemd/kubelet.service&#34;&gt;kubelet.service&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;启动kublet&#34;&gt;启动kublet&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl daemon-reload
$ systemctl enable kubelet
$ systemctl start kubelet
$ systemctl status kubelet
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;通过-kublet-的-tls-证书请求&#34;&gt;通过 kublet 的 TLS 证书请求&lt;/h3&gt;

&lt;p&gt;kubelet 首次启动时向 kube-apiserver 发送证书签名请求，必须通过后 kubernetes 系统才会将该 Node 加入到集群。&lt;/p&gt;

&lt;p&gt;查看未授权的 CSR 请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get csr
NAME        AGE       REQUESTOR           CONDITION
csr-2b308   4m        kubelet-bootstrap   Pending
$ kubectl get nodes
No resources found.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过 CSR 请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl certificate approve csr-2b308
certificatesigningrequest &amp;quot;csr-2b308&amp;quot; approved
$ kubectl get nodes
NAME        STATUS    AGE       VERSION
10.64.3.7   Ready     49m       v1.6.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自动生成了 kubelet kubeconfig 文件和公私钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls -l /etc/kubernetes/kubelet.kubeconfig
-rw------- 1 root root 2284 Apr  7 02:07 /etc/kubernetes/kubelet.kubeconfig
$ ls -l /etc/kubernetes/ssl/kubelet*
-rw-r--r-- 1 root root 1046 Apr  7 02:07 /etc/kubernetes/ssl/kubelet-client.crt
-rw------- 1 root root  227 Apr  7 02:04 /etc/kubernetes/ssl/kubelet-client.key
-rw-r--r-- 1 root root 1103 Apr  7 02:07 /etc/kubernetes/ssl/kubelet.crt
-rw------- 1 root root 1675 Apr  7 02:07 /etc/kubernetes/ssl/kubelet.key
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置-kube-proxy&#34;&gt;配置 kube-proxy&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;创建 kube-proxy 的service配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文件路径&lt;code&gt;/usr/lib/systemd/system/kube-proxy.service&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes Kube-Proxy Server
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=network.target

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/proxy
ExecStart=/usr/bin/kube-proxy \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_MASTER \
	    $KUBE_PROXY_ARGS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;kube-proxy配置文件&lt;code&gt;/etc/kubernetes/proxy&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;###
# kubernetes proxy config

# default config should be adequate

# Add your own!
KUBE_PROXY_ARGS=&amp;quot;--bind-address=172.20.0.113 --hostname-override=172.20.0.113 --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig --cluster-cidr=10.254.0.0/16&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--hostname-override&lt;/code&gt; 参数值必须与 kubelet 的值一致，否则 kube-proxy 启动后会找不到该 Node，从而不会创建任何 iptables 规则；&lt;/li&gt;
&lt;li&gt;kube-proxy 根据 &lt;code&gt;--cluster-cidr&lt;/code&gt; 判断集群内部和外部流量，指定 &lt;code&gt;--cluster-cidr&lt;/code&gt; 或 &lt;code&gt;--masquerade-all&lt;/code&gt; 选项后 kube-proxy 才会对访问 Service IP 的请求做 SNAT；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--kubeconfig&lt;/code&gt; 指定的配置文件嵌入了 kube-apiserver 的地址、用户名、证书、秘钥等请求和认证信息；&lt;/li&gt;
&lt;li&gt;预定义的 RoleBinding &lt;code&gt;cluster-admin&lt;/code&gt; 将User &lt;code&gt;system:kube-proxy&lt;/code&gt; 与 Role &lt;code&gt;system:node-proxier&lt;/code&gt; 绑定，该 Role 授予了调用 &lt;code&gt;kube-apiserver&lt;/code&gt; Proxy 相关 API 的权限；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整 unit 见 &lt;a href=&#34;./systemd/kube-proxy.service&#34;&gt;kube-proxy.service&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;启动-kube-proxy&#34;&gt;启动 kube-proxy&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl daemon-reload
$ systemctl enable kube-proxy
$ systemctl start kube-proxy
$ systemctl status kube-proxy
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;验证测试&#34;&gt;验证测试&lt;/h2&gt;

&lt;p&gt;我们创建一个niginx的service试一下集群是否可用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl run nginx --replicas=2 --labels=&amp;quot;run=load-balancer-example&amp;quot; --image=sz-pg-oam-docker-hub-001.tendcloud.com/library/nginx:1.9  --port=80
deployment &amp;quot;nginx&amp;quot; created
$ kubectl expose deployment nginx --type=NodePort --name=example-service
service &amp;quot;example-service&amp;quot; exposed
$ kubectl describe svc example-service
Name:			example-service
Namespace:		default
Labels:			run=load-balancer-example
Annotations:		&amp;lt;none&amp;gt;
Selector:		run=load-balancer-example
Type:			NodePort
IP:			10.254.62.207
Port:			&amp;lt;unset&amp;gt;	80/TCP
NodePort:		&amp;lt;unset&amp;gt;	32724/TCP
Endpoints:		172.30.60.2:80,172.30.94.2:80
Session Affinity:	None
Events:			&amp;lt;none&amp;gt;
$ curl &amp;quot;10.254.62.207:80&amp;quot;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Welcome to nginx!&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;For online documentation and support please refer to
&amp;lt;a href=&amp;quot;http://nginx.org/&amp;quot;&amp;gt;nginx.org&amp;lt;/a&amp;gt;.&amp;lt;br/&amp;gt;
Commercial support is available at
&amp;lt;a href=&amp;quot;http://nginx.com/&amp;quot;&amp;gt;nginx.com&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Thank you for using nginx.&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问&lt;code&gt;172.20.0.113:32724&lt;/code&gt;或&lt;code&gt;172.20.0.114:32724&lt;/code&gt;或者&lt;code&gt;172.20.0.115:32724&lt;/code&gt;都可以得到nginx的页面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/kubernetes-installation-test-nginx.png&#34; alt=&#34;welcome-nginx&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes高可用master节点安装</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-ha-master-installation/</link>
      <pubDate>Tue, 11 Apr 2017 19:55:56 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-ha-master-installation/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2015091402.jpg&#34; alt=&#34;北京西山&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：鬼见愁@北京西山 Sep 14,2015）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这是&lt;a href=&#34;https://github.com/rootsongjc/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;项目((fork自&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;opsnull&lt;/a&gt;))中的一篇文章，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;产生的kuberentes环境，部署master节点的&lt;code&gt;kube-apiserver&lt;/code&gt;、&lt;code&gt;kube-controller-manager&lt;/code&gt;和&lt;code&gt;kube-scheduler&lt;/code&gt;的过程。&lt;/p&gt;

&lt;h2 id=&#34;高可用kubernetes-master节点安装&#34;&gt;高可用kubernetes master节点安装&lt;/h2&gt;

&lt;p&gt;kubernetes master 节点包含的组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kube-apiserver&lt;/li&gt;
&lt;li&gt;kube-scheduler&lt;/li&gt;
&lt;li&gt;kube-controller-manager&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前这三个组件需要部署在同一台机器上。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kube-scheduler&lt;/code&gt;、&lt;code&gt;kube-controller-manager&lt;/code&gt; 和 &lt;code&gt;kube-apiserver&lt;/code&gt; 三者的功能紧密相关；&lt;/li&gt;
&lt;li&gt;同时只能有一个 &lt;code&gt;kube-scheduler&lt;/code&gt;、&lt;code&gt;kube-controller-manager&lt;/code&gt; 进程处于工作状态，如果运行多个，则需要通过选举产生一个 leader；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文档记录部署一个三个节点的高可用 kubernetes master 集群步骤。（后续创建一个 load balancer 来代理访问 kube-apiserver 的请求）&lt;/p&gt;

&lt;h2 id=&#34;tls-证书文件&#34;&gt;TLS 证书文件&lt;/h2&gt;

&lt;p&gt;pem和token.csv证书文件我们在&lt;a href=&#34;./01-TLS证书和秘钥.md&#34;&gt;TLS证书和秘钥&lt;/a&gt;这一步中已经创建过了。我们再检查一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls /etc/kubernetes/ssl
admin-key.pem  admin.pem  ca-key.pem  ca.pem  kube-proxy-key.pem  kube-proxy.pem  kubernetes-key.pem  kubernetes.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;下载最新版本的二进制文件&#34;&gt;下载最新版本的二进制文件&lt;/h2&gt;

&lt;p&gt;有两种下载方式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方式一&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/releases&#34;&gt;github release 页面&lt;/a&gt; 下载发布版 tarball，解压后再执行下载脚本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ wget https://github.com/kubernetes/kubernetes/releases/download/v1.6.0/kubernetes.tar.gz
$ tar -xzvf kubernetes.tar.gz
...
$ cd kubernetes
$ ./cluster/get-kube-binaries.sh
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;方式二&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG.md&#34;&gt;&lt;code&gt;CHANGELOG&lt;/code&gt;页面&lt;/a&gt; 下载 &lt;code&gt;client&lt;/code&gt; 或 &lt;code&gt;server&lt;/code&gt; tarball 文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;server&lt;/code&gt; 的 tarball &lt;code&gt;kubernetes-server-linux-amd64.tar.gz&lt;/code&gt; 已经包含了 &lt;code&gt;client&lt;/code&gt;(&lt;code&gt;kubectl&lt;/code&gt;) 二进制文件，所以不用单独下载&lt;code&gt;kubernetes-client-linux-amd64.tar.gz&lt;/code&gt;文件；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ # wget https://dl.k8s.io/v1.6.0/kubernetes-client-linux-amd64.tar.gz
$ wget https://dl.k8s.io/v1.6.0/kubernetes-server-linux-amd64.tar.gz
$ tar -xzvf kubernetes-server-linux-amd64.tar.gz
...
$ cd kubernetes
$ tar -xzvf  kubernetes-src.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将二进制文件拷贝到指定路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cp -r server/bin/{kube-apiserver,kube-controller-manager,kube-scheduler,kubectl,kube-proxy,kubelet} /root/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置和启动-kube-apiserver&#34;&gt;配置和启动 kube-apiserver&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;创建 kube-apiserver的service配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;serivce配置文件&lt;code&gt;/usr/lib/systemd/system/kube-apiserver.service&lt;/code&gt;内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes API Service
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=network.target
After=etcd.service

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/apiserver
ExecStart=/usr/bin/kube-apiserver \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_ETCD_SERVERS \
	    $KUBE_API_ADDRESS \
	    $KUBE_API_PORT \
	    $KUBELET_PORT \
	    $KUBE_ALLOW_PRIV \
	    $KUBE_SERVICE_ADDRESSES \
	    $KUBE_ADMISSION_CONTROL \
	    $KUBE_API_ARGS
Restart=on-failure
Type=notify
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/kubernetes/config&lt;/code&gt;文件的内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
# kubernetes system config
#
# The following values are used to configure various aspects of all
# kubernetes services, including
#
#   kube-apiserver.service
#   kube-controller-manager.service
#   kube-scheduler.service
#   kubelet.service
#   kube-proxy.service
# logging to stderr means we get it in the systemd journal
KUBE_LOGTOSTDERR=&amp;quot;--logtostderr=true&amp;quot;

# journal message level, 0 is debug
KUBE_LOG_LEVEL=&amp;quot;--v=0&amp;quot;

# Should this cluster be allowed to run privileged docker containers
KUBE_ALLOW_PRIV=&amp;quot;--allow-privileged=true&amp;quot;

# How the controller-manager, scheduler, and proxy find the apiserver
#KUBE_MASTER=&amp;quot;--master=http://sz-pg-oam-docker-test-001.tendcloud.com:8080&amp;quot;
KUBE_MASTER=&amp;quot;--master=http://172.20.0.113:8080&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该配置文件同时被kube-apiserver、kube-controller-manager、kube-scheduler、kubelet、kube-proxy使用。&lt;/p&gt;

&lt;p&gt;apiserver配置文件&lt;code&gt;/etc/kubernetes/apiserver&lt;/code&gt;内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ini&#34;&gt;###
## kubernetes system config
##
## The following values are used to configure the kube-apiserver
##
#
## The address on the local server to listen to.
#KUBE_API_ADDRESS=&amp;quot;--insecure-bind-address=sz-pg-oam-docker-test-001.tendcloud.com&amp;quot;
KUBE_API_ADDRESS=&amp;quot;--advertise-address=172.20.0.113 --bind-address=172.20.0.113 --insecure-bind-address=172.20.0.113&amp;quot;
#
## The port on the local server to listen on.
#KUBE_API_PORT=&amp;quot;--port=8080&amp;quot;
#
## Port minions listen on
#KUBELET_PORT=&amp;quot;--kubelet-port=10250&amp;quot;
#
## Comma separated list of nodes in the etcd cluster
KUBE_ETCD_SERVERS=&amp;quot;--etcd-servers=https://172.20.0.113:2379,172.20.0.114:2379,172.20.0.115:2379&amp;quot;
#
## Address range to use for services
KUBE_SERVICE_ADDRESSES=&amp;quot;--service-cluster-ip-range=10.254.0.0/16&amp;quot;
#
## default admission control policies
KUBE_ADMISSION_CONTROL=&amp;quot;--admission-control=ServiceAccount,NamespaceLifecycle,NamespaceExists,LimitRanger,ResourceQuota&amp;quot;
#
## Add your own!
KUBE_API_ARGS=&amp;quot;--authorization-mode=RBAC --runtime-config=rbac.authorization.k8s.io/v1beta1 --kubelet-https=true --experimental-bootstrap-token-auth --token-auth-file=/etc/kubernetes/token.csv --service-node-port-range=30000-32767 --tls-cert-file=/etc/kubernetes/ssl/kubernetes.pem --tls-private-key-file=/etc/kubernetes/ssl/kubernetes-key.pem --client-ca-file=/etc/kubernetes/ssl/ca.pem --service-account-key-file=/etc/kubernetes/ssl/ca-key.pem --etcd-cafile=/etc/kubernetes/ssl/ca.pem --etcd-certfile=/etc/kubernetes/ssl/kubernetes.pem --etcd-keyfile=/etc/kubernetes/ssl/kubernetes-key.pem --enable-swagger-ui=true --apiserver-count=3 --audit-log-maxage=30 --audit-log-maxbackup=3 --audit-log-maxsize=100 --audit-log-path=/var/lib/audit.log --event-ttl=1h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--authorization-mode=RBAC&lt;/code&gt; 指定在安全端口使用 RBAC 授权模式，拒绝未通过授权的请求；&lt;/li&gt;
&lt;li&gt;kube-scheduler、kube-controller-manager 一般和 kube-apiserver 部署在同一台机器上，它们使用&lt;strong&gt;非安全端口&lt;/strong&gt;和 kube-apiserver通信;&lt;/li&gt;
&lt;li&gt;kubelet、kube-proxy、kubectl 部署在其它 Node 节点上，如果通过&lt;strong&gt;安全端口&lt;/strong&gt;访问 kube-apiserver，则必须先通过 TLS 证书认证，再通过 RBAC 授权；&lt;/li&gt;
&lt;li&gt;kube-proxy、kubectl 通过在使用的证书里指定相关的 User、Group 来达到通过 RBAC 授权的目的；&lt;/li&gt;
&lt;li&gt;如果使用了 kubelet TLS Boostrap 机制，则不能再指定 &lt;code&gt;--kubelet-certificate-authority&lt;/code&gt;、&lt;code&gt;--kubelet-client-certificate&lt;/code&gt; 和 &lt;code&gt;--kubelet-client-key&lt;/code&gt; 选项，否则后续 kube-apiserver 校验 kubelet 证书时出现 ”x509: certificate signed by unknown authority“ 错误；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--admission-control&lt;/code&gt; 值必须包含 &lt;code&gt;ServiceAccount&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--bind-address&lt;/code&gt; 不能为 &lt;code&gt;127.0.0.1&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;runtime-config&lt;/code&gt;配置为&lt;code&gt;rbac.authorization.k8s.io/v1beta1&lt;/code&gt;，表示运行时的apiVersion；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--service-cluster-ip-range&lt;/code&gt; 指定 Service Cluster IP 地址段，该地址段不能路由可达；&lt;/li&gt;
&lt;li&gt;缺省情况下 kubernetes 对象保存在 etcd &lt;code&gt;/registry&lt;/code&gt; 路径下，可以通过 &lt;code&gt;--etcd-prefix&lt;/code&gt; 参数进行调整；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整 unit 见 &lt;a href=&#34;./systemd/kube-apiserver.service&#34;&gt;kube-apiserver.service&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启动kube-apiserver&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl daemon-reload
$ systemctl enable kube-apiserver
$ systemctl start kube-apiserver
$ systemctl status kube-apiserver
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置和启动-kube-controller-manager&#34;&gt;配置和启动 kube-controller-manager&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;创建 kube-controller-manager的serivce配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文件路径&lt;code&gt;/usr/lib/systemd/system/kube-controller-manager.service&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;Description=Kubernetes Controller Manager
Documentation=https://github.com/GoogleCloudPlatform/kubernetes

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/controller-manager
ExecStart=/usr/bin/kube-controller-manager \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_MASTER \
	    $KUBE_CONTROLLER_MANAGER_ARGS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件&lt;code&gt;/etc/kubernetes/controller-manager&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
# The following values are used to configure the kubernetes controller-manager

# defaults from config and apiserver should be adequate

# Add your own!
KUBE_CONTROLLER_MANAGER_ARGS=&amp;quot;--address=127.0.0.1 --service-cluster-ip-range=10.254.0.0/16 --cluster-name=kubernetes --cluster-signing-cert-file=/etc/kubernetes/ssl/ca.pem --cluster-signing-key-file=/etc/kubernetes/ssl/ca-key.pem  --service-account-private-key-file=/etc/kubernetes/ssl/ca-key.pem --root-ca-file=/etc/kubernetes/ssl/ca.pem --leader-elect=true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;--service-cluster-ip-range&lt;/code&gt; 参数指定 Cluster 中 Service 的CIDR范围，该网络在各 Node 间必须路由不可达，必须和 kube-apiserver 中的参数一致；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--cluster-signing-*&lt;/code&gt; 指定的证书和私钥文件用来签名为 TLS BootStrap 创建的证书和私钥；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--root-ca-file&lt;/code&gt; 用来对 kube-apiserver 证书进行校验，&lt;strong&gt;指定该参数后，才会在Pod 容器的 ServiceAccount 中放置该 CA 证书文件&lt;/strong&gt;；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--address&lt;/code&gt; 值必须为 &lt;code&gt;127.0.0.1&lt;/code&gt;，因为当前 kube-apiserver 期望 scheduler 和 controller-manager 在同一台机器，否则：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  $ kubectl get componentstatuses
  NAME                 STATUS      MESSAGE                                                                                        ERROR
  scheduler            Unhealthy   Get http://127.0.0.1:10251/healthz: dial tcp 127.0.0.1:10251: getsockopt: connection refused   
  controller-manager   Healthy     ok                                                                                             
  etcd-2               Unhealthy   Get http://172.20.0.113:2379/health: malformed HTTP response &amp;quot;\x15\x03\x01\x00\x02\x02&amp;quot;        
  etcd-0               Healthy     {&amp;quot;health&amp;quot;: &amp;quot;true&amp;quot;}                                                                             
  etcd-1               Healthy     {&amp;quot;health&amp;quot;: &amp;quot;true&amp;quot;}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://github.com/kubernetes-incubator/bootkube/issues/64&#34;&gt;https://github.com/kubernetes-incubator/bootkube/issues/64&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;完整 unit 见 &lt;a href=&#34;./systemd/kube-controller-manager.service&#34;&gt;kube-controller-manager.service&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;启动-kube-controller-manager&#34;&gt;启动 kube-controller-manager&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl daemon-reload
$ systemctl enable kube-controller-manager
$ systemctl start kube-controller-manager
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置和启动-kube-scheduler&#34;&gt;配置和启动 kube-scheduler&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;创建 kube-scheduler的serivce配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文件路径&lt;code&gt;/usr/lib/systemd/system/kube-scheduler.serivce&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes Scheduler Plugin
Documentation=https://github.com/GoogleCloudPlatform/kubernetes

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/scheduler
ExecStart=/usr/bin/kube-scheduler \
            $KUBE_LOGTOSTDERR \
            $KUBE_LOG_LEVEL \
            $KUBE_MASTER \
            $KUBE_SCHEDULER_ARGS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件&lt;code&gt;/etc/kubernetes/scheduler&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ini&#34;&gt;###
# kubernetes scheduler config

# default config should be adequate

# Add your own!
KUBE_SCHEDULER_ARGS=&amp;quot;--leader-elect=true --address=127.0.0.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--address&lt;/code&gt; 值必须为 &lt;code&gt;127.0.0.1&lt;/code&gt;，因为当前 kube-apiserver 期望 scheduler 和 controller-manager 在同一台机器；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整 unit 见 &lt;a href=&#34;./systemd/kube-scheduler.service&#34;&gt;kube-scheduler.service&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;启动-kube-scheduler&#34;&gt;启动 kube-scheduler&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl daemon-reload
$ systemctl enable kube-scheduler
$ systemctl start kube-scheduler
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;验证-master-节点功能&#34;&gt;验证 master 节点功能&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get componentstatuses
NAME                 STATUS    MESSAGE              ERROR
scheduler            Healthy   ok                   
controller-manager   Healthy   ok                   
etcd-0               Healthy   {&amp;quot;health&amp;quot;: &amp;quot;true&amp;quot;}   
etcd-1               Healthy   {&amp;quot;health&amp;quot;: &amp;quot;true&amp;quot;}   
etcd-2               Healthy   {&amp;quot;health&amp;quot;: &amp;quot;true&amp;quot;}   
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;当时在配置过程中遇到了问题&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster/issues/4&#34;&gt;TLS认证相关的问题&lt;/a&gt;，其实就是因为配置apiserver时候etcd的协议写成了http导致的，应该是用https。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;Opsnull&lt;/a&gt;写的kubernetes高可用master集群部署过程中似乎并没有包括&lt;strong&gt;高可用的配置&lt;/strong&gt;，才云科技的唐继元分享过&lt;a href=&#34;https://segmentfault.com/a/1190000005832319&#34;&gt;Kubernetes Master High Availability 高级实践&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;究竟如何实现kubernetes master的高可用还需要继续探索。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes安装之etcd高可用配置</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-etcd-ha-config/</link>
      <pubDate>Tue, 11 Apr 2017 15:21:39 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-etcd-ha-config/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2015091401.jpg&#34; alt=&#34;西山俯瞰北京夜景&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：北京夜景@西山）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这是&lt;a href=&#34;https://github.com/rootsongjc/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;项目((fork自&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;opsnull&lt;/a&gt;))中的一篇文章，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;产生的kuberentes环境，生成&lt;strong&gt;kubeconfig&lt;/strong&gt;文件的过程。&lt;/p&gt;

&lt;h2 id=&#34;创建高可用-etcd-集群&#34;&gt;创建高可用 etcd 集群&lt;/h2&gt;

&lt;p&gt;kuberntes 系统使用 etcd 存储所有数据，本文档介绍部署一个三节点高可用 etcd 集群的步骤，这三个节点复用 kubernetes master 机器，分别命名为&lt;code&gt;sz-pg-oam-docker-test-001.tendcloud.com&lt;/code&gt;、&lt;code&gt;sz-pg-oam-docker-test-002.tendcloud.com&lt;/code&gt;、&lt;code&gt;sz-pg-oam-docker-test-003.tendcloud.com&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sz-pg-oam-docker-test-001.tendcloud.com：172.20.0.113&lt;/li&gt;
&lt;li&gt;sz-pg-oam-docker-test-002.tendcloud.com：172.20.0.114&lt;/li&gt;
&lt;li&gt;sz-pg-oam-docker-test-003.tendcloud.com：172.20.0.115&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tls-认证文件&#34;&gt;TLS 认证文件&lt;/h2&gt;

&lt;p&gt;需要为 etcd 集群创建加密通信的 TLS 证书，这里复用以前创建的 kubernetes 证书&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cp ca.pem kubernetes-key.pem kubernetes.pem /etc/kubernetes/ssl
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;kubernetes 证书的 &lt;code&gt;hosts&lt;/code&gt; 字段列表中包含上面三台机器的 IP，否则后续证书校验会失败；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;下载二进制文件&#34;&gt;下载二进制文件&lt;/h2&gt;

&lt;p&gt;到 &lt;code&gt;https://github.com/coreos/etcd/releases&lt;/code&gt; 页面下载最新版本的二进制文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ https://github.com/coreos/etcd/releases/download/v3.1.5/etcd-v3.1.5-linux-amd64.tar.gz
$ tar -xvf etcd-v3.1.4-linux-amd64.tar.gz
$ sudo mv etcd-v3.1.4-linux-amd64/etcd* /root/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建-etcd-的-systemd-unit-文件&#34;&gt;创建 etcd 的 systemd unit 文件&lt;/h2&gt;

&lt;p&gt;注意替换 &lt;code&gt;ETCD_NAME&lt;/code&gt; 和 &lt;code&gt;INTERNAL_IP&lt;/code&gt; 变量的值；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export ETCD_NAME=sz-pg-oam-docker-test-001.tendcloud.com
$ export INTERNAL_IP=172.20.0.113
$ sudo mkdir -p /var/lib/etcd /var/lib/etcd
$ cat &amp;gt; etcd.service &amp;lt;&amp;lt;EOF
[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target
Documentation=https://github.com/coreos

[Service]
Type=notify
WorkingDirectory=/var/lib/etcd/
EnvironmentFile=-/etc/etcd/etcd.conf
ExecStart=/root/local/bin/etcd \\
  --name ${ETCD_NAME} \\
  --cert-file=/etc/kubernetes/ssl/kubernetes.pem \\
  --key-file=/etc/kubernetes/ssl/kubernetes-key.pem \\
  --peer-cert-file=/etc/kubernetes/ssl/kubernetes.pem \\
  --peer-key-file=/etc/kubernetes/ssl/kubernetes-key.pem \\
  --trusted-ca-file=/etc/kubernetes/ssl/ca.pem \\
  --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem \\
  --initial-advertise-peer-urls https://${INTERNAL_IP}:2380 \\
  --listen-peer-urls https://${INTERNAL_IP}:2380 \\
  --listen-client-urls https://${INTERNAL_IP}:2379,https://127.0.0.1:2379 \\
  --advertise-client-urls https://${INTERNAL_IP}:2379 \\
  --initial-cluster-token etcd-cluster-0 \\
  --initial-cluster sz-pg-oam-docker-test-001.tendcloud.com=https://172.20.0.113:2380,sz-pg-oam-docker-test-002.tendcloud.com=https://172.20.0.114:2380,sz-pg-oam-docker-test-003.tendcloud.com=https://172.20.0.115:2380 \\
  --initial-cluster-state new \\
  --data-dir=/var/lib/etcd
Restart=on-failure
RestartSec=5
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;指定 &lt;code&gt;etcd&lt;/code&gt; 的工作目录为 &lt;code&gt;/var/lib/etcd&lt;/code&gt;，数据目录为 &lt;code&gt;/var/lib/etcd&lt;/code&gt;，需在启动服务前创建这两个目录；&lt;/li&gt;
&lt;li&gt;为了保证通信安全，需要指定 etcd 的公私钥(cert-file和key-file)、Peers 通信的公私钥和 CA 证书(peer-cert-file、peer-key-file、peer-trusted-ca-file)、客户端的CA证书（trusted-ca-file）；&lt;/li&gt;
&lt;li&gt;创建 &lt;code&gt;kubernetes.pem&lt;/code&gt; 证书时使用的 &lt;code&gt;kubernetes-csr.json&lt;/code&gt; 文件的 &lt;code&gt;hosts&lt;/code&gt; 字段&lt;strong&gt;包含所有 etcd 节点的 INTERNAL_IP&lt;/strong&gt;，否则证书校验会出错；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--initial-cluster-state&lt;/code&gt; 值为 &lt;code&gt;new&lt;/code&gt; 时，&lt;code&gt;--name&lt;/code&gt; 的参数值必须位于 &lt;code&gt;--initial-cluster&lt;/code&gt; 列表中；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整 unit 文件见：&lt;a href=&#34;./systemd/etcd.service&#34;&gt;etcd.service&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;启动-etcd-服务&#34;&gt;启动 etcd 服务&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo mv etcd.service /etc/systemd/system/
$ sudo systemctl daemon-reload
$ sudo systemctl enable etcd
$ sudo systemctl start etcd
$ systemctl status etcd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在所有的 kubernetes master 节点重复上面的步骤，直到所有机器的 etcd 服务都已启动。&lt;/p&gt;

&lt;h2 id=&#34;验证服务&#34;&gt;验证服务&lt;/h2&gt;

&lt;p&gt;在任一 kubernetes master 机器上执行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ etcdctl \
  --ca-file=/etc/kubernetes/ssl/ca.pem \
  --cert-file=/etc/kubernetes/ssl/kubernetes.pem \
  --key-file=/etc/kubernetes/ssl/kubernetes-key.pem \
  cluster-health
2017-04-11 15:17:09.082250 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated
2017-04-11 15:17:09.083681 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated
member 9a2ec640d25672e5 is healthy: got healthy result from https://172.20.0.115:2379
member bc6f27ae3be34308 is healthy: got healthy result from https://172.20.0.114:2379
member e5c92ea26c4edba0 is healthy: got healthy result from https://172.20.0.113:2379
cluster is healthy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果最后一行为 &lt;code&gt;cluster is healthy&lt;/code&gt; 时表示集群服务正常。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes安装之创建kubeconfig文件</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-create-kubeconfig/</link>
      <pubDate>Tue, 11 Apr 2017 14:34:54 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-create-kubeconfig/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2016050801.jpg&#34; alt=&#34;北海公园&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(题图：北海公园 May 8,2016)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这是&lt;a href=&#34;https://github.com/rootsongjc/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;项目((fork自&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;opsnull&lt;/a&gt;))中的一篇文章，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;产生的kuberentes环境，生成&lt;strong&gt;kubeconfig&lt;/strong&gt;文件的过程。
&lt;code&gt;kubelet&lt;/code&gt;、&lt;code&gt;kube-proxy&lt;/code&gt; 等 Node 机器上的进程与 Master 机器的 &lt;code&gt;kube-apiserver&lt;/code&gt; 进程通信时需要认证和授权；
kubernetes 1.4 开始支持由 &lt;code&gt;kube-apiserver&lt;/code&gt; 为客户端生成 TLS 证书的 &lt;a href=&#34;https://kubernetes.io/docs/admin/kubelet-tls-bootstrapping/&#34;&gt;TLS Bootstrapping&lt;/a&gt; 功能，这样就不需要为每个客户端生成证书了；该功能&lt;strong&gt;当前仅支持为 &lt;code&gt;kubelet&lt;/code&gt;&lt;/strong&gt; 生成证书。&lt;/p&gt;

&lt;h2 id=&#34;创建-tls-bootstrapping-token&#34;&gt;创建 TLS Bootstrapping Token&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Token auth file&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Token可以是任意的包涵128 bit的字符串，可以使用安全的随机数发生器生成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export BOOTSTRAP_TOKEN=$(head -c 16 /dev/urandom | od -An -t x | tr -d &#39; &#39;)
cat &amp;gt; token.csv &amp;lt;&amp;lt;EOF
${BOOTSTRAP_TOKEN},kubelet-bootstrap,10001,&amp;quot;system:kubelet-bootstrap&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;后三行是一句，直接复制上面的脚本运行即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;将token.csv发到所有机器（Master 和 Node）的 &lt;code&gt;/etc/kubernetes/&lt;/code&gt; 目录。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$cp token.csv /etc/kubernetes/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建-kubelet-bootstrapping-kubeconfig-文件&#34;&gt;创建 kubelet bootstrapping kubeconfig 文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd /etc/kubernetes
$ export KUBE_APISERVER=&amp;quot;https://172.20.0.113:6443&amp;quot;
$ # 设置集群参数
$ kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=bootstrap.kubeconfig
$ # 设置客户端认证参数
$ kubectl config set-credentials kubelet-bootstrap \
  --token=${BOOTSTRAP_TOKEN} \
  --kubeconfig=bootstrap.kubeconfig
$ # 设置上下文参数
$ kubectl config set-context default \
  --cluster=kubernetes \
  --user=kubelet-bootstrap \
  --kubeconfig=bootstrap.kubeconfig
$ # 设置默认上下文
$ kubectl config use-context default --kubeconfig=bootstrap.kubeconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--embed-certs&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时表示将 &lt;code&gt;certificate-authority&lt;/code&gt; 证书写入到生成的 &lt;code&gt;bootstrap.kubeconfig&lt;/code&gt; 文件中；&lt;/li&gt;
&lt;li&gt;设置客户端认证参数时&lt;strong&gt;没有&lt;/strong&gt;指定秘钥和证书，后续由 &lt;code&gt;kube-apiserver&lt;/code&gt; 自动生成；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;创建-kube-proxy-kubeconfig-文件&#34;&gt;创建 kube-proxy kubeconfig 文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export KUBE_APISERVER=&amp;quot;https://172.20.0.113:6443&amp;quot;
$ # 设置集群参数
$ kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=kube-proxy.kubeconfig
$ # 设置客户端认证参数
$ kubectl config set-credentials kube-proxy \
  --client-certificate=/etc/kubernetes/ssl/kube-proxy.pem \
  --client-key=/etc/kubernetes/ssl/kube-proxy-key.pem \
  --embed-certs=true \
  --kubeconfig=kube-proxy.kubeconfig
$ # 设置上下文参数
$ kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-proxy \
  --kubeconfig=kube-proxy.kubeconfig
$ # 设置默认上下文
$ kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;设置集群参数和客户端认证参数时 &lt;code&gt;--embed-certs&lt;/code&gt; 都为 &lt;code&gt;true&lt;/code&gt;，这会将 &lt;code&gt;certificate-authority&lt;/code&gt;、&lt;code&gt;client-certificate&lt;/code&gt; 和 &lt;code&gt;client-key&lt;/code&gt; 指向的证书文件内容写入到生成的 &lt;code&gt;kube-proxy.kubeconfig&lt;/code&gt; 文件中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kube-proxy.pem&lt;/code&gt; 证书中 CN 为 &lt;code&gt;system:kube-proxy&lt;/code&gt;，&lt;code&gt;kube-apiserver&lt;/code&gt; 预定义的 RoleBinding &lt;code&gt;cluster-admin&lt;/code&gt; 将User &lt;code&gt;system:kube-proxy&lt;/code&gt; 与 Role &lt;code&gt;system:node-proxier&lt;/code&gt; 绑定，该 Role 授予了调用 &lt;code&gt;kube-apiserver&lt;/code&gt; Proxy 相关 API 的权限；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;分发-kubeconfig-文件&#34;&gt;分发 kubeconfig 文件&lt;/h2&gt;

&lt;p&gt;将两个 kubeconfig 文件分发到所有 Node 机器的 &lt;code&gt;/etc/kubernetes/&lt;/code&gt; 目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cp bootstrap.kubeconfig kube-proxy.kubeconfig /etc/kubernetes/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>开源微服务管理平台fabric8简介</title>
      <link>http://rootsongjc.github.io/blogs/fabric8-introduction/</link>
      <pubDate>Mon, 10 Apr 2017 21:39:00 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/fabric8-introduction/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://fabric8.io/images/fabric8_logo.svg&#34; alt=&#34;fabric8&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;无意中发现&lt;a href=&#34;https://github.com/fabric8io/fabric8&#34;&gt;Fabric8&lt;/a&gt;这个&lt;strong&gt;对于Java友好的开源微服务管理平台&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;其实这在这里发现的&lt;a href=&#34;http://blog.sonatype.com/achieving-ci/cd-with-kubernetes&#34;&gt;Achieving CI/CD with Kubernetes&lt;/a&gt;（by Ramit Surana,on February 17, 2017），其实是先在&lt;a href=&#34;https://www.slideshare.net/ramitsurana/achieving-cicd-with-kubernetes&#34;&gt;slideshare&lt;/a&gt;上看到的，pdf可以&lt;a href=&#34;http://olz1di9xf.bkt.clouddn.com/achiveving-ci-cd-with-kubernetes-ramit-surana.pdf&#34;&gt;在此下载&lt;/a&gt;，大小2.04M。&lt;/p&gt;

&lt;p&gt;大家可能以前听过一个叫做&lt;a href=&#34;https://github.com/fabric/fabric/&#34;&gt;fabric&lt;/a&gt;的工具，那是一个 Python (2.5-2.7) 库和命令行工具，用来流水线化执行 SSH 以部署应用或系统管理任务。所以大家不要把fabric8跟fabric搞混，虽然它们之间有一些共同点，但两者完全不是同一个东西，&lt;strong&gt;fabric8不是fabric的一个版本&lt;/strong&gt;。Fabric是用python开发的，fabric8是java开发的。&lt;/p&gt;

&lt;p&gt;如果你想了解简化Fabric可以看它的&lt;a href=&#34;http://fabric-docs-cn.readthedocs.io/zh_CN/latest/tutorial.html&#34;&gt;中文官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;fabric8简介&#34;&gt;Fabric8简介&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;fabric8&lt;/strong&gt;是一个开源&lt;strong&gt;集成开发平台&lt;/strong&gt;，为基于&lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt;和&lt;a href=&#34;https://jenkins.io/&#34;&gt;Jenkins&lt;/a&gt;的微服务提供&lt;a href=&#34;http://fabric8.io/guide/cdelivery.html&#34;&gt;持续发布&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;使用fabric可以很方便的通过&lt;a href=&#34;http://fabric8.io/guide/cdelivery.html&#34;&gt;Continuous Delivery pipelines&lt;/a&gt;创建、编译、部署和测试微服务，然后通过Continuous Improvement和&lt;a href=&#34;http://fabric8.io/guide/chat.html&#34;&gt;ChatOps&lt;/a&gt;运行和管理他们。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://fabric8.io/guide/fabric8DevOps.html&#34;&gt;Fabric8微服务平台&lt;/a&gt;提供：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/console.html&#34;&gt;Developer Console&lt;/a&gt;，是一个&lt;a href=&#34;http://www.infoq.com/cn/news/2014/11/seven-principles-rich-web-app&#34;&gt;富web应用&lt;/a&gt;，提供一个单页面来创建、编辑、编译、部署和测试微服务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/cdelivery.html&#34;&gt;Continuous Integration and Continous Delivery&lt;/a&gt;，使用 &lt;a href=&#34;https://jenkins.io/&#34;&gt;Jenkins&lt;/a&gt; with a &lt;a href=&#34;http://fabric8.io/guide/jenkinsWorkflowLibrary.html&#34;&gt;Jenkins Workflow Library&lt;/a&gt;更快和更可靠的交付软件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/management.html&#34;&gt;Management&lt;/a&gt;，集中式管理&lt;a href=&#34;http://fabric8.io/guide/logging.html&#34;&gt;Logging&lt;/a&gt;、&lt;a href=&#34;http://fabric8.io/guide/metrics.html&#34;&gt;Metrics&lt;/a&gt;, &lt;a href=&#34;http://fabric8.io/guide/chat.html&#34;&gt;ChatOps&lt;/a&gt;、&lt;a href=&#34;http://fabric8.io/guide/chaosMonkey.html&#34;&gt;Chaos Monkey&lt;/a&gt;，使用&lt;a href=&#34;http://hawt.io/&#34;&gt;Hawtio&lt;/a&gt;和&lt;a href=&#34;http://jolokia.org/&#34;&gt;Jolokia&lt;/a&gt;管理Java Containers。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/ipaas.html&#34;&gt;Integration&lt;/a&gt; &lt;u&gt;&lt;em&gt;Integration Platform As A Service&lt;/em&gt;&lt;/u&gt; with &lt;a href=&#34;http://fabric8.io/guide/console.html&#34;&gt;deep visualisation&lt;/a&gt; of your &lt;a href=&#34;http://camel.apache.org/&#34;&gt;Apache Camel&lt;/a&gt; integration services, an &lt;a href=&#34;http://fabric8.io/guide/apiRegistry.html&#34;&gt;API Registry&lt;/a&gt; to view of all your RESTful and SOAP APIs and &lt;a href=&#34;http://fabric8.io/guide/fabric8MQ.html&#34;&gt;Fabric8 MQ&lt;/a&gt; provides &lt;u&gt;&lt;em&gt;Messaging As A Service&lt;/em&gt;&lt;/u&gt; based on &lt;a href=&#34;http://activemq.apache.org/&#34;&gt;Apache ActiveMQ&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/tools.html&#34;&gt;Java Tools&lt;/a&gt; 帮助Java应用使用&lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt;:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/mavenPlugin.html&#34;&gt;Maven Plugin&lt;/a&gt; for working with &lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt; ，这真是极好的&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/testing.html&#34;&gt;Integration and System Testing&lt;/a&gt; of &lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt; resources easily inside &lt;a href=&#34;http://junit.org/&#34;&gt;JUnit&lt;/a&gt; with &lt;a href=&#34;http://arquillian.org/&#34;&gt;Arquillian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/javaLibraries.html&#34;&gt;Java Libraries&lt;/a&gt; and support for &lt;a href=&#34;http://fabric8.io/guide/cdi.html&#34;&gt;CDI&lt;/a&gt; extensions for working with &lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;fabric8微服务平台&#34;&gt;Fabric8微服务平台&lt;/h2&gt;

&lt;p&gt;Fabric8提供了一个完全集成的开源微服务平台，可在任何的&lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt;和&lt;a href=&#34;http://www.openshift.org/&#34;&gt;OpenShift&lt;/a&gt;环境中开箱即用。&lt;/p&gt;

&lt;p&gt;整个平台是基于微服务而且是模块化的，你可以按照微服务的方式来使用它。&lt;/p&gt;

&lt;p&gt;微服务平台提供的服务有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开发者控制台，这是一个富Web应用程序，它提供了一个单一的页面来创建、编辑、编译、部署和测试微服务。&lt;/li&gt;
&lt;li&gt;持续集成和持续交付，帮助团队以更快更可靠的方式交付软件，可以使用以下开源软件：

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jenkins.io/&#34;&gt;Jenkins&lt;/a&gt;：CI／CD pipeline&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sonatype.org/nexus/&#34;&gt;Nexus&lt;/a&gt;： 组件库&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gogs.io/&#34;&gt;Gogs&lt;/a&gt;：git代码库&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sonarqube.org/&#34;&gt;SonarQube&lt;/a&gt;：代码质量维护平台&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/jenkinsWorkflowLibrary.html&#34;&gt;Jenkins Workflow Library&lt;/a&gt;：在不同的项目中复用&lt;a href=&#34;https://github.com/fabric8io/jenkins-workflow-library&#34;&gt;Jenkins Workflow scripts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/fabric8YmlFile.html&#34;&gt;Fabric8.yml&lt;/a&gt;：为每个项目、存储库、聊天室、工作流脚本和问题跟踪器提供一个配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/chat.html&#34;&gt;ChatOps&lt;/a&gt;：通过使用&lt;a href=&#34;https://hubot.github.com/&#34;&gt;hubot&lt;/a&gt;来开发和管理，能够让你的团队拥抱DevOps，通过聊天和系统通知的方式来&lt;a href=&#34;https://github.com/fabric8io/fabric8-jenkins-workflow-steps#hubotapprove&#34;&gt;approval of release promotion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/chaosMonkey.html&#34;&gt;Chaos Monkey&lt;/a&gt;：通过干掉&lt;a href=&#34;http://fabric8.io/guide/pods.html&#34;&gt;pods&lt;/a&gt;来测试系统健壮性和可靠性&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/management.html&#34;&gt;管理&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/logging.html&#34;&gt;日志&lt;/a&gt; 统一集群日志和可视化查看状态&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/metrics.html&#34;&gt;metris&lt;/a&gt; 可查看历史metrics和可视化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://hao.jobbole.com/fabric8/&#34;&gt;fabric8：容器集成平台——伯乐在线&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI0NjI4MDg5MQ==&amp;amp;mid=2715290731&amp;amp;idx=1&amp;amp;sn=f1fcacb9aa4f1f3037918f03c29c0465&amp;amp;chksm=cd6d0bbffa1a82a978ccc0405afa295bd9265bd9f89f2217c80f48e1c497b25d1f24090108af&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0410RTk3PKkxlFlLbCVlOKMK#rd&#34;&gt;Kubernetes部署微服务速成指南——&lt;em&gt;2017-03-09&lt;/em&gt; &lt;em&gt;徐薛彪&lt;/em&gt; 容器时代微信公众号&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面那篇文章是翻译的，英文原文地址：&lt;a href=&#34;http://www.eclipse.org/community/eclipse_newsletter/2017/january/article2.php&#34;&gt;Quick Guide to Developing Microservices on Kubernetes and Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://fabric8.io/&#34;&gt;fabric8官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://fabric8.io/guide/getStarted/gofabric8.html&#34;&gt;fabric8 get started&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;&lt;del&gt;我在自己笔记本上装了个minikube，试玩感受将在后续发表。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;试玩时需要科学上网。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$gofabric8 start
using the executable /usr/local/bin/minikube
minikube already running
using the executable /usr/local/bin/kubectl
Switched to context &amp;quot;minikube&amp;quot;.
Deploying fabric8 to your Kubernetes installation at https://192.168.99.100:8443 for domain  in namespace default

Loading fabric8 releases from maven repository:https://repo1.maven.org/maven2/
Deploying package: platform version: 2.4.24

Now about to install package https://repo1.maven.org/maven2/io/fabric8/platform/packages/fabric8-platform/2.4.24/fabric8-platform-2.4.24-kubernetes.yml
Processing resource kind: Namespace in namespace default name user-secrets-source-admin
Found namespace on kind Secret of user-secrets-source-adminProcessing resource kind: Secret in namespace user-secrets-source-admin name default-gogs-git
Processing resource kind: Secret in namespace default name jenkins-docker-cfg
Processing resource kind: Secret in namespace default name jenkins-git-ssh
Processing resource kind: Secret in namespace default name jenkins-hub-api-token
Processing resource kind: Secret in namespace default name jenkins-master-ssh
Processing resource kind: Secret in namespace default name jenkins-maven-settings
Processing resource kind: Secret in namespace default name jenkins-release-gpg
Processing resource kind: Secret in namespace default name jenkins-ssh-config
Processing resource kind: ServiceAccount in namespace default name configmapcontroller
Processing resource kind: ServiceAccount in namespace default name exposecontroller
Processing resource kind: ServiceAccount in namespace default name fabric8
Processing resource kind: ServiceAccount in namespace default name gogs
Processing resource kind: ServiceAccount in namespace default name jenkins
Processing resource kind: Service in namespace default name fabric8
Processing resource kind: Service in namespace default name fabric8-docker-registry
Processing resource kind: Service in namespace default name fabric8-forge
Processing resource kind: Service in namespace default name gogs
...
-------------------------

Default GOGS admin username/password = gogsadmin/RedHat$1

Checking if PersistentVolumeClaims bind to a PersistentVolume ....
Downloading images and waiting to open the fabric8 console...

-------------------------
.....................................................
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动了半天一直是这种状态：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Waiting, endpoint for service is not ready yet...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我一看下载下来的&lt;code&gt;https://repo1.maven.org/maven2/io/fabric8/platform/packages/fabric8-platform/2.4.24/fabric8-platform-2.4.24-kubernetes.yml&lt;/code&gt;文件，真是&lt;strong&gt;蔚为壮观&lt;/strong&gt;啊，足足有&lt;strong&gt;24712行&lt;/strong&gt;(这里面都是实际配置，没有配置充行数)，使用了如下这些docker镜像，足足有&lt;strong&gt;53个docker镜像&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fabric8/alpine-caddy:2.2.311
fabric8/apiman-gateway:2.2.168
fabric8/apiman:2.2.168
fabric8/chaos-monkey:2.2.311
fabric8/configmapcontroller:2.3.5
fabric8/eclipse-orion:2.2.311
fabric8/elasticsearch-k8s:2.3.4
fabric8/elasticsearch-logstash-template:2.2.311
fabric8/elasticsearch-v1:2.2.168
fabric8/exposecontroller:2.3.2
fabric8/fabric8-console:2.2.199
fabric8/fabric8-forge:2.3.88
fabric8/fabric8-kiwiirc:2.2.311
fabric8/fluentd-kubernetes:v1.19
fabric8/gerrit:2.2.311
fabric8/git-collector:2.2.311
fabric8/gogs:v0.9.97
fabric8/grafana:2.6.1
fabric8/hubot-irc:2.2.311
fabric8/hubot-letschat:v1.0.0
fabric8/hubot-notifier:2.2.311
fabric8/hubot-slack:2.2.311
fabric8/jenkins-docker:2.2.311
fabric8/jenkinshift:2.2.199
fabric8/kafka:2.2.153
fabric8/kibana-config:2.2.311
fabric8/kibana4:v4.5.3
fabric8/lets-chat:2.2.311
fabric8/maven-builder:2.2.311
fabric8/message-broker:2.2.168
fabric8/message-gateway:2.2.168
fabric8/nexus:2.2.311
fabric8/taiga-back:2.2.311
fabric8/taiga-front:2.2.311
fabric8/turbine-server:1.0.28
fabric8/zookeeper:2.2.153
fabric8/zookeeper:2.2.168
funktion/funktion-nodejs-runtime:1.0.3
funktion/funktion:1.0.9
gitlab/gitlab-ce
jboss/keycloak:2.2.0.Final
jfrog-docker-registry.bintray.io/artifactory/artifactory-oss
jimmidyson/configmap-reload:v0.1
manageiq/manageiq:latest
mongo
mysql:5.7
nginxdemos/nginx-ingress:0.3.1
openzipkin/zipkin:1.13.0
postgres
prom/blackbox-exporter:master
prom/node-exporter
prom/prometheus:v1.3.1
registry:2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你们感受下吧，我果断放弃了在自己笔记本上安装的念头。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes安装之证书验证</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-tls-certificate/</link>
      <pubDate>Mon, 10 Apr 2017 17:28:41 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-tls-certificate/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2014082502.jpg&#34; alt=&#34;颐和园&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：铜牛@颐和园 Aug 25,2014）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;昨晚（Apr 9,2017）金山软件的&lt;a href=&#34;https://github.com/opsnull&#34;&gt;opsnull&lt;/a&gt;发布了一个开源项目&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;打造的kubernetes环境和opsnull的文章&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster/blob/master/01-TLS%E8%AF%81%E4%B9%A6%E5%92%8C%E7%A7%98%E9%92%A5.md&#34;&gt;创建 kubernetes 各组件 TLS 加密通信的证书和秘钥&lt;/a&gt;的实践。之前安装过程中一直使用的是非加密方式，一直到后来&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-fluentd-elasticsearch-installation/&#34;&gt;使用Fluentd和ElasticSearch收集Kubernetes集群日志&lt;/a&gt;时发现有权限验证问题，所以为了深入研究kubernentes。&lt;/p&gt;

&lt;h2 id=&#34;kubernentes中的身份验证&#34;&gt;Kubernentes中的身份验证&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;kubernetes&lt;/code&gt; 系统的各组件需要使用 &lt;code&gt;TLS&lt;/code&gt; 证书对通信进行加密，本文档使用 &lt;code&gt;CloudFlare&lt;/code&gt; 的 PKI 工具集 &lt;a href=&#34;https://github.com/cloudflare/cfssl&#34;&gt;cfssl&lt;/a&gt; 来生成 Certificate Authority (CA) 和其它证书；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;生成的 CA 证书和秘钥文件如下：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ca-key.pem&lt;/li&gt;
&lt;li&gt;ca.pem&lt;/li&gt;
&lt;li&gt;kubernetes-key.pem&lt;/li&gt;
&lt;li&gt;kubernetes.pem&lt;/li&gt;
&lt;li&gt;kube-proxy.pem&lt;/li&gt;
&lt;li&gt;kube-proxy-key.pem&lt;/li&gt;
&lt;li&gt;admin.pem&lt;/li&gt;
&lt;li&gt;admin-key.pem&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;使用证书的组件如下：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;etcd：使用 ca.pem、kubernetes-key.pem、kubernetes.pem；&lt;/li&gt;
&lt;li&gt;kube-apiserver：使用 ca.pem、kubernetes-key.pem、kubernetes.pem；&lt;/li&gt;
&lt;li&gt;kubelet：使用 ca.pem；&lt;/li&gt;
&lt;li&gt;kube-proxy：使用 ca.pem、kube-proxy-key.pem、kube-proxy.pem；&lt;/li&gt;
&lt;li&gt;kubectl：使用 ca.pem、admin-key.pem、admin.pem；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;kube-controller&lt;/code&gt;、&lt;code&gt;kube-scheduler&lt;/code&gt; 当前需要和 &lt;code&gt;kube-apiserver&lt;/code&gt; 部署在同一台机器上且使用非安全端口通信，故不需要证书。&lt;/p&gt;

&lt;h2 id=&#34;安装-cfssl&#34;&gt;安装 &lt;code&gt;CFSSL&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;方式一：直接使用二进制源码包安装&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64
$ chmod +x cfssl_linux-amd64
$ sudo mv cfssl_linux-amd64 /root/local/bin/cfssl

$ wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64
$ chmod +x cfssljson_linux-amd64
$ sudo mv cfssljson_linux-amd64 /root/local/bin/cfssljson

$ wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64
$ chmod +x cfssl-certinfo_linux-amd64
$ sudo mv cfssl-certinfo_linux-amd64 /root/local/bin/cfssl-certinfo

$ export PATH=/root/local/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;方式二：使用go命令安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们的系统中安装了Go1.7.5，使用以下命令安装更快捷：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$go get -u github.com/cloudflare/cfssl/cmd/...
$echo $GOPATH
/usr/local
$ls /usr/local/bin/cfssl*
cfssl cfssl-bundle cfssl-certinfo cfssljson cfssl-newkey cfssl-scan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;$GOPATH/bin&lt;/code&gt;目录下得到以cfssl开头的几个命令。&lt;/p&gt;

&lt;h2 id=&#34;创建-ca-certificate-authority&#34;&gt;创建 CA (Certificate Authority)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;创建 CA 配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir /root/ssl
$ cd /root/ssl
$ cfssl print-defaults config &amp;gt; config.json
$ cfssl print-defaults csr &amp;gt; csr.json
$ cat ca-config.json
{
  &amp;quot;signing&amp;quot;: {
    &amp;quot;default&amp;quot;: {
      &amp;quot;expiry&amp;quot;: &amp;quot;8760h&amp;quot;
    },
    &amp;quot;profiles&amp;quot;: {
      &amp;quot;kubernetes&amp;quot;: {
        &amp;quot;usages&amp;quot;: [
            &amp;quot;signing&amp;quot;,
            &amp;quot;key encipherment&amp;quot;,
            &amp;quot;server auth&amp;quot;,
            &amp;quot;client auth&amp;quot;
        ],
        &amp;quot;expiry&amp;quot;: &amp;quot;8760h&amp;quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字段说明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ca-config.json&lt;/code&gt;：可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;signing&lt;/code&gt;：表示该证书可用于签名其它证书；生成的 ca.pem 证书中 &lt;code&gt;CA=TRUE&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server auth&lt;/code&gt;：表示client可以用该 CA 对server提供的证书进行验证；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client auth&lt;/code&gt;：表示server可以用该CA对client提供的证书进行验证；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;创建 CA 证书签名请求&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat ca-csr.json
{
  &amp;quot;CN&amp;quot;: &amp;quot;kubernetes&amp;quot;,
  &amp;quot;key&amp;quot;: {
    &amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
    &amp;quot;size&amp;quot;: 2048
  },
  &amp;quot;names&amp;quot;: [
    {
      &amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
      &amp;quot;ST&amp;quot;: &amp;quot;BeiJing&amp;quot;,
      &amp;quot;L&amp;quot;: &amp;quot;BeiJing&amp;quot;,
      &amp;quot;O&amp;quot;: &amp;quot;k8s&amp;quot;,
      &amp;quot;OU&amp;quot;: &amp;quot;System&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;CN&amp;rdquo;：&lt;code&gt;Common Name&lt;/code&gt;，kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)；浏览器使用该字段验证网站是否合法；&lt;/li&gt;
&lt;li&gt;&amp;ldquo;O&amp;rdquo;：&lt;code&gt;Organization&lt;/code&gt;，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;生成 CA 证书和私钥&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca
$ ls ca*
ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建-kubernetes-证书&#34;&gt;创建 kubernetes 证书&lt;/h2&gt;

&lt;p&gt;创建 kubernetes 证书签名请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat kubernetes-csr.json
{
    &amp;quot;CN&amp;quot;: &amp;quot;kubernetes&amp;quot;,
    &amp;quot;hosts&amp;quot;: [
      &amp;quot;127.0.0.1&amp;quot;,
      &amp;quot;172.20.0.112&amp;quot;,
      &amp;quot;172.20.0.113&amp;quot;,
      &amp;quot;172.20.0.114&amp;quot;,
      &amp;quot;172.20.0.115&amp;quot;,
      &amp;quot;10.254.0.1&amp;quot;,
      &amp;quot;kubernetes&amp;quot;,
      &amp;quot;kubernetes.default&amp;quot;,
      &amp;quot;kubernetes.default.svc&amp;quot;,
      &amp;quot;kubernetes.default.svc.cluster&amp;quot;,
      &amp;quot;kubernetes.default.svc.cluster.local&amp;quot;
    ],
    &amp;quot;key&amp;quot;: {
        &amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
        &amp;quot;size&amp;quot;: 2048
    },
    &amp;quot;names&amp;quot;: [
        {
            &amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
            &amp;quot;ST&amp;quot;: &amp;quot;BeiJing&amp;quot;,
            &amp;quot;L&amp;quot;: &amp;quot;BeiJing&amp;quot;,
            &amp;quot;O&amp;quot;: &amp;quot;k8s&amp;quot;,
            &amp;quot;OU&amp;quot;: &amp;quot;System&amp;quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果 hosts 字段不为空则需要指定授权使用该证书的 &lt;strong&gt;IP 或域名列表&lt;/strong&gt;，由于该证书后续被 &lt;code&gt;etcd&lt;/code&gt; 集群和 &lt;code&gt;kubernetes master&lt;/code&gt; 集群使用，所以上面分别指定了 &lt;code&gt;etcd&lt;/code&gt; 集群、&lt;code&gt;kubernetes master&lt;/code&gt; 集群的主机 IP 和 &lt;strong&gt;&lt;code&gt;kubernetes&lt;/code&gt; 服务的服务 IP&lt;/strong&gt;（一般是 &lt;code&gt;kue-apiserver&lt;/code&gt; 指定的 &lt;code&gt;service-cluster-ip-range&lt;/code&gt; 网段的第一个IP，如 10.254.0.1。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;生成 kubernetes 证书和私钥&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes
$ ls kuberntes*
kubernetes.csr  kubernetes-csr.json  kubernetes-key.pem  kubernetes.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者直接在命令行上指定相关参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo &#39;{&amp;quot;CN&amp;quot;:&amp;quot;kubernetes&amp;quot;,&amp;quot;hosts&amp;quot;:[&amp;quot;&amp;quot;],&amp;quot;key&amp;quot;:{&amp;quot;algo&amp;quot;:&amp;quot;rsa&amp;quot;,&amp;quot;size&amp;quot;:2048}}&#39; | cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes -hostname=&amp;quot;127.0.0.1,10.64.3.7,10.254.0.1,kubernetes,kubernetes.default&amp;quot; - | cfssljson -bare kubernetes
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建-admin-证书&#34;&gt;创建 admin 证书&lt;/h2&gt;

&lt;p&gt;创建 admin 证书签名请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat admin-csr.json
{
  &amp;quot;CN&amp;quot;: &amp;quot;admin&amp;quot;,
  &amp;quot;hosts&amp;quot;: [],
  &amp;quot;key&amp;quot;: {
    &amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
    &amp;quot;size&amp;quot;: 2048
  },
  &amp;quot;names&amp;quot;: [
    {
      &amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
      &amp;quot;ST&amp;quot;: &amp;quot;BeiJing&amp;quot;,
      &amp;quot;L&amp;quot;: &amp;quot;BeiJing&amp;quot;,
      &amp;quot;O&amp;quot;: &amp;quot;system:masters&amp;quot;,
      &amp;quot;OU&amp;quot;: &amp;quot;System&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;后续 &lt;code&gt;kube-apiserver&lt;/code&gt; 使用 &lt;code&gt;RBAC&lt;/code&gt; 对客户端(如 &lt;code&gt;kubelet&lt;/code&gt;、&lt;code&gt;kube-proxy&lt;/code&gt;、&lt;code&gt;Pod&lt;/code&gt;)请求进行授权；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kube-apiserver&lt;/code&gt; 预定义了一些 &lt;code&gt;RBAC&lt;/code&gt; 使用的 &lt;code&gt;RoleBindings&lt;/code&gt;，如 &lt;code&gt;cluster-admin&lt;/code&gt; 将 Group &lt;code&gt;system:masters&lt;/code&gt; 与 Role &lt;code&gt;cluster-admin&lt;/code&gt; 绑定，该 Role 授予了调用&lt;code&gt;kube-apiserver&lt;/code&gt; 的&lt;strong&gt;所有 API&lt;/strong&gt;的权限；&lt;/li&gt;
&lt;li&gt;OU 指定该证书的 Group 为 &lt;code&gt;system:masters&lt;/code&gt;，&lt;code&gt;kubelet&lt;/code&gt; 使用该证书访问 &lt;code&gt;kube-apiserver&lt;/code&gt; 时 ，由于证书被 CA 签名，所以认证通过，同时由于证书用户组为经过预授权的 &lt;code&gt;system:masters&lt;/code&gt;，所以被授予访问所有 API 的权限；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生成 admin 证书和私钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin
$ ls admin*
admin.csr  admin-csr.json  admin-key.pem  admin.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建-kube-proxy-证书&#34;&gt;创建 kube-proxy 证书&lt;/h2&gt;

&lt;p&gt;创建 kube-proxy 证书签名请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat kube-proxy-csr.json
{
  &amp;quot;CN&amp;quot;: &amp;quot;system:kube-proxy&amp;quot;,
  &amp;quot;hosts&amp;quot;: [],
  &amp;quot;key&amp;quot;: {
    &amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
    &amp;quot;size&amp;quot;: 2048
  },
  &amp;quot;names&amp;quot;: [
    {
      &amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
      &amp;quot;ST&amp;quot;: &amp;quot;BeiJing&amp;quot;,
      &amp;quot;L&amp;quot;: &amp;quot;BeiJing&amp;quot;,
      &amp;quot;O&amp;quot;: &amp;quot;k8s&amp;quot;,
      &amp;quot;OU&amp;quot;: &amp;quot;System&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;CN 指定该证书的 User 为 &lt;code&gt;system:kube-proxy&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kube-apiserver&lt;/code&gt; 预定义的 RoleBinding &lt;code&gt;cluster-admin&lt;/code&gt; 将User &lt;code&gt;system:kube-proxy&lt;/code&gt; 与 Role &lt;code&gt;system:node-proxier&lt;/code&gt; 绑定，该 Role 授予了调用 &lt;code&gt;kube-apiserver&lt;/code&gt; Proxy 相关 API 的权限；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生成 kube-proxy 客户端证书和私钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes  kube-proxy-csr.json | cfssljson -bare kube-proxy
$ ls kube-proxy*
kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;校验证书&#34;&gt;校验证书&lt;/h2&gt;

&lt;p&gt;以 kubernetes 证书为例&lt;/p&gt;

&lt;h3 id=&#34;使用-opsnssl-命令&#34;&gt;使用 &lt;code&gt;opsnssl&lt;/code&gt; 命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ openssl x509  -noout -text -in  kubernetes.pem
...
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=CN, ST=BeiJing, L=BeiJing, O=k8s, OU=System, CN=Kubernetes
        Validity
            Not Before: Apr  5 05:36:00 2017 GMT
            Not After : Apr  5 05:36:00 2018 GMT
        Subject: C=CN, ST=BeiJing, L=BeiJing, O=k8s, OU=System, CN=kubernetes
...
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            X509v3 Extended Key Usage:
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Subject Key Identifier:
                DD:52:04:43:10:13:A9:29:24:17:3A:0E:D7:14:DB:36:F8:6C:E0:E0
            X509v3 Authority Key Identifier:
                keyid:44:04:3B:60:BD:69:78:14:68:AF:A0:41:13:F6:17:07:13:63:58:CD

            X509v3 Subject Alternative Name:
                DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster, DNS:kubernetes.default.svc.cluster.local, IP Address:127.0.0.1, IP Address:172.20.0.112, IP Address:172.20.0.113, IP Address:172.20.0.114, IP Address:172.20.0.115, IP Address:10.254.0.1
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;确认 &lt;code&gt;Issuer&lt;/code&gt; 字段的内容和 &lt;code&gt;ca-csr.json&lt;/code&gt; 一致；&lt;/li&gt;
&lt;li&gt;确认 &lt;code&gt;Subject&lt;/code&gt; 字段的内容和 &lt;code&gt;kubernetes-csr.json&lt;/code&gt; 一致；&lt;/li&gt;
&lt;li&gt;确认 &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; 字段的内容和 &lt;code&gt;kubernetes-csr.json&lt;/code&gt; 一致；&lt;/li&gt;
&lt;li&gt;确认 &lt;code&gt;X509v3 Key Usage、Extended Key Usage&lt;/code&gt; 字段的内容和 &lt;code&gt;ca-config.json&lt;/code&gt; 中 &lt;code&gt;kubernetes&lt;/code&gt; profile 一致；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用-cfssl-certinfo-命令&#34;&gt;使用 &lt;code&gt;cfssl-certinfo&lt;/code&gt; 命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cfssl-certinfo -cert kubernetes.pem
...
{
  &amp;quot;subject&amp;quot;: {
    &amp;quot;common_name&amp;quot;: &amp;quot;kubernetes&amp;quot;,
    &amp;quot;country&amp;quot;: &amp;quot;CN&amp;quot;,
    &amp;quot;organization&amp;quot;: &amp;quot;k8s&amp;quot;,
    &amp;quot;organizational_unit&amp;quot;: &amp;quot;System&amp;quot;,
    &amp;quot;locality&amp;quot;: &amp;quot;BeiJing&amp;quot;,
    &amp;quot;province&amp;quot;: &amp;quot;BeiJing&amp;quot;,
    &amp;quot;names&amp;quot;: [
      &amp;quot;CN&amp;quot;,
      &amp;quot;BeiJing&amp;quot;,
      &amp;quot;BeiJing&amp;quot;,
      &amp;quot;k8s&amp;quot;,
      &amp;quot;System&amp;quot;,
      &amp;quot;kubernetes&amp;quot;
    ]
  },
  &amp;quot;issuer&amp;quot;: {
    &amp;quot;common_name&amp;quot;: &amp;quot;Kubernetes&amp;quot;,
    &amp;quot;country&amp;quot;: &amp;quot;CN&amp;quot;,
    &amp;quot;organization&amp;quot;: &amp;quot;k8s&amp;quot;,
    &amp;quot;organizational_unit&amp;quot;: &amp;quot;System&amp;quot;,
    &amp;quot;locality&amp;quot;: &amp;quot;BeiJing&amp;quot;,
    &amp;quot;province&amp;quot;: &amp;quot;BeiJing&amp;quot;,
    &amp;quot;names&amp;quot;: [
      &amp;quot;CN&amp;quot;,
      &amp;quot;BeiJing&amp;quot;,
      &amp;quot;BeiJing&amp;quot;,
      &amp;quot;k8s&amp;quot;,
      &amp;quot;System&amp;quot;,
      &amp;quot;Kubernetes&amp;quot;
    ]
  },
  &amp;quot;serial_number&amp;quot;: &amp;quot;174360492872423263473151971632292895707129022309&amp;quot;,
  &amp;quot;sans&amp;quot;: [
    &amp;quot;kubernetes&amp;quot;,
    &amp;quot;kubernetes.default&amp;quot;,
    &amp;quot;kubernetes.default.svc&amp;quot;,
    &amp;quot;kubernetes.default.svc.cluster&amp;quot;,
    &amp;quot;kubernetes.default.svc.cluster.local&amp;quot;,
    &amp;quot;127.0.0.1&amp;quot;,
    &amp;quot;10.64.3.7&amp;quot;,
    &amp;quot;10.254.0.1&amp;quot;
  ],
  &amp;quot;not_before&amp;quot;: &amp;quot;2017-04-05T05:36:00Z&amp;quot;,
  &amp;quot;not_after&amp;quot;: &amp;quot;2018-04-05T05:36:00Z&amp;quot;,
  &amp;quot;sigalg&amp;quot;: &amp;quot;SHA256WithRSA&amp;quot;,
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;分发证书&#34;&gt;分发证书&lt;/h2&gt;

&lt;p&gt;将生成的证书和秘钥文件（后缀名为&lt;code&gt;.pem&lt;/code&gt;）拷贝到所有机器的 &lt;code&gt;/etc/kubernetes/ssl&lt;/code&gt; 目录下备用；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo mkdir -p /etc/kubernetes/ssl
$ sudo cp *.pem /etc/kubernetes/ssl
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coreos.com/os/docs/latest/generate-self-signed-certificates.html&#34;&gt;Generate self-signed certificates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kelseyhightower/kubernetes-the-hard-way/blob/master/docs/02-certificate-authority.md&#34;&gt;Setting up a Certificate Authority and Creating TLS Certificates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/kaushal/2012/02/17/client-certificates-vs-server-certificates/&#34;&gt;Client Certificates V/s Server Certificates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.jobbole.com/104919/&#34;&gt;数字证书及 CA 的扫盲介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>《云计算技术架构与实践（第二版）》读后感</title>
      <link>http://rootsongjc.github.io/blogs/cloud-computing-architecture-practice/</link>
      <pubDate>Sat, 08 Apr 2017 12:29:36 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/cloud-computing-architecture-practice/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20150406003.jpg&#34; alt=&#34;长江三峡&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：长江三峡大坝@湖北宜昌 Apr 6,2015）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近（2017年3月）友人推荐了一本书，是华为的工程师写的《云计算架构与实践第二版》，正好在网上找到了这本书的pdf，分享给大家，&lt;a href=&#34;http://olz1di9xf.bkt.clouddn.com/docs/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%AC2%E7%89%88.pdf&#34;&gt;点这里下载&lt;/a&gt;，书是文字版的，大小13.04MB，除了章节顺序有点问题外没有其他什么问题。这是该书的第二版，第一版2014年9月出版，第二版2016年9月出版，第二版的编者团队居然有50人之多😓&lt;/p&gt;

&lt;p&gt;第二版分享了华为在云计算核心竞争力构建与价值转换方面的经验与建议，并补充了业界在公有云、私有云、行业云以及电信网络云化商用落地与技术应用方面的成功优秀实践。增加了对Docker容器与微服务敏捷迭代、大数据与数据库云化、行业建模与机器学习算法、混合云与管理自动化编排、云生态建设等方面的介绍。&lt;/p&gt;

&lt;h2 id=&#34;第1章-云计算的商业动力与技术趋势&#34;&gt;第1章 云计算的商业动力与技术趋势&lt;/h2&gt;

&lt;p&gt;​&lt;br /&gt;
​&lt;br /&gt;
​&lt;/p&gt;

&lt;p&gt;​&lt;br /&gt;
​&lt;br /&gt;
​&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Fluentd和ElasticSearch收集Kubernetes集群日志</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-fluentd-elasticsearch-installation/</link>
      <pubDate>Fri, 07 Apr 2017 20:13:24 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-fluentd-elasticsearch-installation/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20160430080.jpg&#34; alt=&#34;古北水镇&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：码头@古北水镇 Apr 30,2016）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-installation-on-centos/&#34;&gt;安装好了Kubernetes集群&lt;/a&gt;、&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-network-config/&#34;&gt;配置好了flannel网络&lt;/a&gt;、&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-dashboard-installation/&#34;&gt;安装了Kubernetes Dashboard&lt;/a&gt;和&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-heapster-installation/&#34;&gt;配置Heapster监控插件&lt;/a&gt;后，还有一项重要的工作，为了调试和故障排查，还需要进行日志收集工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;官方文档&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/cluster-administration/logging/&#34;&gt;Kubernetes Logging and Monitoring Cluster Activity&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/logging-elasticsearch-kibana/&#34;&gt;Logging Using Elasticsearch and Kibana&lt;/a&gt;：不过这篇文章是在GCE上配置的，参考价值不大。&lt;/p&gt;

&lt;h2 id=&#34;容器日志的存在形式&#34;&gt;容器日志的存在形式&lt;/h2&gt;

&lt;p&gt;目前容器日志有两种输出形式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;stdout,stderr标准输出&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这种形式的日志输出我们可以直接使用&lt;code&gt;docker logs&lt;/code&gt;查看日志，kubernetes集群中同样可以使用&lt;code&gt;kubectl logs&lt;/code&gt;类似的形式查看日志。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;日志文件记录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这种日志输出我们无法从以上方法查看日志内容，只能&lt;code&gt;tail&lt;/code&gt;日志文件查看。&lt;/p&gt;

&lt;h2 id=&#34;fluentd介绍&#34;&gt;Fluentd介绍&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fluent/fluentd&#34;&gt;Fluentd&lt;/a&gt;是使用Ruby编写的，通过在后端系统之间提供&lt;strong&gt;统一的日志记录层&lt;/strong&gt;来从后端系统中解耦数据源。
此层允许开发人员和数据分析人员在生成日志时使用多种类型的日志。
统一的日志记录层可以让您和您的组织更好地使用数据，并更快地在您的软件上进行迭代。
也就是说fluentd是一个面向多种数据来源以及面向多种数据出口的日志收集器。另外它附带了日志转发的功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/c4abfe337c0b54b36f81bce78481f8965acbc7a9/687474703a2f2f646f63732e666c75656e74642e6f72672f696d616765732f666c75656e74642d6172636869746563747572652e706e67&#34; alt=&#34;arch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Fluentd收集的&lt;strong&gt;event&lt;/strong&gt;由以下几个方面组成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tag&lt;/strong&gt;：字符串，中间用点隔开，如myapp.access&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time&lt;/strong&gt;：UNIX时间格式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Record&lt;/strong&gt;：JSON格式&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;fluentd特点&#34;&gt;Fluentd特点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;部署简单灵活&lt;/li&gt;
&lt;li&gt;开源&lt;/li&gt;
&lt;li&gt;经过验证的可靠性和性能&lt;/li&gt;
&lt;li&gt;社区支持，插件较多&lt;/li&gt;
&lt;li&gt;使用json格式事件格式&lt;/li&gt;
&lt;li&gt;可拔插的架构设计&lt;/li&gt;
&lt;li&gt;低资源要求&lt;/li&gt;
&lt;li&gt;内置高可靠性&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;查看&lt;code&gt;cluster/addons/fluentd-elasticsearch&lt;/code&gt;插件目录，获取到需要用到的docker镜像名称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$grep -rn &amp;quot;gcr.io&amp;quot; *.yaml
es-controller.yaml:24:      - image: gcr.io/google_containers/elasticsearch:v2.4.1-2
fluentd-es-ds.yaml:26:        image: gcr.io/google_containers/fluentd-elasticsearch:1.22
kibana-controller.yaml:22:        image: gcr.io/google_containers/kibana:v4.6.1-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;需要用到的镜像&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gcr.io/google_containers/kibana:v4.6.1-1&lt;/li&gt;
&lt;li&gt;gcr.io/google_containers/elasticsearch:v2.4.1-2&lt;/li&gt;
&lt;li&gt;gcr.io/google_containers/fluentd-elasticsearch:1.22&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为这些镜像在墙外，所以我特意备份了一份在本地还有时速云上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试环境镜像名称&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sz-pg-oam-docker-hub-001.tendcloud.com/library/elasticsearch:v2.4.1-2&lt;/li&gt;
&lt;li&gt;sz-pg-oam-docker-hub-001.tendcloud.com/library/kibana:v4.6.1-1&lt;/li&gt;
&lt;li&gt;sz-pg-oam-docker-hub-001.tendcloud.com/library/fluentd-elasticsearch:1.22&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;备份到时速云上的镜像名称&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;index.tenxcloud.com/jimmy/elasticsearch:v2.4.1-2&lt;/li&gt;
&lt;li&gt;index.tenxcloud.com/jimmy/kibana:v4.6.1-1&lt;/li&gt;
&lt;li&gt;index.tenxcloud.com/jimmy/fluentd-elasticsearch:1.22&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;修改上面的那三个yaml文件，将其中的镜像名称改成我们测试环境中的。&lt;/p&gt;

&lt;h3 id=&#34;启动集群&#34;&gt;启动集群&lt;/h3&gt;

&lt;p&gt;使用刚修改好yaml文件的那个目录启动fluentd-elasticsearch。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl create -f flucentd-elasticsearch
$kubectl get -f fluentd-elasticsearch/
NAME                          DESIRED   CURRENT   READY     AGE
rc/elasticsearch-logging-v1   2         2         2         13m

NAME                        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
svc/elasticsearch-logging   10.254.107.114   &amp;lt;none&amp;gt;        9200/TCP   13m

NAME                  DESIRED   CURRENT   READY     UP-TO-DATE   AVAILABLE   NODE-SELECTOR                              AGE
ds/fluentd-es-v1.22   0         0         0         0            0           beta.kubernetes.io/fluentd-ds-ready=true   13m

NAME                    DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deploy/kibana-logging   1         1         1            1           13m

NAME                 CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
svc/kibana-logging   10.254.104.215   &amp;lt;none&amp;gt;        5601/TCP   13m

$kubectl cluster-info
Kubernetes master is running at http://sz-pg-oam-docker-test-001:8080
Elasticsearch is running at http://sz-pg-oam-docker-test-001:8080/api/v1/proxy/namespaces/kube-system/services/elasticsearch-logging
Heapster is running at http://sz-pg-oam-docker-test-001:8080/api/v1/proxy/namespaces/kube-system/services/heapster
Kibana is running at http://sz-pg-oam-docker-test-001:8080/api/v1/proxy/namespaces/kube-system/services/kibana-logging
monitoring-grafana is running at http://sz-pg-oam-docker-test-001:8080/api/v1/proxy/namespaces/kube-system/services/monitoring-grafana
monitoring-influxdb is running at http://sz-pg-oam-docker-test-001:8080/api/v1/proxy/namespaces/kube-system/services/monitoring-influxdb

To further debug and diagnose cluster problems, use &#39;kubectl cluster-info dump&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动完成，但是查看pod的日志后会发现出错了。&lt;/p&gt;

&lt;p&gt;如何保证每个节点启动一个Fluentd呢？答案是使用DaemonSet。&lt;/p&gt;

&lt;h3 id=&#34;排错&#34;&gt;排错&lt;/h3&gt;

&lt;p&gt;查看启动的pod。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl --namespace=kube-system get all
NAME                                       READY     STATUS    RESTARTS   AGE
po/elasticsearch-logging-v1-nshz2          1/1       Running   0          16m
po/elasticsearch-logging-v1-q515j          1/1       Running   0          16m
po/heapster-3669180046-06n3d               1/1       Running   0          23h
po/kibana-logging-4247188994-h8jxx         1/1       Running   0          16m
po/kubernetes-dashboard-1074266307-hsgxx   1/1       Running   0          1d
po/monitoring-grafana-127711743-xl9v1      1/1       Running   0          23h
po/monitoring-influxdb-1411048194-cvxmm    1/1       Running   0          23h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该在个node节点上启动的&lt;strong&gt;fluentd&lt;/strong&gt;没有看到。查看logging pod的日志。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl -n kube-system logs po/elasticsearch-logging-v1-nshz2
F0406 08:30:05.488197       7 elasticsearch_logging_discovery.go:49] Failed to make client: open /var/run/secrets/kubernetes.io/serviceaccount/token: no such file or directory
goroutine 1 [running]:
...
[2017-04-06 08:30:23,450][WARN ][discovery.zen.ping.unicast] [elasticsearch-logging-v1-nshz2] failed to send ping to [{#zen_unicast_1#}{127.0.0.1}{127.0.0.1:9300}]
SendRequestTransportException[[][127.0.0.1:9300][internal:discovery/zen/unicast]]; nested: NodeNotConnectedException[[][127.0.0.1:9300] Node not connected];
	at org.elasticsearch.transport.TransportService.sendRequest(TransportService.java:340)
	at org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing.sendPingRequestToNode(UnicastZenPing.java:440)
	at org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing.sendPings(UnicastZenPing.java:426)
	at org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing.ping(UnicastZenPing.java:240)
	at org.elasticsearch.discovery.zen.ping.ZenPingService.ping(ZenPingService.java:106)
	at org.elasticsearch.discovery.zen.ping.ZenPingService.pingAndWait(ZenPingService.java:84)
	at org.elasticsearch.discovery.zen.ZenDiscovery.findMaster(ZenDiscovery.java:945)
	at org.elasticsearch.discovery.zen.ZenDiscovery.innerJoinCluster(ZenDiscovery.java:360)
	at org.elasticsearch.discovery.zen.ZenDiscovery.access$4400(ZenDiscovery.java:96)
	at org.elasticsearch.discovery.zen.ZenDiscovery$JoinThreadControl$1.run(ZenDiscovery.java:1296)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: NodeNotConnectedException[[][127.0.0.1:9300] Node not connected]
	at org.elasticsearch.transport.netty.NettyTransport.nodeChannel(NettyTransport.java:1141)
	at org.elasticsearch.transport.netty.NettyTransport.sendRequest(NettyTransport.java:830)
	at org.elasticsearch.transport.TransportService.sendRequest(TransportService.java:329)
	... 12 more
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到报错中有这样的描述：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;discovery.zen.ping.unicast failed to send ping to [{#zen_unicast_1#}{127.0.0.1}{127.0.0.1:9300}]
SendRequestTransportException[[internal:discovery/zen/unicast]]; nested: NodeNotConnectedException[ Node not connected]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面有两个错误：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无法访问到API Server&lt;/li&gt;
&lt;li&gt;elasticsearch两个节点间互ping失败&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个是镜像中的配置问题，配置文件在&lt;code&gt;fluentd-es-image/td-agent.conf&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;参考&lt;a href=&#34;http://tonybai.com/2017/03/03/implement-kubernetes-cluster-level-logging-with-fluentd-and-elasticsearch-stack/&#34;&gt;使用Fluentd和ElasticSearch Stack实现Kubernetes的集群Logging&lt;/a&gt;，Tony Bai也遇到了这个问题，我们了解下&lt;a href=&#34;https://kubernetes.io/docs/user-guide/configmap/&#34;&gt;ConfigMap&lt;/a&gt;还有&lt;a href=&#34;https://github.com/fabric8io/fluent-plugin-kubernetes_metadata_filter&#34;&gt;fluent-plugin-kubernetes_metadata_filter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;参考我的另一片译文&lt;a href=&#34;rootsongjc.github.io/blogs/kubernetes-configmap-introduction&#34;&gt;Kubernetes中ConfigMap解析&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;问题排查&#34;&gt;问题排查&lt;/h2&gt;

&lt;p&gt;前面写的是直接使用&lt;code&gt;kubectl create -f flucentd-elasticsearch&lt;/code&gt;命令启动整个fluentd+elasticsearch集群，这样启动看似很简单，但是对于问题排查的时候不便于我们分析出错原因，因为你根本不知道服务之间的依赖关系和启动顺序，所以现在我们依次启动每个服务，看看背后都做了什么。&lt;/p&gt;

&lt;h3 id=&#34;启动fluentd&#34;&gt;启动fluentd&lt;/h3&gt;

&lt;p&gt;首先启动fluentd收集日志的服务，从&lt;code&gt;fluentd-es-ds.yaml&lt;/code&gt;的配置中可以看到fluentd是以&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/&#34;&gt;DaemonSet&lt;/a&gt;方式来运行的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DaemonSet简介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DaemonSet能够让所有（或者一些特定）的Node节点运行同一个pod。当节点加入到kubernetes集群中，pod会被（DaemonSet）调度到该节点上运行，当节点从kubernetes集群中被移除，被（DaemonSet）调度的pod会被移除，如果删除DaemonSet，所有跟这个DaemonSet相关的pods都会被删除。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.dockerinfo.net/1139.html&#34;&gt;DaemonSet详细介绍&lt;/a&gt;，这是官方文档的中文翻译，其中还有示例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启动fluentd&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl create -f fluentd-es-ds.yaml
daemonset &amp;quot;fluentd-es-v1.22&amp;quot; created
$kubectl get -f fluentd-es-ds.yaml 
NAME               DESIRED   CURRENT   READY     UP-TO-DATE   AVAILABLE   NODE-SELECTOR                              AGE
fluentd-es-v1.22   0         0         0         0            0           beta.kubernetes.io/fluentd-ds-ready=true   2m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在没有修改&lt;code&gt;fluentd-es-ds.yaml&lt;/code&gt;的情况下直接启动fluentd，实际上一个Pod也没有启动起来，这是为什么呢？因为&lt;strong&gt;NODE-SELECTOR&lt;/strong&gt;选择的label是&lt;code&gt;beta.kubernetes.io/fluentd-ds-ready=true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们再来看下&lt;strong&gt;node&lt;/strong&gt;的&lt;strong&gt;label&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl describe node sz-pg-oam-docker-test-001.tendcloud.com
Name:			sz-pg-oam-docker-test-001.tendcloud.com
Role:			
Labels:			beta.kubernetes.io/arch=amd64
			beta.kubernetes.io/os=linux
			kubernetes.io/hostname=sz-pg-oam-docker-test-001.tendcloud.com
Annotations:		node.alpha.kubernetes.io/ttl=0
			volumes.kubernetes.io/controller-managed-attach-detach=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们没有给node设置&lt;code&gt;beta.kubernetes.io/fluentd-ds-ready=true&lt;/code&gt;的label，所以DaemonSet没有调度上去。&lt;/p&gt;

&lt;p&gt;我们需要手动给kubernetes集群的三个node添加label。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl label node sz-pg-oam-docker-test-001.tendcloud.com beta.kubernetes.io/fluentd-ds-ready=true
node &amp;quot;sz-pg-oam-docker-test-001.tendcloud.com&amp;quot; labeled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给另外两个node执行同样的操作。&lt;/p&gt;

&lt;p&gt;现在再查看下DaemonSet的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl get -f fluentd-es-ds.yaml 
NAME               DESIRED   CURRENT   READY     UP-TO-DATE   AVAILABLE   NODE-SELECTOR                              AGE
fluentd-es-v1.22   3         3         0         3            0           beta.kubernetes.io/fluentd-ds-ready=true   31m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以看到三个DeamonSet都启动起来了。&lt;/p&gt;

&lt;p&gt;查看下fluentd的日志&lt;code&gt;/var/log/fluentd.log&lt;/code&gt;，日志是mount到本地的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2017-04-07 03:53:42 +0000 [info]: adding match pattern=&amp;quot;fluent.**&amp;quot; type=&amp;quot;null&amp;quot;
2017-04-07 03:53:42 +0000 [info]: adding filter pattern=&amp;quot;kubernetes.**&amp;quot; type=&amp;quot;kubernetes_metadata&amp;quot;
2017-04-07 03:53:42 +0000 [error]: config error file=&amp;quot;/etc/td-agent/td-agent.conf&amp;quot; error=&amp;quot;Invalid Kubernetes API v1 endpoint https://10.254.0.1:443/api: SSL_connect returned=1 errno=0 state=error: certificate verify failed&amp;quot;
2017-04-07 03:53:42 +0000 [info]: process finished code=256
2017-04-07 03:53:42 +0000 [warn]: process died within 1 second. exit.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从日志的最后几行中可以看到，&lt;code&gt;Invalid Kubernetes API v1 endpoint https://10.254.0.1:443/api: SSL_connect returned=1 errno=0 state=error: certificate verify failed&lt;/code&gt;这样的错误，这些需要在&lt;code&gt;/etc/td-agent/td-agent.conf&lt;/code&gt;文件中配置的。&lt;/p&gt;

&lt;p&gt;但是这些配置已经在创建&lt;code&gt;gcr.io/google_containers/fluentd-elasticsearch:1.22&lt;/code&gt;镜像（该镜像是运行带有elasticsearch插件的fluentd的）的时候就已经copy进去了，从&lt;code&gt;fluentd-elasticsearch/fluentd-es-image/Dockerfile&lt;/code&gt;文件中就可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Copy the Fluentd configuration file.
COPY td-agent.conf /etc/td-agent/td-agent.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-configmap-introduction/&#34;&gt;ConfigMap&lt;/a&gt;，不用重新再build镜像，通过文件挂载的形式替换镜像中已有的td-agent.conf文件。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;tonybai.com&#34;&gt;Tony Bai&lt;/a&gt;给出的两点建议：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在基于td-agent.conf创建configmap资源之前，需要将td-agent.conf中的注释行都删掉，否则生成的configmap的内容可能不正确；&lt;/li&gt;
&lt;li&gt;fluentd pod将创建在kube-system下，因此ConfigMap资源也需要创建在kube-system namespace下面，否则kubectl create无法找到对应的ConfigMap。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在td-agent.conf的配置文件的&lt;filter kubernetes.**&gt;中增加两条配置配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;filter kubernetes.**&amp;gt;
  type kubernetes_metadata
  kubernetes_url sz-pg-oam-docker-test-001.tendcloud.com:8080
  verify_ssl false
&amp;lt;/filter&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;创建ConfigMap&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl create configmap td-agent-config --from-file=fluentd-elasticsearch/fluentd-es-image/td-agent.conf -n kube-system
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看刚创建的ConfigMap&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl -n kube-system get configmaps td-agent-config -o yaml
apiVersion: v1
data:
  td-agent.conf: |
    &amp;lt;match fluent.**&amp;gt;
      type null
    &amp;lt;/match&amp;gt;
...
&amp;lt;filter kubernetes.**&amp;gt;
  type kubernetes_metadata
  kubernetes_url http://sz-pg-oam-docker-test-001.tendcloud.com:8080
  verify_ssl false
&amp;lt;/filter&amp;gt;
...

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;⚠️ kubernetes_url地址要加上&lt;strong&gt;http&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;修改&lt;code&gt;fluentd-es-ds.yaml&lt;/code&gt;文件，在其中增加&lt;code&gt;td-agent.conf&lt;/code&gt;文件的volume。&lt;/p&gt;

&lt;p&gt;该文件的部分内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: DaemonSet
metadata:
...
    spec:
     ...
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
        - name: td-agent-config
          mountPath: /etc/td-agent
...
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
      - name: td-agent-config
        configMap:
          name: td-agent-config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动日志收集服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl create -f ./fluentd-elasticsearch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在再查看&lt;code&gt;/var/log/fluentd.log&lt;/code&gt;日志里面就没有错误了。&lt;/p&gt;

&lt;p&gt;查看下elasticsearch pod日志，发现里面还有错误，跟以前的一样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[2017-04-07 10:54:57,858][WARN ][discovery.zen.ping.unicast] [elasticsearch-logging-v1-wxd5f] failed to send ping to [{#zen_unicast_1#}{127.0.0.1}{127.0.0.1:9300}]
SendRequestTransportException[[][127.0.0.1:9300][internal:discovery/zen/unicast]]; nested: NodeNotConnectedException[[][127.0.0.1:9300] Node not connected];
	at org.elasticsearch.transport.TransportService.sendRequest(TransportService.java:340)
	at org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing.sendPingRequestToNode(UnicastZenPing.java:440)
	at org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing.sendPings(UnicastZenPing.java:426)
	at org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing.ping(UnicastZenPing.java:240)
	at org.elasticsearch.discovery.zen.ping.ZenPingService.ping(ZenPingService.java:106)
	at org.elasticsearch.discovery.zen.ping.ZenPingService.pingAndWait(ZenPingService.java:84)
	at org.elasticsearch.discovery.zen.ZenDiscovery.findMaster(ZenDiscovery.java:945)
	at org.elasticsearch.discovery.zen.ZenDiscovery.innerJoinCluster(ZenDiscovery.java:360)
	at org.elasticsearch.discovery.zen.ZenDiscovery.access$4400(ZenDiscovery.java:96)
	at org.elasticsearch.discovery.zen.ZenDiscovery$JoinThreadControl$1.run(ZenDiscovery.java:1296)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: NodeNotConnectedException[[][127.0.0.1:9300] Node not connected]
	at org.elasticsearch.transport.netty.NettyTransport.nodeChannel(NettyTransport.java:1141)
	at org.elasticsearch.transport.netty.NettyTransport.sendRequest(NettyTransport.java:830)
	at org.elasticsearch.transport.TransportService.sendRequest(TransportService.java:329)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看下elasticsearch:v2.4.1-2镜像的代码，在&lt;code&gt;fluentd-elasticsearch/es-image&lt;/code&gt;目录下，该目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config
Dockerfile
elasticsearch_logging_discovery.go
Makefile
run.sh
template-k8s-logstash.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从&lt;strong&gt;Dockerfile&lt;/strong&gt;中可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;RUN mkdir -p /elasticsearch/config/templates
COPY template-k8s-logstash.json /elasticsearch/config/templates/template-k8s-logstash.json

COPY config /elasticsearch/config

COPY run.sh /
COPY elasticsearch_logging_discovery /

RUN useradd --no-create-home --user-group elasticsearch \
    &amp;amp;&amp;amp; mkdir /data \
    &amp;amp;&amp;amp; chown -R elasticsearch:elasticsearch /elasticsearch

VOLUME [&amp;quot;/data&amp;quot;]
EXPOSE 9200 9300

CMD [&amp;quot;/run.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将本地的&lt;code&gt;config&lt;/code&gt;目录作为配置文件拷贝到了镜像里，&lt;code&gt;run.sh&lt;/code&gt;启动脚本中有三行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/elasticsearch_logging_discovery &amp;gt;&amp;gt; /elasticsearch/config/elasticsearch.yml

chown -R elasticsearch:elasticsearch /data

exec gosu elasticsearch /elasticsearch/bin/elasticsearch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再进入到镜像里查看下&lt;code&gt;/elasticsearch/config/elasticsearch.yml&lt;/code&gt;文件的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cluster.name: kubernetes-logging

node.name: ${NODE_NAME}
node.master: ${NODE_MASTER}
node.data: ${NODE_DATA}

transport.tcp.port: ${TRANSPORT_PORT}
http.port: ${HTTP_PORT}

path.data: /data

network.host: 0.0.0.0

discovery.zen.minimum_master_nodes: ${MINIMUM_MASTER_NODES}
discovery.zen.ping.multicast.enabled: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;记录几个问题&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kubernetes中的DNS没有配置。&lt;/li&gt;
&lt;li&gt;ElasticSearch的配置有问题。&lt;/li&gt;
&lt;li&gt;是否要用ServiceAccount？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tonybai.com/2017/03/03/implement-kubernetes-cluster-level-logging-with-fluentd-and-elasticsearch-stack/&#34;&gt;使用Fluentd和ElasticSearch Stack实现Kubernetes的集群Logging&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://my.oschina.net/newlife111/blog/714574&#34;&gt;在Kubernetes上搭建EFK（Fluentd＋Elasticsearch＋Kibana）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/muzhiye/p/elasticsearch_set_cluster.html&#34;&gt;elasticsearch2.2 集群搭建各种坑&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/fluentd-elasticsearch/es-image/elasticsearch_logging_discovery.go&#34;&gt;elasticsearch_logging_discovery.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fabric8io/fluent-plugin-kubernetes_metadata_filter&#34;&gt;fluent-plugin-kubernetes_metadata_filter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;To be continued…&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes的ConfigMap解析</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-configmap-introduction/</link>
      <pubDate>Thu, 06 Apr 2017 21:24:20 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-configmap-introduction/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20160430004.jpg&#34; alt=&#34;古北水镇&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：龙形灯笼@古北水镇 Apr 30,2016）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;为什么要翻译这篇文章，是因为我在&lt;a href=&#34;rootsongjc.github.io/blogs/kubernetes-fluentd-elasticsearch-installation&#34;&gt;使用Fluentd和ElasticSearch收集Kubernetes集群日志&lt;/a&gt;的时候遇到了需要修改镜像中配置的问题，&lt;a href=&#34;https://github.com/fabric8io/fluent-plugin-kubernetes_metadata_filter&#34;&gt;fluent-plugin-kubernetes_metadata&lt;/a&gt;里的需要的&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/fluentd-elasticsearch/fluentd-es-image/td-agent.conf&#34;&gt;td-agent.conf&lt;/a&gt;文件。&lt;/p&gt;

&lt;p&gt;其实ConfigMap功能在Kubernetes1.2版本的时候就有了，许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。这些配置信息需要与docker image解耦，你总不能每修改一个配置就重做一个image吧？ConfigMap API给我们提供了向容器中注入配置信息的机制，ConfigMap可以被用来保存单个属性，也可以用来保存整个配置文件或者JSON二进制大对象。&lt;/p&gt;

&lt;h2 id=&#34;configmap概览&#34;&gt;ConfigMap概览&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;ConfigMap API&lt;/strong&gt;资源用来保存&lt;strong&gt;key-value pair&lt;/strong&gt;配置数据，这个数据可以在&lt;strong&gt;pods&lt;/strong&gt;里使用，或者被用来为像&lt;strong&gt;controller&lt;/strong&gt;一样的系统组件存储配置数据。虽然ConfigMap跟&lt;a href=&#34;https://kubernetes.io/docs/user-guide/secrets/&#34;&gt;Secrets&lt;/a&gt;类似，但是ConfigMap更方便的处理不含敏感信息的字符串。
注意：&lt;u&gt;ConfigMaps不是属性配置文件的替代品。&lt;/u&gt;ConfigMaps只是作为多个properties文件的引用。你可以把它理解为Linux系统中的&lt;code&gt;/etc&lt;/code&gt;目录，专门用来存储配置文件的目录。下面举个例子，使用ConfigMap配置来创建Kuberntes Volumes，ConfigMap中的每个data项都会成为一个新文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;kind: ConfigMap
apiVersion: v1
metadata:
  creationTimestamp: 2016-02-18T19:14:38Z
  name: example-config
  namespace: default
data:
  example.property.1: hello
  example.property.2: world
  example.property.file: |-
    property.1=value-1
    property.2=value-2
    property.3=value-3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;data&lt;/code&gt;一栏包括了配置数据，ConfigMap可以被用来保存单个属性，也可以用来保存一个配置文件。
配置数据可以通过很多种方式在Pods里被使用。ConfigMaps可以被用来：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;设置环境变量的值&lt;/li&gt;
&lt;li&gt;在容器里设置命令行参数&lt;/li&gt;
&lt;li&gt;在数据卷里面创建config文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用户和系统组件两者都可以在ConfigMap里面存储配置数据。&lt;/p&gt;

&lt;p&gt;其实不用看下面的文章，直接从&lt;code&gt;kubectl create configmap -h&lt;/code&gt;的帮助信息中就可以对ConfigMap究竟如何创建略知一二了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Examples:
  # Create a new configmap named my-config based on folder bar
  kubectl create configmap my-config --from-file=path/to/bar
  
  # Create a new configmap named my-config with specified keys instead of file basenames on disk
  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt
  
  # Create a new configmap named my-config with key1=config1 and key2=config2
  kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建configmaps&#34;&gt;创建ConfigMaps&lt;/h2&gt;

&lt;p&gt;可以使用该命令，用给定值、文件或目录来创建ConfigMap。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl create configmap
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用目录创建&#34;&gt;使用目录创建&lt;/h3&gt;

&lt;p&gt;比如我们已经有个了包含一些配置文件，其中包含了我们想要设置的ConfigMap的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls docs/user-guide/configmap/kubectl/
game.properties
ui.properties

$ cat docs/user-guide/configmap/kubectl/game.properties
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30

$ cat docs/user-guide/configmap/kubectl/ui.properties
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面的命令可以创建一个包含目录中所有文件的ConfigMap。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create configmap game-config --from-file=docs/user-guide/configmap/kubectl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;—from-file&lt;/code&gt;指定在目录下的所有文件都会被用在ConfigMap里面创建一个键值对，键的名字就是文件名，值就是文件的内容。&lt;/p&gt;

&lt;p&gt;让我们来看一下这个命令创建的ConfigMap：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl describe configmaps game-config
Name:           game-config
Namespace:      default
Labels:         &amp;lt;none&amp;gt;
Annotations:    &amp;lt;none&amp;gt;

Data
====
game.properties:        158 bytes
ui.properties:          83 bytes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到那两个key是从kubectl指定的目录中的文件名。这些key的内容可能会很大，所以在kubectl describe的输出中，只能够看到键的名字和他们的大小。
如果想要看到键的值的话，可以使用&lt;code&gt;kubectl get&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get configmaps game-config -o yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们以&lt;code&gt;yaml&lt;/code&gt;格式输出配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
data:
  game.properties: |
    enemies=aliens
    lives=3
    enemies.cheat=true
    enemies.cheat.level=noGoodRotten
    secret.code.passphrase=UUDDLRLRBABAS
    secret.code.allowed=true
    secret.code.lives=30
  ui.properties: |
    color.good=purple
    color.bad=yellow
    allow.textmode=true
    how.nice.to.look=fairlyNice
kind: ConfigMap
metadata:
  creationTimestamp: 2016-02-18T18:34:05Z
  name: game-config
  namespace: default
  resourceVersion: &amp;quot;407&amp;quot;
  selfLink: /api/v1/namespaces/default/configmaps/game-config
  uid: 30944725-d66e-11e5-8cd0-68f728db1985
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用文件创建&#34;&gt;使用文件创建&lt;/h3&gt;

&lt;p&gt;刚才&lt;strong&gt;使用目录创建&lt;/strong&gt;的时候我们&lt;code&gt;—from-file&lt;/code&gt;指定的是一个目录，只要指定为一个文件就可以从单个文件中创建ConfigMap。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create configmap game-config-2 --from-file=docs/user-guide/configmap/kubectl/game.properties 

$ kubectl get configmaps game-config-2 -o yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: v1
data:
  game-special-key: |
    enemies=aliens
    lives=3
    enemies.cheat=true
    enemies.cheat.level=noGoodRotten
    secret.code.passphrase=UUDDLRLRBABAS
    secret.code.allowed=true
    secret.code.lives=30
kind: ConfigMap
metadata:
  creationTimestamp: 2016-02-18T18:54:22Z
  name: game-config-3
  namespace: default
  resourceVersion: &amp;quot;530&amp;quot;
  selfLink: /api/v1/namespaces/default/configmaps/game-config-3
  uid: 05f8da22-d671-11e5-8cd0-68f728db1985
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;—from-file&lt;/code&gt;这个参数可以使用多次，你可以使用两次分别指定上个实例中的那两个配置文件，效果就跟指定整个目录是一样的。&lt;/p&gt;

&lt;h3 id=&#34;使用literal值创建&#34;&gt;使用literal值创建&lt;/h3&gt;

&lt;p&gt;使用文字值创建，利用&lt;code&gt;—from-literal&lt;/code&gt;参数传递配置信息，该参数可以使用多次，格式如下；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charm

$ kubectl get configmaps special-config -o yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
data:
  special.how: very
  special.type: charm
kind: ConfigMap
metadata:
  creationTimestamp: 2016-02-18T19:14:38Z
  name: special-config
  namespace: default
  resourceVersion: &amp;quot;651&amp;quot;
  selfLink: /api/v1/namespaces/default/configmaps/special-config
  uid: dadce046-d673-11e5-8cd0-68f728db1985
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pod中使用configmap&#34;&gt;Pod中使用ConfigMap&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;使用ConfigMap来替代环境变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ConfigMap可以被用来填入环境变量。看下下面的ConfigMap。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
  special.type: charm
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: env-config
  namespace: default
data:
  log_level: INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以在Pod中这样使用ConfigMap：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox
      command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;env&amp;quot; ]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how
        - name: SPECIAL_TYPE_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.type
      envFrom:
        - configMapRef:
            name: env-config
  restartPolicy: Never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个Pod运行后会输出如下几行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;SPECIAL_LEVEL_KEY=very
SPECIAL_TYPE_KEY=charm
log_level=INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;用ConfigMap设置命令行参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ConfigMap也可以被使用来设置容器中的命令或者参数值。它使用的是Kubernetes的$(VAR_NAME)替换语法。我们看下下面这个ConfigMap。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
  special.type: charm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了将ConfigMap中的值注入到命令行的参数里面，我们还要像前面那个例子一样使用环境变量替换语法&lt;code&gt;${VAR_NAME)&lt;/code&gt;。（其实这个东西就是给Docker容器设置环境变量，以前我创建镜像的时候经常这么玩，通过docker run的时候指定-e参数修改镜像里的环境变量，然后docker的CMD命令再利用该$(VAR_NAME)通过sed来来修改配置文件或者作为命令行启动参数。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox
      command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&amp;quot; ]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how
        - name: SPECIAL_TYPE_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.type
  restartPolicy: Never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这个Pod后会输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;very charm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;通过数据卷插件使用ConfigMap&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ConfigMap也可以在数据卷里面被使用。还是这个ConfigMap。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
  special.type: charm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在数据卷里面使用这个ConfigMap，有不同的选项。最基本的就是将文件填入数据卷，在这个文件中，键就是文件名，键值就是文件内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox
      command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;cat /etc/config/special.how&amp;quot; ]
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap:
        name: special-config
  restartPolicy: Never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这个Pod的输出是&lt;code&gt;very&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们也可以在ConfigMap值被映射的数据卷里控制路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox
      command: [ &amp;quot;/bin/sh&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;cat /etc/config/path/to/special-key&amp;quot; ]
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap:
        name: special-config
        items:
        - key: special.how
          path: path/to/special-key
  restartPolicy: Never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这个Pod后的结果是&lt;code&gt;very&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;还是那句话，如果你了解docker的ENV机制就会明白ConfigMap背后究竟发生了什么，so easy~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TensorFlow深度学习手写数字识别初体验</title>
      <link>http://rootsongjc.github.io/blogs/tensorflow-and-deep-learning-without-a-phd/</link>
      <pubDate>Wed, 05 Apr 2017 21:52:01 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/tensorflow-and-deep-learning-without-a-phd/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/201703085.jpg&#34; alt=&#34;禾雀&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：禾雀 @北京动物园 Apr 3,2017）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;TensorFlow学习曲线是陡峭的，不是所有的IT从业人员都很容易参与的，你需要有一定的数学专业知识，对于对深度学习没有经验的程序员，要想了解这门技术，最快捷的途径是先运行一个示例，我们认识事物都是先从感性、到理性的思辨过程。&lt;/p&gt;

&lt;p&gt;下面我们来跟随&lt;strong&gt;Martin Gorner&lt;/strong&gt;的&lt;a href=&#34;https://codelabs.developers.google.com/codelabs/cloud-tensorflow-mnist/#0&#34;&gt;TensorFlow and Deep Learing Without a PhD&lt;/a&gt;来编写我们的第一个TensorFlow程序——手写数字识别，这篇文章的中文版&lt;a href=&#34;http://www.jiqizhixin.com/article/2458&#34;&gt;没有博士学位如何玩转TensorFlow和深度学习&lt;/a&gt;于2017年3月13日发表在发表在&lt;a href=&#34;www.jiqizhixin.com&#34;&gt;机器之心&lt;/a&gt;上。这篇文章也是根据3月8日-10日的&lt;strong&gt;Google Cloud NEXT&amp;rsquo;17&lt;/strong&gt;大会上Martin Gorner做的讲解整理而成的，&lt;a href=&#34;http://it.sohu.com/20170124/n479480999.shtml&#34;&gt;教程 | 没有博士学位，照样玩转TensorFlow深度学习&lt;/a&gt;这篇文章是对Martin Gorner的简易教程的原文翻译，我们暂时不要求了解TensorFlow背后复杂的理论，我们先跟随这篇简易教程玩一把TensorFlow的手写数字识别。&lt;/p&gt;

&lt;p&gt;如果你想深入了解这本后的原理的话，可以查看哈尔滨工业大学社会计算与信息检索研究中心翻译的&lt;a href=&#34;https://www.gitbook.com/book/hit-scir/neural-networks-and-deep-learning-zh_cn/details&#34;&gt;《神经网络与深度学习》&lt;/a&gt;这本书，该书翻译自&lt;a href=&#34;http://neuralnetworksanddeeplearning.com/&#34;&gt;Neural Networks and Deep Learning&lt;/a&gt;的中文翻译，原文作者 Michael Nielsen，而且这还是一本免费的电子书，该书中系统讲解了&lt;a href=&#34;https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/chap1/c1s0.html&#34;&gt;使用神经网络识别手写数字&lt;/a&gt;背后的原理。该书托管在GitBook上，你可以点击&lt;a href=&#34;http://olz1di9xf.bkt.clouddn.com/neural-networks-and-deep-learning-zh_cn.pdf&#34;&gt;这里&lt;/a&gt;直接下载该书中文版的PDF。&lt;/p&gt;

&lt;h2 id=&#34;准备&#34;&gt;准备&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;下载代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个代码仓库里包含了手写数字识别和下载依赖的训练数据的代码，我们将只用到&lt;code&gt;mnist_1.0_softmax.py&lt;/code&gt;这一个代码文件。整个&lt;code&gt;mnist_1.0_softmax.py&lt;/code&gt;代码并不复杂，不算注释的话只有36行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/martin-gorner/tensorflow-mnist-tutorial.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载完后，可以看到有一个&lt;strong&gt;INSTALL.txt&lt;/strong&gt;，这篇文章是运行代码所必需的环境要求说明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装TensorFlow&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我之前写过详细的TensorFlow安装教程&lt;a href=&#34;http://rootsongjc.github.io/blogs/tensorflow-practice-02/&#34;&gt;TensorFlow实战（才云郑泽宇著）读书笔记——第二章TensorFlow环境搭建&lt;/a&gt;，这篇文章中主要讲怎样在docker里安装TensorFlow。&lt;/p&gt;

&lt;p&gt;我使用的Mac而且还是python2.7，所以我这样安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install --upgrade tensorflow --user -U
pip install --upgrade matplotlib --user -U
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;运行示例&#34;&gt;运行示例&lt;/h2&gt;

&lt;p&gt;运行手写数字训练示例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python mnist_1.0_softmax.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行过程中你会看到一大段输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Collecting matplotlib
  Downloading matplotlib-2.0.0-cp27-cp27m-macosx_10_6_intel.macosx_10_9_intel.macosx_10_9_x86_64.macosx_10_10_intel.macosx_10_10_x86_64.whl (12.8MB)
    100% |████████████████████████████████| 12.8MB 26kB/s 
Requirement already up-to-date: pyparsing!=2.0.0,!=2.0.4,!=2.1.2,!=2.1.6,&amp;gt;=1.5.6 in /Users/jimmy/Library/Python/2.7/lib/python/site-packages (from matplotlib)
Requirement already up-to-date: numpy&amp;gt;=1.7.1 in /Users/jimmy/Library/Python/2.7/lib/python/site-packages (from matplotlib)
Collecting functools32 (from matplotlib)
  Downloading functools32-3.2.3-2.zip
Collecting pytz (from matplotlib)
  Downloading pytz-2017.2-py2.py3-none-any.whl (484kB)
    100% |████████████████████████████████| 491kB 33kB/s 
Requirement already up-to-date: six&amp;gt;=1.10 in /Users/jimmy/Library/Python/2.7/lib/python/site-packages (from matplotlib)
Collecting cycler&amp;gt;=0.10 (from matplotlib)
  Downloading cycler-0.10.0-py2.py3-none-any.whl
Collecting subprocess32 (from matplotlib)
  Downloading subprocess32-3.2.7.tar.gz (54kB)
    100% |████████████████████████████████| 61kB 26kB/s 
Collecting python-dateutil (from matplotlib)
  Downloading python_dateutil-2.6.0-py2.py3-none-any.whl (194kB)
    100% |████████████████████████████████| 194kB 45kB/s 
Building wheels for collected packages: functools32, subprocess32
  Running setup.py bdist_wheel for functools32 ... done
  Stored in directory: /Users/jimmy/Library/Caches/pip/wheels/3c/d0/09/cd78d0ff4d6cfecfbd730782a7815a4571cd2cd4d2ed6e69d9
  Running setup.py bdist_wheel for subprocess32 ... done
  Stored in directory: /Users/jimmy/Library/Caches/pip/wheels/7d/4c/a4/ce9ceb463dae01f4b95e670abd9afc8d65a45f38012f8030cc
Successfully built functools32 subprocess32
Installing collected packages: functools32, pytz, cycler, subprocess32, python-dateutil, matplotlib
Successfully installed cycler-0.10.0 functools32-3.2.3.post2 matplotlib-2.0.0 python-dateutil-2.6.0 pytz-2017.2 subprocess32-3.2.7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到这个过程中下载了一些python依赖库如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;matplotlib&lt;/li&gt;
&lt;li&gt;pytz&lt;/li&gt;
&lt;li&gt;subprocess32&lt;/li&gt;
&lt;li&gt;cycler&lt;/li&gt;
&lt;li&gt;python_dateutil&lt;/li&gt;
&lt;li&gt;functools32&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有的依赖都下载完成之后，就会弹出一个窗口，同时后台也会在不断滚动显示训练的阶段，直到2001步，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-01.jpg&#34; alt=&#34;tensorflow-mnist-01&#34; /&gt;&lt;/p&gt;

&lt;p&gt;正规的TensorFlow项目会使用&lt;strong&gt;TensorBoard&lt;/strong&gt;作可视化，我们用&lt;strong&gt;matplotlib&lt;/strong&gt;作为替代。&lt;/p&gt;

&lt;p&gt;至此整个训练过程结束了，但是我们还不明白这个窗口里的6个图分别表示的含义，下面将依次作出解释。&lt;/p&gt;

&lt;h2 id=&#34;窗口中的图片说明&#34;&gt;窗口中的图片说明&lt;/h2&gt;

&lt;p&gt;我们分别来看下MNIST窗口中的6个Panel。&lt;/p&gt;

&lt;h3 id=&#34;training-digits&#34;&gt;Training Digits&lt;/h3&gt;

&lt;p&gt;此&lt;strong&gt;DataSet&lt;/strong&gt;中一共有50000个&lt;u&gt;训练数字&lt;/u&gt;，每次&lt;strong&gt;Iteration&lt;/strong&gt;送入100个数字作为循环，500次迭代后可以将所有数字训练一次，叫做一个&lt;strong&gt;Epoch&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;上图中白色背景的数字表示识别正确的，红色背景的部分表示识别错误的，每个数字左边下标表示应该被识别成的正确结果，数字右边的下标是识别错误的结果。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-panel-01.jpg&#34; alt=&#34;training digits&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;test-digits&#34;&gt;Test Digits&lt;/h3&gt;

&lt;p&gt;此外也不能光有训练数字吧，MNIST数据集中还有10000个测试数字，此处你能看到每个数字对应的大约 1000 种书写形式，其中所有错误识别的数字列在顶部（有红色背景）。左边的刻度会给你一个粗略的分辨率精确度（正确识别的百分比）。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-panel-02.jpg&#34; alt=&#34;test digits&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到经过2000轮的训练后，已经对手写数字的识别率达到了92%。&lt;/p&gt;

&lt;h3 id=&#34;cross-entropy-loss&#34;&gt;Cross Entropy Loss&lt;/h3&gt;

&lt;p&gt;为了驱动训练，我们来定义&lt;strong&gt;损失函数&lt;/strong&gt;，即&lt;u&gt;一个展示出系统数字识别能力有多糟的值&lt;/u&gt;，并且系统会尽力将其最小化。损失函数（loss function，此处为&lt;a href=&#34;https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/chap3/c3s1.html&#34;&gt;交叉熵&lt;/a&gt;）的选择稍后会做出解释。你会看到，随着训练的进行，训练和测试数据的损失会减少，而这个现象是好的，意味着神经网络正在学习。X 轴表示了学习过程中的迭代。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-panel-03.jpg&#34; alt=&#34;cross entropy loss&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;accuracy&#34;&gt;Accuracy&lt;/h3&gt;

&lt;p&gt;这个准确度只是正确识别的数字的百分比，是在训练和测试集上计算出的。如果训练顺利，它便会上升。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-panel-04.jpg&#34; alt=&#34;accuratcy&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;weight-biases&#34;&gt;Weight &amp;amp; Biases&lt;/h3&gt;

&lt;p&gt;最后的两幅图表说明了内部变量所取的所有值的扩展，即随训练进行而变化的权重和偏置。比如偏置从 0 开始，且最终得到的值大致均匀地分布在-1.5 和 1.5 之间。如果系统不能很好地收敛，那么这些图可能有用。倘若你发现权重和偏差扩展到上百或上千，那么就可能有问题了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-panel-05.jpg&#34; alt=&#34;weight&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-panel-06.jpg&#34; alt=&#34;biases&#34; /&gt;&lt;/p&gt;

&lt;p&gt;剩下的部分就是理论讲解了，先复制过来，期待有朝一日我能看懂吧😄&lt;/p&gt;

&lt;h3 id=&#34;理论-单层神经网络&#34;&gt;理论 : 单层神经网络&lt;/h3&gt;

&lt;p&gt;MNIST 数据集中，手写数字是 28x28 像素的灰度图像。将它们进行分类的最简单的方法就是使用 28x28=784 个像素作为单层神经网络的输入。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/5070df2db57143eabd8549e038c95735_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;神经网络中的每个「神经元」对其所有的输入进行加权求和，并添加一个被称为「偏置（bias）」的常数，然后通过一些非线性激活函数来反馈结果。&lt;/p&gt;

&lt;p&gt;为了将数字分为 10 类（0 到 9），我们设计了一个具有 10 个输出神经元的单层神经网络。对于分类问题，softmax 是一个不错的激活函数。通过取每个元素的指数，然后归一化向量（使用任意的范数（norm），比如向量的普通欧几里得距离）从而将 softmax 应用于向量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/7648d231901a468a99cb9a849e8630a5_th.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那么为什么「softmax」会被称为 softmax 呢？指数是一种骤增的函数。这将加大向量中每个元素的差异。它也会迅速地产生一个巨大的值。然后，当进行向量的标准化时，支配范数（norm）的最大的元素将会被标准化为一个接近 1 的数字，其他的元素将会被一个较大的值分割并被标准化为一个接近 0 的数字。所得到的向量清楚地显示出了哪个是其最大的值，即「max」，但是却又保留了其值的原始的相对排列顺序，因此即为「soft」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/c85a5d9f37f045ceb8b7b0b457159782_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们现在将使用矩阵乘法将这个单层的神经元的行为总结进一个简单的公式当中。让我们直接这样做：100 个图像的「mini-batch」作为输入，产生 100 个预测（10 元素向量）作为输出。&lt;/p&gt;

&lt;p&gt;使用加权矩阵 W 的第一列权重，我们计算第一个图像所有像素的加权和。该和对应于第一神经元。使用第二列权重，我们对第二个神经元进行同样的操作，直到第 10 个神经元。然后，我们可以对剩余的 99 个图像重复操作。如果我们把一个包含 100 个图像的矩阵称为 X，那么我们的 10 个神经元在这 100 张图像上的加权和就是简单的 X.W（矩阵乘法）。&lt;/p&gt;

&lt;p&gt;每一个神经元都必须添加其偏置（一个常数）。因为我们有 10 个神经元，我们同样拥有 10 个偏置常数。我们将这个 10 个值的向量称为 b。它必须被添加到先前计算的矩阵中的每一行当中。使用一个称为 &amp;ldquo;broadcasting&amp;rdquo; 的魔法，我们将会用一个简单的加号写出它。&lt;/p&gt;

&lt;p&gt;「Broadcasting」是 Python 和 numpy（Python 的科学计算库）的一个标准技巧。它扩展了对不兼容维度的矩阵进行正常操作的方式。「Broadcasting add」意味着「如果你因为两个矩阵维度不同的原因而不能将其相加，那么你可以根据需要尝试复制一个小的矩阵使其工作。」&lt;/p&gt;

&lt;p&gt;我们最终应用 softmax 激活函数并且得到一个描述单层神经网络的公式，并将其应用于 100 张图像：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/cd007da75f714c96ade9a4e4c0187bfa_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;顺便说一下，什么是「tensor（张量）」？&lt;/p&gt;

&lt;p&gt;「张量（tensor）」像一个矩阵，但是却有着任意数量的维度。一个 1 维的张量是一个向量。一个二维的张量是一个矩阵。然后你可以有 3, 4, 5 或者更多维的张量。&lt;/p&gt;

&lt;h3 id=&#34;理论-梯度下降&#34;&gt;理论：梯度下降&lt;/h3&gt;

&lt;p&gt;现在我们的神经网络从输入图像中产生预测，我们需要知道它们可以做到什么样的程度，即在我们知道的事实和网络的预测之间到底有多大的距离。请记住，我们对于这个数据集中的所有图像都有一个真实的标签。&lt;/p&gt;

&lt;p&gt;任何一种定义的距离都可以进行这样的操作，普通欧几里得距离是可以的，但是对于分类问题，被称为「交叉熵（cross-entropy）」的距离更加有效。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/9fe5ab61209c490297769b729a471c81_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;「one-hot」编码意味着你使用一个 10 个值的向量，其中除了第 6 个值为 1 以外的所有值都是 0。这非常方便，因为这样的格式和我们神经网络预测输出的格式非常相似，同时它也作为一个 10 值的向量。&lt;/p&gt;

&lt;p&gt;「训练」一个神经网络实际上意味着使用训练图像和标签来调整权重和偏置，以便最小化交叉熵损失函数。它是这样工作的。&lt;/p&gt;

&lt;p&gt;交叉熵是一个关于权重、偏置、训练图像的像素和其已知标签的函数。&lt;/p&gt;

&lt;p&gt;如果我们相对于所有的权重和所有的偏置计算交叉熵的偏导数，我们就得到一个对于给定图像、标签和当前权重和偏置的「梯度」。请记住，我们有 7850 个权重和偏置，所以计算梯度需要大量的工作。幸运的是，TensorFlow 可以来帮我们做这项工作。&lt;/p&gt;

&lt;p&gt;梯度的数学意义在于它指向「上（up）」。因为我们想要到达一个交叉熵低的地方，那么我们就去向相反的方向。我们用一小部分的梯度更新权重和偏置并且使用下一批训练图像再次做同样的事情。我们希望的是，这可以使我们到达交叉熵最小的凹点的低部。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/b90ff98a395b46e392c21c6ebca0c7d6_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在这副图片当中，交叉熵被表示为一个具有两个权重的函数。事实上，还有更多。梯度下降算法遵循着一个最陡的坡度下降到局部最小值的路径。训练图像在每一次迭代中同样会被改变，这使得我们向着一个适用于所有图像的局部最小值收敛。&lt;/p&gt;

&lt;p&gt;「学习率（learning rate）」： 在整个梯度的长度上，你不能在每一次迭代的时候都对权重和偏置进行更新。这就会像是你穿着七里靴却试图到达一个山谷的底部。你会直接从山谷的一边到达另一边。为了到达底部，你需要一些更小的步伐，即只使用梯度的一部分，通常在 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1000&lt;/sub&gt; 区域中。我们称这个部分为「学习率（Learning rate）」。&lt;/p&gt;

&lt;p&gt;总结一下，以下是训练过程的步骤：&lt;/p&gt;

&lt;p&gt;Training digits and labels =&amp;gt; loss function =&amp;gt; gradient (partial derivatives) =&amp;gt; steepest descent =&amp;gt; update weights and biases =&amp;gt; repeat with next mini-batch of training images and labels&lt;/p&gt;

&lt;p&gt;训练数字和标签 =&amp;gt; 损失函数 =&amp;gt; 梯度（部分偏导数）=&amp;gt; 最陡的梯度 =&amp;gt; 更新权重和偏置 =&amp;gt; 使用下一个 mini-batch 的图像和标签重复这一过程&lt;/p&gt;

&lt;p&gt;为什么使用 100 个图像和标签的 mini-batch？&lt;/p&gt;

&lt;p&gt;你当然也可以只在一个示例图像中计算你的梯度并且立即更新权重和偏置（这在科学文献中被称为「随机梯度下降（stochastic gradient descent）」）。在 100 个样本上都这样做可以得到一个更好地表示由不同样本图像施加约束的梯度并且可能更快地朝着解决方案收敛。mini-batch 的大小是可调整的参数。还有一个更加技术化的原因：使用批处理也意味着使用较大的矩阵，而这些通常更容易在 GPU 上优化。&lt;/p&gt;

&lt;p&gt;常见问题&lt;/p&gt;

&lt;p&gt;为什么交叉熵是在分类问题中合适的定义距离？&lt;/p&gt;

&lt;p&gt;　　解答链接：&lt;a href=&#34;https://jamesmccaffrey.wordpress.com/2013/11/05/why-you-should-use-cross-entropy-error-instead-of-classification-error-or-mean-squared-error-for-neural-network-classifier-training/&#34;&gt;https://jamesmccaffrey.wordpress.com/2013/11/05/why-you-should-use-cross-entropy-error-instead-of-classification-error-or-mean-squared-error-for-neural-network-classifier-training/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;实验-让我们来看看代码&#34;&gt;实验：让我们来看看代码&lt;/h3&gt;

&lt;p&gt;单层神经网络的代码已经写好了。请打开 mnist_1.0_softmax.py 文件并按说明进行操作。&lt;/p&gt;

&lt;p&gt;你在本节的任务是理解开始代码，以便稍后对其改进。&lt;/p&gt;

&lt;p&gt;你应该看到，在文档中的说明和启动代码只有微小的差别。它们对应于可视化的函数，并且在注释中被标记。此处可忽略。&lt;/p&gt;

&lt;p&gt;　　mnist_1.0_softmax.py：&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&#34;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py&#34;&gt;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/b8be8ddc1a9e41d19ddbffe3ed1ddc05_th.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　我们首先定义 TensorFlow 的变量和占位符。变量是你希望训练算法为你确定的所有的参数。在我们的例子中参数是权重和偏差。&lt;/p&gt;

&lt;p&gt;占位符是在训练期间填充实际数据的参数，通常是训练图像。持有训练图像的张量的形式是 [None, 28, 28, 1]，其中的参数代表：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;28, 28, 1: 图像是 28x28 每像素 x 1（灰度）。最后一个数字对于彩色图像是 3 但在这里并非是必须的。&lt;/li&gt;
&lt;li&gt;None: 这是代表图像在小批量（mini-batch）中的数量。在训练时可以得到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　mnist_1.0_softmax.py：&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&#34;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py&#34;&gt;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/71fef16bc66b4939975a236b58dac8ba_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　第一行是我们单层神经网络的模型。公式是我们在前面的理论部分建立的。tf.reshape 命令将我们的 28×28 的图像转化成 784 个像素的单向量。在 reshape 中的「-1」意味着「计算机，计算出来，这只有一种可能」。在实际当中，这会是图像在小批次（mini-batch）中的数量。&lt;/p&gt;

&lt;p&gt;然后，我们需要一个额外的占位符用于训练标签，这些标签与训练图像一起被提供。&lt;/p&gt;

&lt;p&gt;现在我们有模型预测和正确的标签，所以我们计算交叉熵。tf.reduce_sum 是对向量的所有元素求和。&lt;/p&gt;

&lt;p&gt;最后两行计算了正确识别数字的百分比。这是留给读者的理解练习，使用 TensorFlow API 参考。你也可以跳过它们。&lt;/p&gt;

&lt;p&gt;　　mnist_1.0_softmax.py：&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&#34;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py)&#34;&gt;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　optimizer = tf.train.GradientDescentOptimizer(0.003)&lt;/p&gt;

&lt;p&gt;　　train_step = optimizer.minimize(cross_entropy)&lt;/p&gt;

&lt;p&gt;　　才是 TensorFlow 发挥它力量的地方。你选择一个适应器（optimiser，有许多可供选择）并且用它最小化交叉熵损失。在这一步中，TensorFlow 计算相对于所有权重和所有偏置（梯度）的损失函数的偏导数。这是一个形式衍生（ formal derivation），并非是一个耗时的数值型衍生。&lt;/p&gt;

&lt;p&gt;梯度然后被用来更新权重和偏置。学习率为 0.003。&lt;/p&gt;

&lt;p&gt;最后，是时候来运行训练循环了。到目前为止，所有的 TensorFlow 指令都在内存中准备了一个计算图，但是还未进行计算。&lt;/p&gt;

&lt;p&gt;TensorFlow 的 “延迟执行（deferred execution）” 模型：TensorFlow 是为分布式计算构建的。它必须知道你要计算的是什么、你的执行图（execution graph），然后才开始发送计算任务到各种计算机。这就是为什么它有一个延迟执行模型，你首先使用 TensorFlow 函数在内存中创造一个计算图，然后启动一个执行 Session 并且使用 Session.run 执行实际计算任务。在此时，图形无法被更改。&lt;/p&gt;

&lt;p&gt;由于这个模型，TensorFlow 接管了分布式运算的大量运筹。例如，假如你指示它在计算机 1 上运行计算的一部分 ，而在计算机 2 上运行另一部分，它可以自动进行必要的数据传输。&lt;/p&gt;

&lt;p&gt;计算需要将实际数据反馈进你在 TensorFlow 代码中定义的占位符。这是以 Python 的 dictionary 的形式给出的，其中的键是占位符的名称。&lt;/p&gt;

&lt;p&gt;　　mnist_1.0_softmax.py：&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&#34;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py&#34;&gt;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/a96dcaf397d342e18edb0ec24757f821.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　在这里执行的 train_step 是当我们要求 TensorFlow 最小化交叉熵时获得的。这是计算梯度和更新权重和偏置的步骤。&lt;/p&gt;

&lt;p&gt;最终，我们还需要一些值来显示，以便我们可以追踪我们模型的性能。&lt;/p&gt;

&lt;p&gt;在训练回路中使用该代码来计算准确度和交叉熵（例如每 10 次迭代）：&lt;/p&gt;

&lt;p&gt;　　# success ?&lt;/p&gt;

&lt;p&gt;　　a,c = sess.run([accuracy, cross_entropy], feed_dict=train_data)&lt;/p&gt;

&lt;p&gt;通过在馈送 dictionary 中提供测试而不是训练数据，可以对测试数据进行同样的计算（例如每 100 次迭代计算一次。有 10,000 个测试数字，所以会耗费 CPU 一些时间）：&lt;/p&gt;

&lt;p&gt;　　# success on test data ?&lt;/p&gt;

&lt;p&gt;　　test&lt;em&gt;data={X: mnist.test.images, Y&lt;/em&gt;: mnist.test.labels}&lt;/p&gt;

&lt;p&gt;　　a,c = sess.run([accuracy, cross_entropy], feed=test_data)&lt;/p&gt;

&lt;p&gt;TensorFlow 和 Numpy 是朋友：在准备计算图时，你只需要操纵 TensorFlow 张量和命令，比如 tf.matmul, tf.reshape 等。&lt;/p&gt;

&lt;p&gt;然而，只要执行 Session.run 命令，它的返回值就是 Numpy 张量，即 Numpy 可以使用的 numpy.ndarray 对象以及基于它的所有科学计算库。这就是使用 matplotlib（基于 Numpy 的标准 Python 绘图库）为本实验构建实时可视化的方法。&lt;/p&gt;

&lt;p&gt;这个简单的模型已经能识别 92% 的数字了。这不错，但是你现在要显著地改善它。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/e65dd7cd3b2f43ab85279a8d39de470a_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;实验-增加层&#34;&gt;实验:增加层&lt;/h3&gt;

&lt;p&gt;为了提高识别的准确度，我们将为神经网络增加更多的层。第二层神经元将计算前一层神经元输出的加权和，而非计算像素的加权和。这里有一个 5 层全相连的神经网络的例子：&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/1b4c2da0004c41988eb4bd83f28449dd_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们继续用 softmax 来作为最后一层的激活函数，这也是为什么在分类这个问题上它性能优异的原因。但在中间层，我们要使用最经典的激活函数：sigmoid：在这一节中你的任务是为你的模型增加一到两个中间层以提高它的性能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/6e069d408df443c49317ccd7784874b8_th.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;答案可以在 mnist_2.0_five_layers_sigmoid.py 中找到。只有当你实在想不出来的时候再使用它！为了增加一个层，你需要为中间层增加一个额外的权重矩阵和一个额外的偏置向量：&lt;/p&gt;

&lt;p&gt;　　W1 = tf.Variable(tf.truncated_normal([28*28, 200] ,stddev=0.1))&lt;/p&gt;

&lt;p&gt;　　B1 = tf.Variable(tf.zeros([200]))&lt;/p&gt;

&lt;p&gt;　　W2 = tf.Variable(tf.truncated_normal([200, 10], stddev=0.1))&lt;/p&gt;

&lt;p&gt;　　B2 = tf.Variable(tf.zeros([10]))&lt;/p&gt;

&lt;p&gt;对，就这么做。通过 2 个中间层以及例子中 200 个和 100 个神经元，你现在应该能够把你的神经网络的准确度推高到 97% 了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/e60d8b29dad048fa8e5917c95c7a6153_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;实验-深度网络需要特别注意的地方&#34;&gt;实验：深度网络需要特别注意的地方&lt;/h3&gt;

&lt;p&gt;随着层数的增加，神经网络越来越难以收敛。但现在我们知道如何控制它们的行为了。这里是一些只用 1 行就可以实现的改进，当你看到准确度曲线出现如下情况的时候，这些小技巧会帮到你：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/5b31861eff624a32bca2e5c29169a7c1_th.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;修正线性单元（ReLU）激活函数&lt;/p&gt;

&lt;p&gt;在深度网络里，sigmoid 激活函数确实能带来很多问题。它把所有的值都挤到了 0 到 1 之间，而且当你重复做的时候，神经元的输出和它们的梯度都归零了。值得一提的是，出于历史原因，一些现代神经网络使用了 ReLU（修正线性单元），它大致是如下这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/a06abc6c13f743c28dd4b28018854629.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;升级 1/4：用 RELU 替换你所有的 sigmoid，然后你会得到一个更快的初始收敛并且当我们继续增加层的时候也避免了一些后续问题的产生。仅仅在代码中简单地用 tf.nn.relu 来替换 tf.nn.sigmoid 就可以了。&lt;/p&gt;

&lt;p&gt;一个更好的优化器&lt;/p&gt;

&lt;p&gt;在一个特别多维的空间里，就像当前这个情况——我们有 10K 量级的权值和偏置值——「鞍点 (saddle points）」会频繁出现。这些点不是局部最小值点，但它的梯度却是零，那么梯度降的优化会卡在这里。TensorFlow 有一系列可以用的优化器，包括一些带有一定的惯性，能够安全越过鞍点的优化器。&lt;/p&gt;

&lt;p&gt;升级 2/4：现在将你的 tf.train.GradientDescentOptimiser 替换为 tf.train.AdamOptimizer。&lt;/p&gt;

&lt;p&gt;随机初始化&lt;/p&gt;

&lt;p&gt;准确性一直卡在 0.1？你把你的权值初始化成随机值了没？对于偏置值，如果用 ReLU 的话，最好的办法就是把它们都初始化成小的正值，这样神经元一开始就会工作在 ReLU 的非零区域内。&lt;/p&gt;

&lt;p&gt;　　W = tf.Variable(tf.truncated_normal([K, L] ,stddev=0.1))&lt;/p&gt;

&lt;p&gt;　　B = tf.Variable(tf.ones([L])/10)&lt;/p&gt;

&lt;p&gt;升级 3/4：现在检查是否你所有的权值和偏置值都被初始化好了。上图所示的 0.1 会作为偏置值。&lt;/p&gt;

&lt;p&gt;不定值（NaN）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/18bf142ee7894aa18c015ddba8c645ab_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果你看到你的精确曲线陡然下滑并且调试口输出的交叉熵是 NaN，不用感到头疼，你其实是正在尝试计算 log(0)，而这肯定是个不定值（NaN）。还记得吗，交叉熵的计算涉及到对 softmax 层的输出取对数。鉴于 softmax 基本上是一个指数，它肯定不是 0，我们如果用 32 位精度的浮点运算就还好，exp(-100) 基本上可以算作是 0 了。&lt;/p&gt;

&lt;p&gt;很幸运，TensorFlow 有一个非常方便的函数可以在单步内计算 softmax 和交叉熵，它是以一种数值上较为稳定的方式实现的。如果要使用它，你需要在应用 softmax 之前将原始的权重和加上你最后一层的偏置隔离开来（在神经网络的术语里叫「logits」）。&lt;/p&gt;

&lt;p&gt;　　如果你模型的最后一行是这样的：&lt;/p&gt;

&lt;p&gt;　　Y = tf.nn.softmax(tf.matmul(Y4, W5) + B5)&lt;/p&gt;

&lt;p&gt;　　你需要把它替换成：&lt;/p&gt;

&lt;p&gt;　　Ylogits = tf.matmul(Y4, W5) + B5Y = tf.nn.softmax(Ylogits)&lt;/p&gt;

&lt;p&gt;　　并且你现在能以一种安全的方式计算交叉熵了：&lt;/p&gt;

&lt;p&gt;　　cross_entropy = tf.nn.softmax_cross_entropy_with&lt;em&gt;logits(Ylogits, Y&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;同样加上下面这行代码使得测试和训练的交叉熵能够同框显示：&lt;/p&gt;

&lt;p&gt;　　cross_entropy = tf.reduce_mean(cross_entropy)*100&lt;/p&gt;

&lt;p&gt;升级 4/4：请把 tf.nn.softmax_cross_entropy_with_logits 加到你的代码里。你也可以跳过这一步，等你真在你的输出里看到 NaN 以后再来做这步。现在，你已经准备好实现「深度」了。&lt;/p&gt;

&lt;h3 id=&#34;实验-学习速率衰退&#34;&gt;实验：学习速率衰退&lt;/h3&gt;

&lt;p&gt;通过两个、三个或者四个中间层，你现在可以将准确度提升至接近 98%，当然，你的迭代次数要达到 5000 次以上。不过你会发现你并不总是会得到这样的结果。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/a4492d6cbbb343aab07a355246c915de_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这些曲线很嘈杂，看看测试精确度吧：它在全百分比范围内跳上跳下。这意味着即使 0.003 的学习率我们还是太快了。但我们不能仅仅将学习率除以十或者永远不停地做训练。一个好的解决方案是开始很快随后将学习速率指数级衰减至比如说 0.0001。&lt;/p&gt;

&lt;p&gt;这个小改变的影响是惊人的。你会看到大部分的噪声消失了并且测试精确度持续稳定在 98% 以上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/41294f08d52d4959bb4b01c8e925f056_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再看看训练精确度曲线。在好多个 epoch 里都达到了 100%（一个 epoch=500 次迭代=全部训练图片训练一次）。第一次我们能很好地识别训练图片了。&lt;/p&gt;

&lt;p&gt;请把学习率衰退加到你的代码里。为了把一个不同的学习率在每次迭代时传给 AdamOptimizer，你需要定义一个新的占位符（placeholder）并在每次迭代时通过 feed_dict 赋给它一个新的参数。&lt;/p&gt;

&lt;p&gt;这里是一个指数级衰减的方程：lr = lrmin+(lrmax-lrmin)*exp(-i/2000) 答案可以在这个文件里找到：mnist_2.1_five_layers_relu_lrdecay.py。如果你被卡住了可以用它。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/260e6a3277984432adc3e945251e5f18_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;实验-dropout-过拟合&#34;&gt;实验：dropout、过拟合&lt;/h3&gt;

&lt;p&gt;你可能已经注意到在数千次迭代之后，测试和训练数据的交叉熵曲线开始不相连。学习算法只是在训练数据上做工作并相应地优化训练的交叉熵。它再也看不到测试数据了，所以这一点也不奇怪：过了一会儿它的工作不再对测试交叉熵产生任何影响，交叉熵停止了下降，有时甚至反弹回来。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/2b215ed2c1984612bdba47bf0dba1188_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;它不会立刻影响你模型对于真实世界的识别能力，但是它会使你运行的众多迭代毫无用处，而且这基本上是一个信号——告诉我们训练已经不能再为模型提供进一步改进了。这种无法连接通常会被标明「过拟合（overfitting）」，而且当你看到这个的时候，你可以尝试采用一种规范化（regularization）技术，称之为「dropout」。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/8ba81eadbd6f4383a4af3a8dc13bbe53_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 dropout 里，在每一次训练迭代的时候，你可以从网络中随机地放弃一些神经元。你可以选择一个使神经元继续保留的概率 pkeep，通常是 50% 到 75% 之间，然后在每一次训练的迭代时，随机地把一些神经元连同它们的权重和偏置一起去掉。在一次迭代里，不同的神经元可以被一起去掉（而且你也同样需要等比例地促进剩余神经元的输出，以确保下一层的激活不会移动）。当测试你神经网络性能的时候，你再把所有的神经元都装回来 (pkeep=1)。&lt;/p&gt;

&lt;p&gt;TensorFlow 提供一个 dropout 函数可以用在一层神经网络的输出上。它随机地清零一些输出并且把剩下的提升 1/pkeep。这里是如何把它用在一个两层神经网络上的例子。&lt;/p&gt;

&lt;p&gt;　　# feed in 1 when testing, 0.75 when training&lt;/p&gt;

&lt;p&gt;　　pkeep = tf.placeholder(tf.float32)&lt;/p&gt;

&lt;p&gt;　　Y1 = tf.nn.relu(tf.matmul(X, W1) + B1)&lt;/p&gt;

&lt;p&gt;　　Y1d = tf.nn.dropout(Y1, pkeep)&lt;/p&gt;

&lt;p&gt;　　Y = tf.nn.softmax(tf.matmul(Y1d, W2) + B2)&lt;/p&gt;

&lt;p&gt;你现在可以在网络中每个中间层以后插入 dropout。如果你没时间深入阅读的话，这是本项目里的可选步骤。&lt;/p&gt;

&lt;p&gt;该解决方案可以在 &lt;a href=&#34;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_2.2_five_layers_relu_lrdecay_dropout.py&#34;&gt;mnist_2.2_five_layers_relu_lrdecay_dropout.py&lt;/a&gt;里找到。如果你被难住了，可以用它。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/59419fef6dbd401aa484dfb9983712f7_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;你会看到测试损失已经被搞回来了，已经在可控范围内了，不过至少在这个例子中噪声重新出现了（如果你知道 dropout 的工作原理的话，这一点也不奇怪）。测试的准确度依然没变，这倒是有点小失望。这个「过拟合」一定还有其它原因。在我们继续进行下一步之前，我们先扼要重述一下我们到目前为止用过的所有工具：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/cfcb109bbbe040d29e61d02d78059124_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;无论我们做什么，我们看上去都不可能很显著地解决 98% 的障碍，而且我们的损失曲线依然显示「过拟合」无法连接。什么是真正的「过拟合」？过拟合发生在该神经网络学得「不好」的时候，在这种情况下该神经网络对于训练样本做得很好，对真实场景却并不是很好。有一些像 dropout 一样的规范化技术能够迫使它学习得更好，不过过拟合还有更深层的原因。&lt;/p&gt;

&lt;p&gt;基本的过拟合发生在一个神经网络针对手头的问题有太多的自由度的时候。想象一下我们有如此多的神经元以至于所组成的网络可以存储我们所有的训练图像并依靠特征匹配来识别它们。它会在真实世界的数据里迷失。一个神经网络必须有某种程度上的约束以使它能够归纳推理它在学习中所学到的东西。&lt;/p&gt;

&lt;p&gt;如果你只有很少的训练数据，甚至一个很小的网络都能够用心学习它。一般来说，你总是需要很多数据来训练神经网络。&lt;/p&gt;

&lt;p&gt;最后，如果你已经做完了所有的步骤，包括实验了不同大小的网络以确保它的自由度已经约束好了、采用了 dropout、并且训练了大量的数据，你可能会发现你还是被卡在了当前的性能层次上再也上不去了。这说明你的神经网络在它当前的形态下已经无法从你提供的数据中抽取到更多的信息了，就像我们这个例子这样。&lt;/p&gt;

&lt;p&gt;还记得我们如何使用我们的图像吗？是所有的像素都展平到一个向量里么？这是一个很糟糕的想法。手写的数字是由一个个形状组成的，当我们把像素展平后我们会丢掉这些形状信息。不过，有一种神经网络可以利用这些形状信息：卷积网络（convolutional network）。让我们来试试。&lt;/p&gt;

&lt;h3 id=&#34;理论-卷积网络&#34;&gt;理论：卷积网络&lt;/h3&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/0eb4bf030ecc488a8d2f990c11e7272c_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在卷积网络层中，一个「神经元」仅对该图像上的一个小部分的像素求加权和。然后，它通常会添加一个偏置单元，并且将得到的加权和传递给激活函数。与全连接网络相比，其最大的区别在于卷积网络的每个神经元重复使用相同的权重，而不是每个神经元都有自己的权重。&lt;/p&gt;

&lt;p&gt;在上面的动画中，你可以看到通过连续修改图片上两个方向的权重（卷积），能够获得与图片上的像素点数量相同的输出值（尽管在边缘处需要填充（padding））。&lt;/p&gt;

&lt;p&gt;要产生一个输出值平面，我们使用了一张 4x4 大小的彩色图片作为出输入。在这个动画当中，我们需要 4x4x3=48 个权重，这还不够，为了增加更多自由度，我们还需要选取不同组的权重值重复实验。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/cda66c477aa946eeba45408d4129b274_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过向权重张量添加一个维度，能够将两组或更多组的权重重写为一组权重，这样就给出了一个卷积层的权重张量的通用实现。由于输入、输出通道的数量都是参数，我们可以开始堆叠式（stacking）和链式（chaining）的卷积层。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/10228a2a4d134aa0aa3077cb019d34a9_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后，我们需要提取信息。在最后一层中，我们仅仅想使用 10 个神经元来分类 0-9 十个不同的数字。传统上，这是通过「最大池化（max-pooling）」层来完成的。即使今天有许多更简单的方法能够实现这分类任务，但是，「最大池化」能够帮助我们直觉地理解卷积神经网络是怎么工作的。如果你认为在训练的过程中，我们的小块权重会发展成能够过滤基本形状（水平线、垂直线或曲线等）的过滤器（filter），那么，提取有用信息的方式就是识别输出层中哪种形状具有最大的强度。实际上，在最大池化层中，神经元的输出是在 2x2 的分组中被处理，最后仅仅保留输出最大强度的神经元。&lt;/p&gt;

&lt;p&gt;这里有一种更简单的方法：如果你是以一步两个像素移动图片上的滑块而不是以每步一个像素地移动图片上的滑块。这种方法就是有效的，今天的卷积网络仅仅使用了卷积层。&lt;/p&gt;

&lt;p&gt;让我们建立一个用于手写数字识别的卷积网络。在顶部，我们将使用 3 个卷积层；在底部，我们使用传统的 softmax 读出层，并将它们用完全连接层连接。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/d3ae69380cae4dddbfc0f3523a264f4e_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意，第二与第三卷积层神经元数量以 2x2 为倍数减少，这就解释了为什么它们的输出值从 28x28 减少为 14x14，然后再到 7x7。卷积层的大小变化使神经元的数量在每层下降约为：28x28x14≈3000-&amp;gt;14x14x8≈1500 → 7x7x12≈500 → 200。下一节中，我们将给出该网络的具体实现。&lt;/p&gt;

&lt;h3 id=&#34;实现-一个卷积网络&#34;&gt;实现：一个卷积网络&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/bf6ccfdee1bc440db5e14229a5799aa3_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了将我们的代码转化为卷积模型，我们需要为卷积层定义适当的权重张量，然后将该卷积层添加到模型中。我们已经理解到卷积层需要以下形式的权重张量。下面代码是用 TensorFlow 语法来对其初始化：&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/dee5ee4d2bda42298813d9819ce61a24_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　W = tf.Variable(tf.truncated_normal([4, 4, 3, 2], stddev=0.1))&lt;/p&gt;

&lt;p&gt;　　B = tf.Variable(tf.ones([2])/10) # 2 is the number of output channels&lt;/p&gt;

&lt;p&gt;在 TensorFlow 中，使用 tf.nn.conv2d 函数实现卷积层，该函数使用提供的权重在两个方向上扫描输入图片。这仅仅是神经元的加权和部分，你需要添加偏置单元并将加权和提供给激活函数。&lt;/p&gt;

&lt;p&gt;　　stride = 1 # output is still 28x28&lt;/p&gt;

&lt;p&gt;　　Ycnv = tf.nn.conv2d(X, W, strides=[1, stride, stride, 1], padding=&amp;lsquo;SAME&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;　　Y = tf.nn.relu(Ycnv + B)&lt;/p&gt;

&lt;p&gt;不要过分在意 stride 的复杂语法，查阅文档就能获取完整的详细信息。这里的填充（padding）策略是为了复制图片的边缘的像素。所有的数字都在一个统一的背景下，所以这仅仅是扩展了背景，并且不应该添加不需要的任何样式。&lt;/p&gt;

&lt;p&gt;现在该你了。修改你的模型并将其转化为卷积模型。你可以使用上图中的值来修改它，你可以减小你的学习速率但是务必先移除 dropout。&lt;/p&gt;

&lt;p&gt;你的模型的准确率应该会超过 98%，并且最终达到约 99%。眼看目标就要实现，我们不能停止！看看测试的交叉熵曲线。在你的头脑中，此时，是否解决方案正在形成？&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/cb5d786d95ac44a5a9bc42c90d212f69_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;99-准确率的挑战&#34;&gt;99% 准确率的挑战&lt;/h3&gt;

&lt;p&gt;调整你的神经网络的一个好方法：先去实现一个限制较多的神经网络，然后给它更多的自由度并且增加 dropout，使神经网络避免过拟合。最终你将得到一个相当不错的神经网络。&lt;/p&gt;

&lt;p&gt;例如，我们在第一层卷积层中仅仅使用了 4 个 patch，如果这些权重的 patch 在训练的过程中发展成不同的识别器，你可以直观地看到这对于解决我们的问题是不够的。手写数字模式远多于 4 种基本样式。&lt;/p&gt;

&lt;p&gt;因此，让我们稍微增加 patch 的数量，将我们卷积层中 patch 的数量从 4，8，12 增加到 6，12，24，并且在全连接层上添加 dropout。它们的神经元重复使用相同的权重，在一次训练迭代中，通过冻结（限制）一些不会对它们起作用的权重，dropout 能够有效地工作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/5792c4f41a734c44b4f1c3ee40e47742_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;加油吧，去打破 99％的限制。增加 patch 数量和通道的数量，如上图所示，在卷积层中添加 dropout。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/e2e13da25b6146f2b0274a19187e18c0_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;解决方案可以在文件 mnist_3.1_convolutional_bigger_dropout.py 中找到。&lt;/p&gt;

&lt;p&gt;使用上图所示的模型，在 10000 个测试的数字中，结果仅仅错误了 72 个。你可以在 MNIST 网站上发现，数字识别准确率的世界纪录大约为 99.7%，这仅比我们用 100 行 Python/TensorFlow 代码构建的模型的准确率高 0.4%。&lt;/p&gt;

&lt;p&gt;最后，不同的 dropout 使我们能够训练更大的卷积网络。增加神经网络的额外自由度，使模型的最终准确率从 98.9% 达到 99.1%。向卷积层中增加 dropout 不仅减少了测试误差，而且使我们模型的准确率突破 99%，甚至达到了 99.3%。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/70c0a9eed13d48e793d06de2317a006f_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;恭喜&#34;&gt;恭喜&lt;/h3&gt;

&lt;p&gt;你已经建立了你的第一个神经网络，并且训练精度达到了 99%。在这个学习过程中，你所学到的技术，并不局限于 MNIST 数据集。实际上，这些技术在训练神经网络的过程中被广泛使用。作为礼物，下面提供的内容可以用来帮助你回忆已经所学的内容。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在完成了完全神经网络和卷积网络后，你应该学习循环神经网络：&lt;a href=&#34;https://www.tensorflow.org/tutorials/recurrent/。&#34;&gt;https://www.tensorflow.org/tutorials/recurrent/。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在本教程中，你已经学习了如何在矩阵层次构建 TensorFlow 模型。Tensorflow 还有更高级的 API，称为 tf.learn：&lt;a href=&#34;https://www.tensorflow.org/tutorials/tflearn/&#34;&gt;https://www.tensorflow.org/tutorials/tflearn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;要在云上的分布式框架上训练，我们提供 Cloud ML 服务：&lt;a href=&#34;https://cloud.google.com/ml&#34;&gt;https://cloud.google.com/ml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;最后，我们希望收到你的反馈。如果你在发现了本实验中的些许错误，或者你认为有什么需要改进的地方，请告诉我们。我们通过 GitHub 处理反馈，&lt;a href=&#34;https://github.com/googlecodelabs/feedback/issues/new?title=[cloud-tensorflow-mnist]:&amp;amp;labels[]=content-platform&amp;amp;labels[]=cloud&#34;&gt;反馈链接&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;虽然看不懂，但是先混个脸熟，以后慢慢再看。本文大部分内容复制自&lt;a href=&#34;http://it.sohu.com/20170124/n479480999.shtml&#34;&gt;教程 | 没有博士学位，照样玩转TensorFlow深度学习&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>