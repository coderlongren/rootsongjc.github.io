<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Jimmy Song&#39;s Blog</title>
    <link>http://rootsongjc.github.io/blogs/index.xml</link>
    <description>Recent content in Blogs on Jimmy Song&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 11 Apr 2017 19:55:56 +0800</lastBuildDate>
    <atom:link href="http://rootsongjc.github.io/blogs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Kubernetes高可用master节点安装</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-ha-master-installation/</link>
      <pubDate>Tue, 11 Apr 2017 19:55:56 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-ha-master-installation/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2015091402.jpg&#34; alt=&#34;北京西山&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：鬼见愁@北京西山 Sep 14,2015）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这是&lt;a href=&#34;https://github.com/rootsongjc/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;项目((fork自&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;opsnull&lt;/a&gt;))中的一篇文章，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;产生的kuberentes环境，部署master节点的&lt;code&gt;kube-apiserver&lt;/code&gt;、&lt;code&gt;kube-controller-manager&lt;/code&gt;和&lt;code&gt;kube-scheduler&lt;/code&gt;的过程。&lt;/p&gt;

&lt;h2 id=&#34;高可用kubernetes-master节点安装&#34;&gt;高可用kubernetes master节点安装&lt;/h2&gt;

&lt;p&gt;kubernetes master 节点包含的组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kube-apiserver&lt;/li&gt;
&lt;li&gt;kube-scheduler&lt;/li&gt;
&lt;li&gt;kube-controller-manager&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目前这三个组件需要部署在同一台机器上。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kube-scheduler&lt;/code&gt;、&lt;code&gt;kube-controller-manager&lt;/code&gt; 和 &lt;code&gt;kube-apiserver&lt;/code&gt; 三者的功能紧密相关；&lt;/li&gt;
&lt;li&gt;同时只能有一个 &lt;code&gt;kube-scheduler&lt;/code&gt;、&lt;code&gt;kube-controller-manager&lt;/code&gt; 进程处于工作状态，如果运行多个，则需要通过选举产生一个 leader；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文档记录部署一个三个节点的高可用 kubernetes master 集群步骤。（后续创建一个 load balancer 来代理访问 kube-apiserver 的请求）&lt;/p&gt;

&lt;h2 id=&#34;tls-证书文件&#34;&gt;TLS 证书文件&lt;/h2&gt;

&lt;p&gt;pem和token.csv证书文件我们在&lt;a href=&#34;./01-TLS证书和秘钥.md&#34;&gt;TLS证书和秘钥&lt;/a&gt;这一步中已经创建过了。我们再检查一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ls /etc/kubernetes/ssl
admin-key.pem  admin.pem  ca-key.pem  ca.pem  kube-proxy-key.pem  kube-proxy.pem  kubernetes-key.pem  kubernetes.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;下载最新版本的二进制文件&#34;&gt;下载最新版本的二进制文件&lt;/h2&gt;

&lt;p&gt;有两种下载方式&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;从 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/releases&#34;&gt;github release 页面&lt;/a&gt; 下载发布版 tarball，解压后再执行下载脚本&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;   $ wget https://github.com/kubernetes/kubernetes/releases/download/v1.6.0/kubernetes.tar.gz
   $ tar -xzvf kubernetes.tar.gz
   ...
   $ cd kubernetes
   $ ./cluster/get-kube-binaries.sh
   ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;从 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG.md&#34;&gt;&lt;code&gt;CHANGELOG&lt;/code&gt;页面&lt;/a&gt; 下载 &lt;code&gt;client&lt;/code&gt; 或 &lt;code&gt;server&lt;/code&gt; tarball 文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;server&lt;/code&gt; 的 tarball &lt;code&gt;kubernetes-server-linux-amd64.tar.gz&lt;/code&gt; 已经包含了 &lt;code&gt;client&lt;/code&gt;(&lt;code&gt;kubectl&lt;/code&gt;) 二进制文件，所以不用单独下载&lt;code&gt;kubernetes-client-linux-amd64.tar.gz&lt;/code&gt;文件；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;   $ # wget https://dl.k8s.io/v1.6.0/kubernetes-client-linux-amd64.tar.gz
   $ wget https://dl.k8s.io/v1.6.0/kubernetes-server-linux-amd64.tar.gz
   $ tar -xzvf kubernetes-server-linux-amd64.tar.gz
   ...
   $ cd kubernetes
   $ tar -xzvf  kubernetes-src.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将二进制文件拷贝到指定路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cp -r server/bin/{kube-apiserver,kube-controller-manager,kube-scheduler,kubectl,kube-proxy,kubelet} /root/local/bin/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置和启动-kube-apiserver&#34;&gt;配置和启动 kube-apiserver&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;创建 kube-apiserver的service配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;serivce配置文件&lt;code&gt;/usr/lib/systemd/system/kube-apiserver.service&lt;/code&gt;内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes API Service
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=network.target
After=etcd.service

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/apiserver
ExecStart=/usr/bin/kube-apiserver \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_ETCD_SERVERS \
	    $KUBE_API_ADDRESS \
	    $KUBE_API_PORT \
	    $KUBELET_PORT \
	    $KUBE_ALLOW_PRIV \
	    $KUBE_SERVICE_ADDRESSES \
	    $KUBE_ADMISSION_CONTROL \
	    $KUBE_API_ARGS
Restart=on-failure
Type=notify
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/kubernetes/config&lt;/code&gt;文件的内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
# kubernetes system config
#
# The following values are used to configure various aspects of all
# kubernetes services, including
#
#   kube-apiserver.service
#   kube-controller-manager.service
#   kube-scheduler.service
#   kubelet.service
#   kube-proxy.service
# logging to stderr means we get it in the systemd journal
KUBE_LOGTOSTDERR=&amp;quot;--logtostderr=true&amp;quot;

# journal message level, 0 is debug
KUBE_LOG_LEVEL=&amp;quot;--v=0&amp;quot;

# Should this cluster be allowed to run privileged docker containers
KUBE_ALLOW_PRIV=&amp;quot;--allow-privileged=true&amp;quot;

# How the controller-manager, scheduler, and proxy find the apiserver
#KUBE_MASTER=&amp;quot;--master=http://sz-pg-oam-docker-test-001.tendcloud.com:8080&amp;quot;
KUBE_MASTER=&amp;quot;--master=http://172.20.0.113:8080&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该配置文件同时被kube-apiserver、kube-controller-manager、kube-scheduler、kubelet、kube-proxy使用。&lt;/p&gt;

&lt;p&gt;apiserver配置文件&lt;code&gt;/etc/kubernetes/apiserver&lt;/code&gt;内容为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ini&#34;&gt;###
## kubernetes system config
##
## The following values are used to configure the kube-apiserver
##
#
## The address on the local server to listen to.
#KUBE_API_ADDRESS=&amp;quot;--insecure-bind-address=sz-pg-oam-docker-test-001.tendcloud.com&amp;quot;
KUBE_API_ADDRESS=&amp;quot;--advertise-address=172.20.0.113 --bind-address=172.20.0.113 --insecure-bind-address=172.20.0.113&amp;quot;
#
## The port on the local server to listen on.
#KUBE_API_PORT=&amp;quot;--port=8080&amp;quot;
#
## Port minions listen on
#KUBELET_PORT=&amp;quot;--kubelet-port=10250&amp;quot;
#
## Comma separated list of nodes in the etcd cluster
KUBE_ETCD_SERVERS=&amp;quot;--etcd-servers=https://172.20.0.113:2379,172.20.0.114:2379,172.20.0.115:2379&amp;quot;
#
## Address range to use for services
KUBE_SERVICE_ADDRESSES=&amp;quot;--service-cluster-ip-range=10.254.0.0/16&amp;quot;
#
## default admission control policies
KUBE_ADMISSION_CONTROL=&amp;quot;--admission-control=ServiceAccount,NamespaceLifecycle,NamespaceExists,LimitRanger,ResourceQuota&amp;quot;
#
## Add your own!
KUBE_API_ARGS=&amp;quot;--authorization-mode=RBAC --runtime-config=rbac.authorization.k8s.io/v1beta1 --kubelet-https=true --experimental-bootstrap-token-auth --token-auth-file=/etc/kubernetes/token.csv --service-node-port-range=30000-32767 --tls-cert-file=/etc/kubernetes/ssl/kubernetes.pem --tls-private-key-file=/etc/kubernetes/ssl/kubernetes-key.pem --client-ca-file=/etc/kubernetes/ssl/ca.pem --service-account-key-file=/etc/kubernetes/ssl/ca-key.pem --etcd-cafile=/etc/kubernetes/ssl/ca.pem --etcd-certfile=/etc/kubernetes/ssl/kubernetes.pem --etcd-keyfile=/etc/kubernetes/ssl/kubernetes-key.pem --enable-swagger-ui=true --apiserver-count=3 --audit-log-maxage=30 --audit-log-maxbackup=3 --audit-log-maxsize=100 --audit-log-path=/var/lib/audit.log --event-ttl=1h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--authorization-mode=RBAC&lt;/code&gt; 指定在安全端口使用 RBAC 授权模式，拒绝未通过授权的请求；&lt;/li&gt;
&lt;li&gt;kube-scheduler、kube-controller-manager 一般和 kube-apiserver 部署在同一台机器上，它们使用&lt;strong&gt;非安全端口&lt;/strong&gt;和 kube-apiserver通信;&lt;/li&gt;
&lt;li&gt;kubelet、kube-proxy、kubectl 部署在其它 Node 节点上，如果通过&lt;strong&gt;安全端口&lt;/strong&gt;访问 kube-apiserver，则必须先通过 TLS 证书认证，再通过 RBAC 授权；&lt;/li&gt;
&lt;li&gt;kube-proxy、kubectl 通过在使用的证书里指定相关的 User、Group 来达到通过 RBAC 授权的目的；&lt;/li&gt;
&lt;li&gt;如果使用了 kubelet TLS Boostrap 机制，则不能再指定 &lt;code&gt;--kubelet-certificate-authority&lt;/code&gt;、&lt;code&gt;--kubelet-client-certificate&lt;/code&gt; 和 &lt;code&gt;--kubelet-client-key&lt;/code&gt; 选项，否则后续 kube-apiserver 校验 kubelet 证书时出现 ”x509: certificate signed by unknown authority“ 错误；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--admission-control&lt;/code&gt; 值必须包含 &lt;code&gt;ServiceAccount&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--bind-address&lt;/code&gt; 不能为 &lt;code&gt;127.0.0.1&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;runtime-config&lt;/code&gt;配置为&lt;code&gt;rbac.authorization.k8s.io/v1beta1&lt;/code&gt;，表示运行时的apiVersion；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--service-cluster-ip-range&lt;/code&gt; 指定 Service Cluster IP 地址段，该地址段不能路由可达；&lt;/li&gt;
&lt;li&gt;缺省情况下 kubernetes 对象保存在 etcd &lt;code&gt;/registry&lt;/code&gt; 路径下，可以通过 &lt;code&gt;--etcd-prefix&lt;/code&gt; 参数进行调整；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整 unit 见 &lt;a href=&#34;./systemd/kube-apiserver.service&#34;&gt;kube-apiserver.service&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启动kube-apiserver&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl daemon-reload
$ systemctl enable kube-apiserver
$ systemctl start kube-apiserver
$ systemctl status kube-apiserver
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置和启动-kube-controller-manager&#34;&gt;配置和启动 kube-controller-manager&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;创建 kube-controller-manager的serivce配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文件路径&lt;code&gt;/usr/lib/systemd/system/kube-controller-manager.service&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;Description=Kubernetes Controller Manager
Documentation=https://github.com/GoogleCloudPlatform/kubernetes

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/controller-manager
ExecStart=/usr/bin/kube-controller-manager \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_MASTER \
	    $KUBE_CONTROLLER_MANAGER_ARGS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件&lt;code&gt;/etc/kubernetes/controller-manager&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
# The following values are used to configure the kubernetes controller-manager

# defaults from config and apiserver should be adequate

# Add your own!
KUBE_CONTROLLER_MANAGER_ARGS=&amp;quot;--address=127.0.0.1 --service-cluster-ip-range=10.254.0.0/16 --cluster-name=kubernetes --cluster-signing-cert-file=/etc/kubernetes/ssl/ca.pem --cluster-signing-key-file=/etc/kubernetes/ssl/ca-key.pem  --service-account-private-key-file=/etc/kubernetes/ssl/ca-key.pem --root-ca-file=/etc/kubernetes/ssl/ca.pem --leader-elect=true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;--service-cluster-ip-range&lt;/code&gt; 参数指定 Cluster 中 Service 的CIDR范围，该网络在各 Node 间必须路由不可达，必须和 kube-apiserver 中的参数一致；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--cluster-signing-*&lt;/code&gt; 指定的证书和私钥文件用来签名为 TLS BootStrap 创建的证书和私钥；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--root-ca-file&lt;/code&gt; 用来对 kube-apiserver 证书进行校验，&lt;strong&gt;指定该参数后，才会在Pod 容器的 ServiceAccount 中放置该 CA 证书文件&lt;/strong&gt;；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--address&lt;/code&gt; 值必须为 &lt;code&gt;127.0.0.1&lt;/code&gt;，因为当前 kube-apiserver 期望 scheduler 和 controller-manager 在同一台机器，否则：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  $ kubectl get componentstatuses
  NAME                 STATUS      MESSAGE                                                                                        ERROR
  scheduler            Unhealthy   Get http://127.0.0.1:10251/healthz: dial tcp 127.0.0.1:10251: getsockopt: connection refused   
  controller-manager   Healthy     ok                                                                                             
  etcd-2               Unhealthy   Get http://172.20.0.113:2379/health: malformed HTTP response &amp;quot;\x15\x03\x01\x00\x02\x02&amp;quot;        
  etcd-0               Healthy     {&amp;quot;health&amp;quot;: &amp;quot;true&amp;quot;}                                                                             
  etcd-1               Healthy     {&amp;quot;health&amp;quot;: &amp;quot;true&amp;quot;}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://github.com/kubernetes-incubator/bootkube/issues/64&#34;&gt;https://github.com/kubernetes-incubator/bootkube/issues/64&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;完整 unit 见 &lt;a href=&#34;./systemd/kube-controller-manager.service&#34;&gt;kube-controller-manager.service&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;启动-kube-controller-manager&#34;&gt;启动 kube-controller-manager&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl daemon-reload
$ systemctl enable kube-controller-manager
$ systemctl start kube-controller-manager
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置和启动-kube-scheduler&#34;&gt;配置和启动 kube-scheduler&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;创建 kube-scheduler的serivce配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文件路径&lt;code&gt;/usr/lib/systemd/system/kube-scheduler.serivce&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes Scheduler Plugin
Documentation=https://github.com/GoogleCloudPlatform/kubernetes

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/scheduler
ExecStart=/usr/bin/kube-scheduler \
            $KUBE_LOGTOSTDERR \
            $KUBE_LOG_LEVEL \
            $KUBE_MASTER \
            $KUBE_SCHEDULER_ARGS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件&lt;code&gt;/etc/kubernetes/scheduler&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ini&#34;&gt;###
# kubernetes scheduler config

# default config should be adequate

# Add your own!
KUBE_SCHEDULER_ARGS=&amp;quot;--leader-elect=true --address=127.0.0.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--address&lt;/code&gt; 值必须为 &lt;code&gt;127.0.0.1&lt;/code&gt;，因为当前 kube-apiserver 期望 scheduler 和 controller-manager 在同一台机器；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整 unit 见 &lt;a href=&#34;./systemd/kube-scheduler.service&#34;&gt;kube-scheduler.service&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;启动-kube-scheduler&#34;&gt;启动 kube-scheduler&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl daemon-reload
$ systemctl enable kube-scheduler
$ systemctl start kube-scheduler
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;验证-master-节点功能&#34;&gt;验证 master 节点功能&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get componentstatuses
NAME                 STATUS    MESSAGE              ERROR
scheduler            Healthy   ok                   
controller-manager   Healthy   ok                   
etcd-0               Healthy   {&amp;quot;health&amp;quot;: &amp;quot;true&amp;quot;}   
etcd-1               Healthy   {&amp;quot;health&amp;quot;: &amp;quot;true&amp;quot;}   
etcd-2               Healthy   {&amp;quot;health&amp;quot;: &amp;quot;true&amp;quot;}   
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;当时在配置过程中遇到了问题&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster/issues/4&#34;&gt;TLS认证相关的问题&lt;/a&gt;，其实就是因为配置apiserver时候etcd的协议写成了http导致的，应该是用https。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;Opsnull&lt;/a&gt;写的kubernetes高可用master集群部署过程中似乎并没有包括&lt;strong&gt;高可用的配置&lt;/strong&gt;，才云科技的唐继元分享过&lt;a href=&#34;https://segmentfault.com/a/1190000005832319&#34;&gt;Kubernetes Master High Availability 高级实践&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;究竟如何实现kubernetes master的高可用还需要继续探索。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes安装之etcd高可用配置</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-etcd-ha-config/</link>
      <pubDate>Tue, 11 Apr 2017 15:21:39 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-etcd-ha-config/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2015091401.jpg&#34; alt=&#34;西山俯瞰北京夜景&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：北京夜景@西山）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这是&lt;a href=&#34;https://github.com/rootsongjc/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;项目((fork自&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;opsnull&lt;/a&gt;))中的一篇文章，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;产生的kuberentes环境，生成&lt;strong&gt;kubeconfig&lt;/strong&gt;文件的过程。&lt;/p&gt;

&lt;h2 id=&#34;创建高可用-etcd-集群&#34;&gt;创建高可用 etcd 集群&lt;/h2&gt;

&lt;p&gt;kuberntes 系统使用 etcd 存储所有数据，本文档介绍部署一个三节点高可用 etcd 集群的步骤，这三个节点复用 kubernetes master 机器，分别命名为&lt;code&gt;sz-pg-oam-docker-test-001.tendcloud.com&lt;/code&gt;、&lt;code&gt;sz-pg-oam-docker-test-002.tendcloud.com&lt;/code&gt;、&lt;code&gt;sz-pg-oam-docker-test-003.tendcloud.com&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sz-pg-oam-docker-test-001.tendcloud.com：172.20.0.113&lt;/li&gt;
&lt;li&gt;sz-pg-oam-docker-test-002.tendcloud.com：172.20.0.114&lt;/li&gt;
&lt;li&gt;sz-pg-oam-docker-test-003.tendcloud.com：172.20.0.115&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tls-认证文件&#34;&gt;TLS 认证文件&lt;/h2&gt;

&lt;p&gt;需要为 etcd 集群创建加密通信的 TLS 证书，这里复用以前创建的 kubernetes 证书&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cp ca.pem kubernetes-key.pem kubernetes.pem /etc/kubernetes/ssl
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;kubernetes 证书的 &lt;code&gt;hosts&lt;/code&gt; 字段列表中包含上面三台机器的 IP，否则后续证书校验会失败；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;下载二进制文件&#34;&gt;下载二进制文件&lt;/h2&gt;

&lt;p&gt;到 &lt;code&gt;https://github.com/coreos/etcd/releases&lt;/code&gt; 页面下载最新版本的二进制文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ https://github.com/coreos/etcd/releases/download/v3.1.5/etcd-v3.1.5-linux-amd64.tar.gz
$ tar -xvf etcd-v3.1.4-linux-amd64.tar.gz
$ sudo mv etcd-v3.1.4-linux-amd64/etcd* /root/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建-etcd-的-systemd-unit-文件&#34;&gt;创建 etcd 的 systemd unit 文件&lt;/h2&gt;

&lt;p&gt;注意替换 &lt;code&gt;ETCD_NAME&lt;/code&gt; 和 &lt;code&gt;INTERNAL_IP&lt;/code&gt; 变量的值；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export ETCD_NAME=sz-pg-oam-docker-test-001.tendcloud.com
$ export INTERNAL_IP=172.20.0.113
$ sudo mkdir -p /var/lib/etcd /var/lib/etcd
$ cat &amp;gt; etcd.service &amp;lt;&amp;lt;EOF
[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target
Documentation=https://github.com/coreos

[Service]
Type=notify
WorkingDirectory=/var/lib/etcd/
EnvironmentFile=-/etc/etcd/etcd.conf
ExecStart=/root/local/bin/etcd \\
  --name ${ETCD_NAME} \\
  --cert-file=/etc/kubernetes/ssl/kubernetes.pem \\
  --key-file=/etc/kubernetes/ssl/kubernetes-key.pem \\
  --peer-cert-file=/etc/kubernetes/ssl/kubernetes.pem \\
  --peer-key-file=/etc/kubernetes/ssl/kubernetes-key.pem \\
  --trusted-ca-file=/etc/kubernetes/ssl/ca.pem \\
  --peer-trusted-ca-file=/etc/kubernetes/ssl/ca.pem \\
  --initial-advertise-peer-urls https://${INTERNAL_IP}:2380 \\
  --listen-peer-urls https://${INTERNAL_IP}:2380 \\
  --listen-client-urls https://${INTERNAL_IP}:2379,https://127.0.0.1:2379 \\
  --advertise-client-urls https://${INTERNAL_IP}:2379 \\
  --initial-cluster-token etcd-cluster-0 \\
  --initial-cluster sz-pg-oam-docker-test-001.tendcloud.com=https://172.20.0.113:2380,sz-pg-oam-docker-test-002.tendcloud.com=https://172.20.0.114:2380,sz-pg-oam-docker-test-003.tendcloud.com=https://172.20.0.115:2380 \\
  --initial-cluster-state new \\
  --data-dir=/var/lib/etcd
Restart=on-failure
RestartSec=5
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;指定 &lt;code&gt;etcd&lt;/code&gt; 的工作目录为 &lt;code&gt;/var/lib/etcd&lt;/code&gt;，数据目录为 &lt;code&gt;/var/lib/etcd&lt;/code&gt;，需在启动服务前创建这两个目录；&lt;/li&gt;
&lt;li&gt;为了保证通信安全，需要指定 etcd 的公私钥(cert-file和key-file)、Peers 通信的公私钥和 CA 证书(peer-cert-file、peer-key-file、peer-trusted-ca-file)、客户端的CA证书（trusted-ca-file）；&lt;/li&gt;
&lt;li&gt;创建 &lt;code&gt;kubernetes.pem&lt;/code&gt; 证书时使用的 &lt;code&gt;kubernetes-csr.json&lt;/code&gt; 文件的 &lt;code&gt;hosts&lt;/code&gt; 字段&lt;strong&gt;包含所有 etcd 节点的 INTERNAL_IP&lt;/strong&gt;，否则证书校验会出错；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--initial-cluster-state&lt;/code&gt; 值为 &lt;code&gt;new&lt;/code&gt; 时，&lt;code&gt;--name&lt;/code&gt; 的参数值必须位于 &lt;code&gt;--initial-cluster&lt;/code&gt; 列表中；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;完整 unit 文件见：&lt;a href=&#34;./systemd/etcd.service&#34;&gt;etcd.service&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;启动-etcd-服务&#34;&gt;启动 etcd 服务&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo mv etcd.service /etc/systemd/system/
$ sudo systemctl daemon-reload
$ sudo systemctl enable etcd
$ sudo systemctl start etcd
$ systemctl status etcd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在所有的 kubernetes master 节点重复上面的步骤，直到所有机器的 etcd 服务都已启动。&lt;/p&gt;

&lt;h2 id=&#34;验证服务&#34;&gt;验证服务&lt;/h2&gt;

&lt;p&gt;在任一 kubernetes master 机器上执行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ etcdctl \
  --ca-file=/etc/kubernetes/ssl/ca.pem \
  --cert-file=/etc/kubernetes/ssl/kubernetes.pem \
  --key-file=/etc/kubernetes/ssl/kubernetes-key.pem \
  cluster-health
2017-04-11 15:17:09.082250 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated
2017-04-11 15:17:09.083681 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated
member 9a2ec640d25672e5 is healthy: got healthy result from https://172.20.0.115:2379
member bc6f27ae3be34308 is healthy: got healthy result from https://172.20.0.114:2379
member e5c92ea26c4edba0 is healthy: got healthy result from https://172.20.0.113:2379
cluster is healthy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果最后一行为 &lt;code&gt;cluster is healthy&lt;/code&gt; 时表示集群服务正常。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes安装之创建kubeconfig文件</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-create-kubeconfig/</link>
      <pubDate>Tue, 11 Apr 2017 14:34:54 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-create-kubeconfig/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2016050801.jpg&#34; alt=&#34;北海公园&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(题图：北海公园 May 8,2016)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;这是&lt;a href=&#34;https://github.com/rootsongjc/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;项目((fork自&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;opsnull&lt;/a&gt;))中的一篇文章，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;产生的kuberentes环境，生成&lt;strong&gt;kubeconfig&lt;/strong&gt;文件的过程。
&lt;code&gt;kubelet&lt;/code&gt;、&lt;code&gt;kube-proxy&lt;/code&gt; 等 Node 机器上的进程与 Master 机器的 &lt;code&gt;kube-apiserver&lt;/code&gt; 进程通信时需要认证和授权；
kubernetes 1.4 开始支持由 &lt;code&gt;kube-apiserver&lt;/code&gt; 为客户端生成 TLS 证书的 &lt;a href=&#34;https://kubernetes.io/docs/admin/kubelet-tls-bootstrapping/&#34;&gt;TLS Bootstrapping&lt;/a&gt; 功能，这样就不需要为每个客户端生成证书了；该功能&lt;strong&gt;当前仅支持为 &lt;code&gt;kubelet&lt;/code&gt;&lt;/strong&gt; 生成证书。&lt;/p&gt;

&lt;h2 id=&#34;创建-tls-bootstrapping-token&#34;&gt;创建 TLS Bootstrapping Token&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Token auth file&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Token可以是任意的包涵128 bit的字符串，可以使用安全的随机数发生器生成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export BOOTSTRAP_TOKEN=$(head -c 16 /dev/urandom | od -An -t x | tr -d &#39; &#39;)
cat &amp;gt; token.csv &amp;lt;&amp;lt;EOF
${BOOTSTRAP_TOKEN},kubelet-bootstrap,10001,&amp;quot;system:kubelet-bootstrap&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;后三行是一句，直接复制上面的脚本运行即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;将token.csv发到所有机器（Master 和 Node）的 &lt;code&gt;/etc/kubernetes/&lt;/code&gt; 目录。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$cp token.csv /etc/kubernetes/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建-kubelet-bootstrapping-kubeconfig-文件&#34;&gt;创建 kubelet bootstrapping kubeconfig 文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd /etc/kubernetes
$ export KUBE_APISERVER=&amp;quot;https://172.20.0.113:6443&amp;quot;
$ # 设置集群参数
$ kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=bootstrap.kubeconfig
$ # 设置客户端认证参数
$ kubectl config set-credentials kubelet-bootstrap \
  --token=${BOOTSTRAP_TOKEN} \
  --kubeconfig=bootstrap.kubeconfig
$ # 设置上下文参数
$ kubectl config set-context default \
  --cluster=kubernetes \
  --user=kubelet-bootstrap \
  --kubeconfig=bootstrap.kubeconfig
$ # 设置默认上下文
$ kubectl config use-context default --kubeconfig=bootstrap.kubeconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--embed-certs&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时表示将 &lt;code&gt;certificate-authority&lt;/code&gt; 证书写入到生成的 &lt;code&gt;bootstrap.kubeconfig&lt;/code&gt; 文件中；&lt;/li&gt;
&lt;li&gt;设置客户端认证参数时&lt;strong&gt;没有&lt;/strong&gt;指定秘钥和证书，后续由 &lt;code&gt;kube-apiserver&lt;/code&gt; 自动生成；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;创建-kube-proxy-kubeconfig-文件&#34;&gt;创建 kube-proxy kubeconfig 文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export KUBE_APISERVER=&amp;quot;https://172.20.0.113:6443&amp;quot;
$ # 设置集群参数
$ kubectl config set-cluster kubernetes \
  --certificate-authority=/etc/kubernetes/ssl/ca.pem \
  --embed-certs=true \
  --server=${KUBE_APISERVER} \
  --kubeconfig=kube-proxy.kubeconfig
$ # 设置客户端认证参数
$ kubectl config set-credentials kube-proxy \
  --client-certificate=/etc/kubernetes/ssl/kube-proxy.pem \
  --client-key=/etc/kubernetes/ssl/kube-proxy-key.pem \
  --embed-certs=true \
  --kubeconfig=kube-proxy.kubeconfig
$ # 设置上下文参数
$ kubectl config set-context default \
  --cluster=kubernetes \
  --user=kube-proxy \
  --kubeconfig=kube-proxy.kubeconfig
$ # 设置默认上下文
$ kubectl config use-context default --kubeconfig=kube-proxy.kubeconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;设置集群参数和客户端认证参数时 &lt;code&gt;--embed-certs&lt;/code&gt; 都为 &lt;code&gt;true&lt;/code&gt;，这会将 &lt;code&gt;certificate-authority&lt;/code&gt;、&lt;code&gt;client-certificate&lt;/code&gt; 和 &lt;code&gt;client-key&lt;/code&gt; 指向的证书文件内容写入到生成的 &lt;code&gt;kube-proxy.kubeconfig&lt;/code&gt; 文件中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kube-proxy.pem&lt;/code&gt; 证书中 CN 为 &lt;code&gt;system:kube-proxy&lt;/code&gt;，&lt;code&gt;kube-apiserver&lt;/code&gt; 预定义的 RoleBinding &lt;code&gt;cluster-admin&lt;/code&gt; 将User &lt;code&gt;system:kube-proxy&lt;/code&gt; 与 Role &lt;code&gt;system:node-proxier&lt;/code&gt; 绑定，该 Role 授予了调用 &lt;code&gt;kube-apiserver&lt;/code&gt; Proxy 相关 API 的权限；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;分发-kubeconfig-文件&#34;&gt;分发 kubeconfig 文件&lt;/h2&gt;

&lt;p&gt;将两个 kubeconfig 文件分发到所有 Node 机器的 &lt;code&gt;/etc/kubernetes/&lt;/code&gt; 目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cp bootstrap.kubeconfig kube-proxy.kubeconfig /etc/kubernetes/
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>开源微服务管理平台fabric8简介</title>
      <link>http://rootsongjc.github.io/blogs/fabric8-introduction/</link>
      <pubDate>Mon, 10 Apr 2017 21:39:00 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/fabric8-introduction/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://fabric8.io/images/fabric8_logo.svg&#34; alt=&#34;fabric8&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;无意中发现&lt;a href=&#34;https://github.com/fabric8io/fabric8&#34;&gt;Fabric8&lt;/a&gt;这个&lt;strong&gt;对于Java友好的开源微服务管理平台&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;其实这在这里发现的&lt;a href=&#34;http://blog.sonatype.com/achieving-ci/cd-with-kubernetes&#34;&gt;Achieving CI/CD with Kubernetes&lt;/a&gt;（by Ramit Surana,on February 17, 2017），其实是先在&lt;a href=&#34;https://www.slideshare.net/ramitsurana/achieving-cicd-with-kubernetes&#34;&gt;slideshare&lt;/a&gt;上看到的，pdf可以&lt;a href=&#34;http://olz1di9xf.bkt.clouddn.com/achiveving-ci-cd-with-kubernetes-ramit-surana.pdf&#34;&gt;在此下载&lt;/a&gt;，大小2.04M。&lt;/p&gt;

&lt;p&gt;大家可能以前听过一个叫做&lt;a href=&#34;https://github.com/fabric/fabric/&#34;&gt;fabric&lt;/a&gt;的工具，那是一个 Python (2.5-2.7) 库和命令行工具，用来流水线化执行 SSH 以部署应用或系统管理任务。所以大家不要把fabric8跟fabric搞混，虽然它们之间有一些共同点，但两者完全不是同一个东西，&lt;strong&gt;fabric8不是fabric的一个版本&lt;/strong&gt;。Fabric是用python开发的，fabric8是java开发的。&lt;/p&gt;

&lt;p&gt;如果你想了解简化Fabric可以看它的&lt;a href=&#34;http://fabric-docs-cn.readthedocs.io/zh_CN/latest/tutorial.html&#34;&gt;中文官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;fabric8简介&#34;&gt;Fabric8简介&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;fabric8&lt;/strong&gt;是一个开源&lt;strong&gt;集成开发平台&lt;/strong&gt;，为基于&lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt;和&lt;a href=&#34;https://jenkins.io/&#34;&gt;Jenkins&lt;/a&gt;的微服务提供&lt;a href=&#34;http://fabric8.io/guide/cdelivery.html&#34;&gt;持续发布&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;使用fabric可以很方便的通过&lt;a href=&#34;http://fabric8.io/guide/cdelivery.html&#34;&gt;Continuous Delivery pipelines&lt;/a&gt;创建、编译、部署和测试微服务，然后通过Continuous Improvement和&lt;a href=&#34;http://fabric8.io/guide/chat.html&#34;&gt;ChatOps&lt;/a&gt;运行和管理他们。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://fabric8.io/guide/fabric8DevOps.html&#34;&gt;Fabric8微服务平台&lt;/a&gt;提供：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/console.html&#34;&gt;Developer Console&lt;/a&gt;，是一个&lt;a href=&#34;http://www.infoq.com/cn/news/2014/11/seven-principles-rich-web-app&#34;&gt;富web应用&lt;/a&gt;，提供一个单页面来创建、编辑、编译、部署和测试微服务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/cdelivery.html&#34;&gt;Continuous Integration and Continous Delivery&lt;/a&gt;，使用 &lt;a href=&#34;https://jenkins.io/&#34;&gt;Jenkins&lt;/a&gt; with a &lt;a href=&#34;http://fabric8.io/guide/jenkinsWorkflowLibrary.html&#34;&gt;Jenkins Workflow Library&lt;/a&gt;更快和更可靠的交付软件。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/management.html&#34;&gt;Management&lt;/a&gt;，集中式管理&lt;a href=&#34;http://fabric8.io/guide/logging.html&#34;&gt;Logging&lt;/a&gt;、&lt;a href=&#34;http://fabric8.io/guide/metrics.html&#34;&gt;Metrics&lt;/a&gt;, &lt;a href=&#34;http://fabric8.io/guide/chat.html&#34;&gt;ChatOps&lt;/a&gt;、&lt;a href=&#34;http://fabric8.io/guide/chaosMonkey.html&#34;&gt;Chaos Monkey&lt;/a&gt;，使用&lt;a href=&#34;http://hawt.io/&#34;&gt;Hawtio&lt;/a&gt;和&lt;a href=&#34;http://jolokia.org/&#34;&gt;Jolokia&lt;/a&gt;管理Java Containers。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/ipaas.html&#34;&gt;Integration&lt;/a&gt; &lt;u&gt;&lt;em&gt;Integration Platform As A Service&lt;/em&gt;&lt;/u&gt; with &lt;a href=&#34;http://fabric8.io/guide/console.html&#34;&gt;deep visualisation&lt;/a&gt; of your &lt;a href=&#34;http://camel.apache.org/&#34;&gt;Apache Camel&lt;/a&gt; integration services, an &lt;a href=&#34;http://fabric8.io/guide/apiRegistry.html&#34;&gt;API Registry&lt;/a&gt; to view of all your RESTful and SOAP APIs and &lt;a href=&#34;http://fabric8.io/guide/fabric8MQ.html&#34;&gt;Fabric8 MQ&lt;/a&gt; provides &lt;u&gt;&lt;em&gt;Messaging As A Service&lt;/em&gt;&lt;/u&gt; based on &lt;a href=&#34;http://activemq.apache.org/&#34;&gt;Apache ActiveMQ&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/tools.html&#34;&gt;Java Tools&lt;/a&gt; 帮助Java应用使用&lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt;:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/mavenPlugin.html&#34;&gt;Maven Plugin&lt;/a&gt; for working with &lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt; ，这真是极好的&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/testing.html&#34;&gt;Integration and System Testing&lt;/a&gt; of &lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt; resources easily inside &lt;a href=&#34;http://junit.org/&#34;&gt;JUnit&lt;/a&gt; with &lt;a href=&#34;http://arquillian.org/&#34;&gt;Arquillian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/javaLibraries.html&#34;&gt;Java Libraries&lt;/a&gt; and support for &lt;a href=&#34;http://fabric8.io/guide/cdi.html&#34;&gt;CDI&lt;/a&gt; extensions for working with &lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;fabric8微服务平台&#34;&gt;Fabric8微服务平台&lt;/h2&gt;

&lt;p&gt;Fabric8提供了一个完全集成的开源微服务平台，可在任何的&lt;a href=&#34;http://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt;和&lt;a href=&#34;http://www.openshift.org/&#34;&gt;OpenShift&lt;/a&gt;环境中开箱即用。&lt;/p&gt;

&lt;p&gt;整个平台是基于微服务而且是模块化的，你可以按照微服务的方式来使用它。&lt;/p&gt;

&lt;p&gt;微服务平台提供的服务有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开发者控制台，这是一个富Web应用程序，它提供了一个单一的页面来创建、编辑、编译、部署和测试微服务。&lt;/li&gt;
&lt;li&gt;持续集成和持续交付，帮助团队以更快更可靠的方式交付软件，可以使用以下开源软件：

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jenkins.io/&#34;&gt;Jenkins&lt;/a&gt;：CI／CD pipeline&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sonatype.org/nexus/&#34;&gt;Nexus&lt;/a&gt;： 组件库&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gogs.io/&#34;&gt;Gogs&lt;/a&gt;：git代码库&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sonarqube.org/&#34;&gt;SonarQube&lt;/a&gt;：代码质量维护平台&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/jenkinsWorkflowLibrary.html&#34;&gt;Jenkins Workflow Library&lt;/a&gt;：在不同的项目中复用&lt;a href=&#34;https://github.com/fabric8io/jenkins-workflow-library&#34;&gt;Jenkins Workflow scripts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/fabric8YmlFile.html&#34;&gt;Fabric8.yml&lt;/a&gt;：为每个项目、存储库、聊天室、工作流脚本和问题跟踪器提供一个配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/chat.html&#34;&gt;ChatOps&lt;/a&gt;：通过使用&lt;a href=&#34;https://hubot.github.com/&#34;&gt;hubot&lt;/a&gt;来开发和管理，能够让你的团队拥抱DevOps，通过聊天和系统通知的方式来&lt;a href=&#34;https://github.com/fabric8io/fabric8-jenkins-workflow-steps#hubotapprove&#34;&gt;approval of release promotion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/chaosMonkey.html&#34;&gt;Chaos Monkey&lt;/a&gt;：通过干掉&lt;a href=&#34;http://fabric8.io/guide/pods.html&#34;&gt;pods&lt;/a&gt;来测试系统健壮性和可靠性&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/management.html&#34;&gt;管理&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/logging.html&#34;&gt;日志&lt;/a&gt; 统一集群日志和可视化查看状态&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fabric8.io/guide/metrics.html&#34;&gt;metris&lt;/a&gt; 可查看历史metrics和可视化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://hao.jobbole.com/fabric8/&#34;&gt;fabric8：容器集成平台——伯乐在线&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI0NjI4MDg5MQ==&amp;amp;mid=2715290731&amp;amp;idx=1&amp;amp;sn=f1fcacb9aa4f1f3037918f03c29c0465&amp;amp;chksm=cd6d0bbffa1a82a978ccc0405afa295bd9265bd9f89f2217c80f48e1c497b25d1f24090108af&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0410RTk3PKkxlFlLbCVlOKMK#rd&#34;&gt;Kubernetes部署微服务速成指南——&lt;em&gt;2017-03-09&lt;/em&gt; &lt;em&gt;徐薛彪&lt;/em&gt; 容器时代微信公众号&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面那篇文章是翻译的，英文原文地址：&lt;a href=&#34;http://www.eclipse.org/community/eclipse_newsletter/2017/january/article2.php&#34;&gt;Quick Guide to Developing Microservices on Kubernetes and Docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://fabric8.io/&#34;&gt;fabric8官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://fabric8.io/guide/getStarted/gofabric8.html&#34;&gt;fabric8 get started&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;&lt;del&gt;我在自己笔记本上装了个minikube，试玩感受将在后续发表。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;试玩时需要科学上网。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$gofabric8 start
using the executable /usr/local/bin/minikube
minikube already running
using the executable /usr/local/bin/kubectl
Switched to context &amp;quot;minikube&amp;quot;.
Deploying fabric8 to your Kubernetes installation at https://192.168.99.100:8443 for domain  in namespace default

Loading fabric8 releases from maven repository:https://repo1.maven.org/maven2/
Deploying package: platform version: 2.4.24

Now about to install package https://repo1.maven.org/maven2/io/fabric8/platform/packages/fabric8-platform/2.4.24/fabric8-platform-2.4.24-kubernetes.yml
Processing resource kind: Namespace in namespace default name user-secrets-source-admin
Found namespace on kind Secret of user-secrets-source-adminProcessing resource kind: Secret in namespace user-secrets-source-admin name default-gogs-git
Processing resource kind: Secret in namespace default name jenkins-docker-cfg
Processing resource kind: Secret in namespace default name jenkins-git-ssh
Processing resource kind: Secret in namespace default name jenkins-hub-api-token
Processing resource kind: Secret in namespace default name jenkins-master-ssh
Processing resource kind: Secret in namespace default name jenkins-maven-settings
Processing resource kind: Secret in namespace default name jenkins-release-gpg
Processing resource kind: Secret in namespace default name jenkins-ssh-config
Processing resource kind: ServiceAccount in namespace default name configmapcontroller
Processing resource kind: ServiceAccount in namespace default name exposecontroller
Processing resource kind: ServiceAccount in namespace default name fabric8
Processing resource kind: ServiceAccount in namespace default name gogs
Processing resource kind: ServiceAccount in namespace default name jenkins
Processing resource kind: Service in namespace default name fabric8
Processing resource kind: Service in namespace default name fabric8-docker-registry
Processing resource kind: Service in namespace default name fabric8-forge
Processing resource kind: Service in namespace default name gogs
...
-------------------------

Default GOGS admin username/password = gogsadmin/RedHat$1

Checking if PersistentVolumeClaims bind to a PersistentVolume ....
Downloading images and waiting to open the fabric8 console...

-------------------------
.....................................................
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动了半天一直是这种状态：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Waiting, endpoint for service is not ready yet...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我一看下载下来的&lt;code&gt;https://repo1.maven.org/maven2/io/fabric8/platform/packages/fabric8-platform/2.4.24/fabric8-platform-2.4.24-kubernetes.yml&lt;/code&gt;文件，真是&lt;strong&gt;蔚为壮观&lt;/strong&gt;啊，足足有&lt;strong&gt;24712行&lt;/strong&gt;(这里面都是实际配置，没有配置充行数)，使用了如下这些docker镜像，足足有&lt;strong&gt;53个docker镜像&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fabric8/alpine-caddy:2.2.311
fabric8/apiman-gateway:2.2.168
fabric8/apiman:2.2.168
fabric8/chaos-monkey:2.2.311
fabric8/configmapcontroller:2.3.5
fabric8/eclipse-orion:2.2.311
fabric8/elasticsearch-k8s:2.3.4
fabric8/elasticsearch-logstash-template:2.2.311
fabric8/elasticsearch-v1:2.2.168
fabric8/exposecontroller:2.3.2
fabric8/fabric8-console:2.2.199
fabric8/fabric8-forge:2.3.88
fabric8/fabric8-kiwiirc:2.2.311
fabric8/fluentd-kubernetes:v1.19
fabric8/gerrit:2.2.311
fabric8/git-collector:2.2.311
fabric8/gogs:v0.9.97
fabric8/grafana:2.6.1
fabric8/hubot-irc:2.2.311
fabric8/hubot-letschat:v1.0.0
fabric8/hubot-notifier:2.2.311
fabric8/hubot-slack:2.2.311
fabric8/jenkins-docker:2.2.311
fabric8/jenkinshift:2.2.199
fabric8/kafka:2.2.153
fabric8/kibana-config:2.2.311
fabric8/kibana4:v4.5.3
fabric8/lets-chat:2.2.311
fabric8/maven-builder:2.2.311
fabric8/message-broker:2.2.168
fabric8/message-gateway:2.2.168
fabric8/nexus:2.2.311
fabric8/taiga-back:2.2.311
fabric8/taiga-front:2.2.311
fabric8/turbine-server:1.0.28
fabric8/zookeeper:2.2.153
fabric8/zookeeper:2.2.168
funktion/funktion-nodejs-runtime:1.0.3
funktion/funktion:1.0.9
gitlab/gitlab-ce
jboss/keycloak:2.2.0.Final
jfrog-docker-registry.bintray.io/artifactory/artifactory-oss
jimmidyson/configmap-reload:v0.1
manageiq/manageiq:latest
mongo
mysql:5.7
nginxdemos/nginx-ingress:0.3.1
openzipkin/zipkin:1.13.0
postgres
prom/blackbox-exporter:master
prom/node-exporter
prom/prometheus:v1.3.1
registry:2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你们感受下吧，我果断放弃了在自己笔记本上安装的念头。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes安装之证书验证</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-tls-certificate/</link>
      <pubDate>Mon, 10 Apr 2017 17:28:41 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-tls-certificate/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2014082502.jpg&#34; alt=&#34;颐和园&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：铜牛@颐和园 Aug 25,2014）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;昨晚（Apr 9,2017）金山软件的&lt;a href=&#34;https://github.com/opsnull&#34;&gt;opsnull&lt;/a&gt;发布了一个开源项目&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster&#34;&gt;和我一步步部署kubernetes集群&lt;/a&gt;，下文是结合我&lt;a href=&#34;http://rootsongjc.github.io/tags/kubernetes/&#34;&gt;之前部署kubernetes的过程&lt;/a&gt;打造的kubernetes环境和opsnull的文章&lt;a href=&#34;https://github.com/opsnull/follow-me-install-kubernetes-cluster/blob/master/01-TLS%E8%AF%81%E4%B9%A6%E5%92%8C%E7%A7%98%E9%92%A5.md&#34;&gt;创建 kubernetes 各组件 TLS 加密通信的证书和秘钥&lt;/a&gt;的实践。之前安装过程中一直使用的是非加密方式，一直到后来&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-fluentd-elasticsearch-installation/&#34;&gt;使用Fluentd和ElasticSearch收集Kubernetes集群日志&lt;/a&gt;时发现有权限验证问题，所以为了深入研究kubernentes。&lt;/p&gt;

&lt;h2 id=&#34;kubernentes中的身份验证&#34;&gt;Kubernentes中的身份验证&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;kubernetes&lt;/code&gt; 系统的各组件需要使用 &lt;code&gt;TLS&lt;/code&gt; 证书对通信进行加密，本文档使用 &lt;code&gt;CloudFlare&lt;/code&gt; 的 PKI 工具集 &lt;a href=&#34;https://github.com/cloudflare/cfssl&#34;&gt;cfssl&lt;/a&gt; 来生成 Certificate Authority (CA) 和其它证书；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;生成的 CA 证书和秘钥文件如下：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ca-key.pem&lt;/li&gt;
&lt;li&gt;ca.pem&lt;/li&gt;
&lt;li&gt;kubernetes-key.pem&lt;/li&gt;
&lt;li&gt;kubernetes.pem&lt;/li&gt;
&lt;li&gt;kube-proxy.pem&lt;/li&gt;
&lt;li&gt;kube-proxy-key.pem&lt;/li&gt;
&lt;li&gt;admin.pem&lt;/li&gt;
&lt;li&gt;admin-key.pem&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;使用证书的组件如下：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;etcd：使用 ca.pem、kubernetes-key.pem、kubernetes.pem；&lt;/li&gt;
&lt;li&gt;kube-apiserver：使用 ca.pem、kubernetes-key.pem、kubernetes.pem；&lt;/li&gt;
&lt;li&gt;kubelet：使用 ca.pem；&lt;/li&gt;
&lt;li&gt;kube-proxy：使用 ca.pem、kube-proxy-key.pem、kube-proxy.pem；&lt;/li&gt;
&lt;li&gt;kubectl：使用 ca.pem、admin-key.pem、admin.pem；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;kube-controller&lt;/code&gt;、&lt;code&gt;kube-scheduler&lt;/code&gt; 当前需要和 &lt;code&gt;kube-apiserver&lt;/code&gt; 部署在同一台机器上且使用非安全端口通信，故不需要证书。&lt;/p&gt;

&lt;h2 id=&#34;安装-cfssl&#34;&gt;安装 &lt;code&gt;CFSSL&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;方式一：直接使用二进制源码包安装&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64
$ chmod +x cfssl_linux-amd64
$ sudo mv cfssl_linux-amd64 /root/local/bin/cfssl

$ wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64
$ chmod +x cfssljson_linux-amd64
$ sudo mv cfssljson_linux-amd64 /root/local/bin/cfssljson

$ wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64
$ chmod +x cfssl-certinfo_linux-amd64
$ sudo mv cfssl-certinfo_linux-amd64 /root/local/bin/cfssl-certinfo

$ export PATH=/root/local/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;方式二：使用go命令安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们的系统中安装了Go1.7.5，使用以下命令安装更快捷：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$go get -u github.com/cloudflare/cfssl/cmd/...
$echo $GOPATH
/usr/local
$ls /usr/local/bin/cfssl*
cfssl cfssl-bundle cfssl-certinfo cfssljson cfssl-newkey cfssl-scan
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;$GOPATH/bin&lt;/code&gt;目录下得到以cfssl开头的几个命令。&lt;/p&gt;

&lt;h2 id=&#34;创建-ca-certificate-authority&#34;&gt;创建 CA (Certificate Authority)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;创建 CA 配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir /root/ssl
$ cd /root/ssl
$ cfssl print-defaults config &amp;gt; config.json
$ cfssl print-defaults csr &amp;gt; csr.json
$ cat ca-config.json
{
  &amp;quot;signing&amp;quot;: {
    &amp;quot;default&amp;quot;: {
      &amp;quot;expiry&amp;quot;: &amp;quot;8760h&amp;quot;
    },
    &amp;quot;profiles&amp;quot;: {
      &amp;quot;kubernetes&amp;quot;: {
        &amp;quot;usages&amp;quot;: [
            &amp;quot;signing&amp;quot;,
            &amp;quot;key encipherment&amp;quot;,
            &amp;quot;server auth&amp;quot;,
            &amp;quot;client auth&amp;quot;
        ],
        &amp;quot;expiry&amp;quot;: &amp;quot;8760h&amp;quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字段说明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ca-config.json&lt;/code&gt;：可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;signing&lt;/code&gt;：表示该证书可用于签名其它证书；生成的 ca.pem 证书中 &lt;code&gt;CA=TRUE&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server auth&lt;/code&gt;：表示client可以用该 CA 对server提供的证书进行验证；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;client auth&lt;/code&gt;：表示server可以用该CA对client提供的证书进行验证；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;创建 CA 证书签名请求&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat ca-csr.json
{
  &amp;quot;CN&amp;quot;: &amp;quot;kubernetes&amp;quot;,
  &amp;quot;key&amp;quot;: {
    &amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
    &amp;quot;size&amp;quot;: 2048
  },
  &amp;quot;names&amp;quot;: [
    {
      &amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
      &amp;quot;ST&amp;quot;: &amp;quot;BeiJing&amp;quot;,
      &amp;quot;L&amp;quot;: &amp;quot;BeiJing&amp;quot;,
      &amp;quot;O&amp;quot;: &amp;quot;k8s&amp;quot;,
      &amp;quot;OU&amp;quot;: &amp;quot;System&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;CN&amp;rdquo;：&lt;code&gt;Common Name&lt;/code&gt;，kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)；浏览器使用该字段验证网站是否合法；&lt;/li&gt;
&lt;li&gt;&amp;ldquo;O&amp;rdquo;：&lt;code&gt;Organization&lt;/code&gt;，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;生成 CA 证书和私钥&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca
$ ls ca*
ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建-kubernetes-证书&#34;&gt;创建 kubernetes 证书&lt;/h2&gt;

&lt;p&gt;创建 kubernetes 证书签名请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat kubernetes-csr.json
{
    &amp;quot;CN&amp;quot;: &amp;quot;kubernetes&amp;quot;,
    &amp;quot;hosts&amp;quot;: [
      &amp;quot;127.0.0.1&amp;quot;,
      &amp;quot;172.20.0.112&amp;quot;,
      &amp;quot;172.20.0.113&amp;quot;,
      &amp;quot;172.20.0.114&amp;quot;,
      &amp;quot;172.20.0.115&amp;quot;,
      &amp;quot;10.254.0.1&amp;quot;,
      &amp;quot;kubernetes&amp;quot;,
      &amp;quot;kubernetes.default&amp;quot;,
      &amp;quot;kubernetes.default.svc&amp;quot;,
      &amp;quot;kubernetes.default.svc.cluster&amp;quot;,
      &amp;quot;kubernetes.default.svc.cluster.local&amp;quot;
    ],
    &amp;quot;key&amp;quot;: {
        &amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
        &amp;quot;size&amp;quot;: 2048
    },
    &amp;quot;names&amp;quot;: [
        {
            &amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
            &amp;quot;ST&amp;quot;: &amp;quot;BeiJing&amp;quot;,
            &amp;quot;L&amp;quot;: &amp;quot;BeiJing&amp;quot;,
            &amp;quot;O&amp;quot;: &amp;quot;k8s&amp;quot;,
            &amp;quot;OU&amp;quot;: &amp;quot;System&amp;quot;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果 hosts 字段不为空则需要指定授权使用该证书的 &lt;strong&gt;IP 或域名列表&lt;/strong&gt;，由于该证书后续被 &lt;code&gt;etcd&lt;/code&gt; 集群和 &lt;code&gt;kubernetes master&lt;/code&gt; 集群使用，所以上面分别指定了 &lt;code&gt;etcd&lt;/code&gt; 集群、&lt;code&gt;kubernetes master&lt;/code&gt; 集群的主机 IP 和 &lt;strong&gt;&lt;code&gt;kubernetes&lt;/code&gt; 服务的服务 IP&lt;/strong&gt;（一般是 &lt;code&gt;kue-apiserver&lt;/code&gt; 指定的 &lt;code&gt;service-cluster-ip-range&lt;/code&gt; 网段的第一个IP，如 10.254.0.1。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;生成 kubernetes 证书和私钥&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes kubernetes-csr.json | cfssljson -bare kubernetes
$ ls kuberntes*
kubernetes.csr  kubernetes-csr.json  kubernetes-key.pem  kubernetes.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者直接在命令行上指定相关参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo &#39;{&amp;quot;CN&amp;quot;:&amp;quot;kubernetes&amp;quot;,&amp;quot;hosts&amp;quot;:[&amp;quot;&amp;quot;],&amp;quot;key&amp;quot;:{&amp;quot;algo&amp;quot;:&amp;quot;rsa&amp;quot;,&amp;quot;size&amp;quot;:2048}}&#39; | cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes -hostname=&amp;quot;127.0.0.1,10.64.3.7,10.254.0.1,kubernetes,kubernetes.default&amp;quot; - | cfssljson -bare kubernetes
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建-admin-证书&#34;&gt;创建 admin 证书&lt;/h2&gt;

&lt;p&gt;创建 admin 证书签名请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat admin-csr.json
{
  &amp;quot;CN&amp;quot;: &amp;quot;admin&amp;quot;,
  &amp;quot;hosts&amp;quot;: [],
  &amp;quot;key&amp;quot;: {
    &amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
    &amp;quot;size&amp;quot;: 2048
  },
  &amp;quot;names&amp;quot;: [
    {
      &amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
      &amp;quot;ST&amp;quot;: &amp;quot;BeiJing&amp;quot;,
      &amp;quot;L&amp;quot;: &amp;quot;BeiJing&amp;quot;,
      &amp;quot;O&amp;quot;: &amp;quot;system:masters&amp;quot;,
      &amp;quot;OU&amp;quot;: &amp;quot;System&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;后续 &lt;code&gt;kube-apiserver&lt;/code&gt; 使用 &lt;code&gt;RBAC&lt;/code&gt; 对客户端(如 &lt;code&gt;kubelet&lt;/code&gt;、&lt;code&gt;kube-proxy&lt;/code&gt;、&lt;code&gt;Pod&lt;/code&gt;)请求进行授权；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kube-apiserver&lt;/code&gt; 预定义了一些 &lt;code&gt;RBAC&lt;/code&gt; 使用的 &lt;code&gt;RoleBindings&lt;/code&gt;，如 &lt;code&gt;cluster-admin&lt;/code&gt; 将 Group &lt;code&gt;system:masters&lt;/code&gt; 与 Role &lt;code&gt;cluster-admin&lt;/code&gt; 绑定，该 Role 授予了调用&lt;code&gt;kube-apiserver&lt;/code&gt; 的&lt;strong&gt;所有 API&lt;/strong&gt;的权限；&lt;/li&gt;
&lt;li&gt;OU 指定该证书的 Group 为 &lt;code&gt;system:masters&lt;/code&gt;，&lt;code&gt;kubelet&lt;/code&gt; 使用该证书访问 &lt;code&gt;kube-apiserver&lt;/code&gt; 时 ，由于证书被 CA 签名，所以认证通过，同时由于证书用户组为经过预授权的 &lt;code&gt;system:masters&lt;/code&gt;，所以被授予访问所有 API 的权限；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生成 admin 证书和私钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes admin-csr.json | cfssljson -bare admin
$ ls admin*
admin.csr  admin-csr.json  admin-key.pem  admin.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建-kube-proxy-证书&#34;&gt;创建 kube-proxy 证书&lt;/h2&gt;

&lt;p&gt;创建 kube-proxy 证书签名请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat kube-proxy-csr.json
{
  &amp;quot;CN&amp;quot;: &amp;quot;system:kube-proxy&amp;quot;,
  &amp;quot;hosts&amp;quot;: [],
  &amp;quot;key&amp;quot;: {
    &amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
    &amp;quot;size&amp;quot;: 2048
  },
  &amp;quot;names&amp;quot;: [
    {
      &amp;quot;C&amp;quot;: &amp;quot;CN&amp;quot;,
      &amp;quot;ST&amp;quot;: &amp;quot;BeiJing&amp;quot;,
      &amp;quot;L&amp;quot;: &amp;quot;BeiJing&amp;quot;,
      &amp;quot;O&amp;quot;: &amp;quot;k8s&amp;quot;,
      &amp;quot;OU&amp;quot;: &amp;quot;System&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;CN 指定该证书的 User 为 &lt;code&gt;system:kube-proxy&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kube-apiserver&lt;/code&gt; 预定义的 RoleBinding &lt;code&gt;cluster-admin&lt;/code&gt; 将User &lt;code&gt;system:kube-proxy&lt;/code&gt; 与 Role &lt;code&gt;system:node-proxier&lt;/code&gt; 绑定，该 Role 授予了调用 &lt;code&gt;kube-apiserver&lt;/code&gt; Proxy 相关 API 的权限；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生成 kube-proxy 客户端证书和私钥&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes  kube-proxy-csr.json | cfssljson -bare kube-proxy
$ ls kube-proxy*
kube-proxy.csr  kube-proxy-csr.json  kube-proxy-key.pem  kube-proxy.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;校验证书&#34;&gt;校验证书&lt;/h2&gt;

&lt;p&gt;以 kubernetes 证书为例&lt;/p&gt;

&lt;h3 id=&#34;使用-opsnssl-命令&#34;&gt;使用 &lt;code&gt;opsnssl&lt;/code&gt; 命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ openssl x509  -noout -text -in  kubernetes.pem
...
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=CN, ST=BeiJing, L=BeiJing, O=k8s, OU=System, CN=Kubernetes
        Validity
            Not Before: Apr  5 05:36:00 2017 GMT
            Not After : Apr  5 05:36:00 2018 GMT
        Subject: C=CN, ST=BeiJing, L=BeiJing, O=k8s, OU=System, CN=kubernetes
...
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            X509v3 Extended Key Usage:
                TLS Web Server Authentication, TLS Web Client Authentication
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Subject Key Identifier:
                DD:52:04:43:10:13:A9:29:24:17:3A:0E:D7:14:DB:36:F8:6C:E0:E0
            X509v3 Authority Key Identifier:
                keyid:44:04:3B:60:BD:69:78:14:68:AF:A0:41:13:F6:17:07:13:63:58:CD

            X509v3 Subject Alternative Name:
                DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster, DNS:kubernetes.default.svc.cluster.local, IP Address:127.0.0.1, IP Address:172.20.0.112, IP Address:172.20.0.113, IP Address:172.20.0.114, IP Address:172.20.0.115, IP Address:10.254.0.1
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;确认 &lt;code&gt;Issuer&lt;/code&gt; 字段的内容和 &lt;code&gt;ca-csr.json&lt;/code&gt; 一致；&lt;/li&gt;
&lt;li&gt;确认 &lt;code&gt;Subject&lt;/code&gt; 字段的内容和 &lt;code&gt;kubernetes-csr.json&lt;/code&gt; 一致；&lt;/li&gt;
&lt;li&gt;确认 &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; 字段的内容和 &lt;code&gt;kubernetes-csr.json&lt;/code&gt; 一致；&lt;/li&gt;
&lt;li&gt;确认 &lt;code&gt;X509v3 Key Usage、Extended Key Usage&lt;/code&gt; 字段的内容和 &lt;code&gt;ca-config.json&lt;/code&gt; 中 &lt;code&gt;kubernetes&lt;/code&gt; profile 一致；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用-cfssl-certinfo-命令&#34;&gt;使用 &lt;code&gt;cfssl-certinfo&lt;/code&gt; 命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cfssl-certinfo -cert kubernetes.pem
...
{
  &amp;quot;subject&amp;quot;: {
    &amp;quot;common_name&amp;quot;: &amp;quot;kubernetes&amp;quot;,
    &amp;quot;country&amp;quot;: &amp;quot;CN&amp;quot;,
    &amp;quot;organization&amp;quot;: &amp;quot;k8s&amp;quot;,
    &amp;quot;organizational_unit&amp;quot;: &amp;quot;System&amp;quot;,
    &amp;quot;locality&amp;quot;: &amp;quot;BeiJing&amp;quot;,
    &amp;quot;province&amp;quot;: &amp;quot;BeiJing&amp;quot;,
    &amp;quot;names&amp;quot;: [
      &amp;quot;CN&amp;quot;,
      &amp;quot;BeiJing&amp;quot;,
      &amp;quot;BeiJing&amp;quot;,
      &amp;quot;k8s&amp;quot;,
      &amp;quot;System&amp;quot;,
      &amp;quot;kubernetes&amp;quot;
    ]
  },
  &amp;quot;issuer&amp;quot;: {
    &amp;quot;common_name&amp;quot;: &amp;quot;Kubernetes&amp;quot;,
    &amp;quot;country&amp;quot;: &amp;quot;CN&amp;quot;,
    &amp;quot;organization&amp;quot;: &amp;quot;k8s&amp;quot;,
    &amp;quot;organizational_unit&amp;quot;: &amp;quot;System&amp;quot;,
    &amp;quot;locality&amp;quot;: &amp;quot;BeiJing&amp;quot;,
    &amp;quot;province&amp;quot;: &amp;quot;BeiJing&amp;quot;,
    &amp;quot;names&amp;quot;: [
      &amp;quot;CN&amp;quot;,
      &amp;quot;BeiJing&amp;quot;,
      &amp;quot;BeiJing&amp;quot;,
      &amp;quot;k8s&amp;quot;,
      &amp;quot;System&amp;quot;,
      &amp;quot;Kubernetes&amp;quot;
    ]
  },
  &amp;quot;serial_number&amp;quot;: &amp;quot;174360492872423263473151971632292895707129022309&amp;quot;,
  &amp;quot;sans&amp;quot;: [
    &amp;quot;kubernetes&amp;quot;,
    &amp;quot;kubernetes.default&amp;quot;,
    &amp;quot;kubernetes.default.svc&amp;quot;,
    &amp;quot;kubernetes.default.svc.cluster&amp;quot;,
    &amp;quot;kubernetes.default.svc.cluster.local&amp;quot;,
    &amp;quot;127.0.0.1&amp;quot;,
    &amp;quot;10.64.3.7&amp;quot;,
    &amp;quot;10.254.0.1&amp;quot;
  ],
  &amp;quot;not_before&amp;quot;: &amp;quot;2017-04-05T05:36:00Z&amp;quot;,
  &amp;quot;not_after&amp;quot;: &amp;quot;2018-04-05T05:36:00Z&amp;quot;,
  &amp;quot;sigalg&amp;quot;: &amp;quot;SHA256WithRSA&amp;quot;,
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;分发证书&#34;&gt;分发证书&lt;/h2&gt;

&lt;p&gt;将生成的证书和秘钥文件（后缀名为&lt;code&gt;.pem&lt;/code&gt;）拷贝到所有机器的 &lt;code&gt;/etc/kubernetes/ssl&lt;/code&gt; 目录下备用；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo mkdir -p /etc/kubernetes/ssl
$ sudo cp *.pem /etc/kubernetes/ssl
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coreos.com/os/docs/latest/generate-self-signed-certificates.html&#34;&gt;Generate self-signed certificates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kelseyhightower/kubernetes-the-hard-way/blob/master/docs/02-certificate-authority.md&#34;&gt;Setting up a Certificate Authority and Creating TLS Certificates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/kaushal/2012/02/17/client-certificates-vs-server-certificates/&#34;&gt;Client Certificates V/s Server Certificates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.jobbole.com/104919/&#34;&gt;数字证书及 CA 的扫盲介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>《云计算技术架构与实践（第二版）》读后感</title>
      <link>http://rootsongjc.github.io/blogs/cloud-computing-architecture-practice/</link>
      <pubDate>Sat, 08 Apr 2017 12:29:36 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/cloud-computing-architecture-practice/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20150406003.jpg&#34; alt=&#34;长江三峡&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：长江三峡大坝@湖北宜昌 Apr 6,2015）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近（2017年3月）友人推荐了一本书，是华为的工程师写的《云计算架构与实践第二版》，正好在网上找到了这本书的pdf，分享给大家，&lt;a href=&#34;http://olz1di9xf.bkt.clouddn.com/docs/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E8%B7%B5%E7%AC%AC2%E7%89%88.pdf&#34;&gt;点这里下载&lt;/a&gt;，书是文字版的，大小13.04MB，除了章节顺序有点问题外没有其他什么问题。这是该书的第二版，第一版2014年9月出版，第二版2016年9月出版，第二版的编者团队居然有50人之多😓&lt;/p&gt;

&lt;p&gt;第二版分享了华为在云计算核心竞争力构建与价值转换方面的经验与建议，并补充了业界在公有云、私有云、行业云以及电信网络云化商用落地与技术应用方面的成功优秀实践。增加了对Docker容器与微服务敏捷迭代、大数据与数据库云化、行业建模与机器学习算法、混合云与管理自动化编排、云生态建设等方面的介绍。&lt;/p&gt;

&lt;h2 id=&#34;第1章-云计算的商业动力与技术趋势&#34;&gt;第1章 云计算的商业动力与技术趋势&lt;/h2&gt;

&lt;p&gt;​&lt;br /&gt;
​&lt;br /&gt;
​&lt;/p&gt;

&lt;p&gt;​&lt;br /&gt;
​&lt;br /&gt;
​&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用Fluentd和ElasticSearch收集Kubernetes集群日志</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-fluentd-elasticsearch-installation/</link>
      <pubDate>Fri, 07 Apr 2017 20:13:24 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-fluentd-elasticsearch-installation/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20160430080.jpg&#34; alt=&#34;古北水镇&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：码头@古北水镇 Apr 30,2016）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-installation-on-centos/&#34;&gt;安装好了Kubernetes集群&lt;/a&gt;、&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-network-config/&#34;&gt;配置好了flannel网络&lt;/a&gt;、&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-dashboard-installation/&#34;&gt;安装了Kubernetes Dashboard&lt;/a&gt;和&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-heapster-installation/&#34;&gt;配置Heapster监控插件&lt;/a&gt;后，还有一项重要的工作，为了调试和故障排查，还需要进行日志收集工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;官方文档&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/concepts/cluster-administration/logging/&#34;&gt;Kubernetes Logging and Monitoring Cluster Activity&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/docs/tasks/debug-application-cluster/logging-elasticsearch-kibana/&#34;&gt;Logging Using Elasticsearch and Kibana&lt;/a&gt;：不过这篇文章是在GCE上配置的，参考价值不大。&lt;/p&gt;

&lt;h2 id=&#34;容器日志的存在形式&#34;&gt;容器日志的存在形式&lt;/h2&gt;

&lt;p&gt;目前容器日志有两种输出形式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;stdout,stderr标准输出&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这种形式的日志输出我们可以直接使用&lt;code&gt;docker logs&lt;/code&gt;查看日志，kubernetes集群中同样可以使用&lt;code&gt;kubectl logs&lt;/code&gt;类似的形式查看日志。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;日志文件记录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这种日志输出我们无法从以上方法查看日志内容，只能&lt;code&gt;tail&lt;/code&gt;日志文件查看。&lt;/p&gt;

&lt;h2 id=&#34;fluentd介绍&#34;&gt;Fluentd介绍&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fluent/fluentd&#34;&gt;Fluentd&lt;/a&gt;是使用Ruby编写的，通过在后端系统之间提供&lt;strong&gt;统一的日志记录层&lt;/strong&gt;来从后端系统中解耦数据源。
此层允许开发人员和数据分析人员在生成日志时使用多种类型的日志。
统一的日志记录层可以让您和您的组织更好地使用数据，并更快地在您的软件上进行迭代。
也就是说fluentd是一个面向多种数据来源以及面向多种数据出口的日志收集器。另外它附带了日志转发的功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/c4abfe337c0b54b36f81bce78481f8965acbc7a9/687474703a2f2f646f63732e666c75656e74642e6f72672f696d616765732f666c75656e74642d6172636869746563747572652e706e67&#34; alt=&#34;arch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Fluentd收集的&lt;strong&gt;event&lt;/strong&gt;由以下几个方面组成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tag&lt;/strong&gt;：字符串，中间用点隔开，如myapp.access&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time&lt;/strong&gt;：UNIX时间格式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Record&lt;/strong&gt;：JSON格式&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;fluentd特点&#34;&gt;Fluentd特点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;部署简单灵活&lt;/li&gt;
&lt;li&gt;开源&lt;/li&gt;
&lt;li&gt;经过验证的可靠性和性能&lt;/li&gt;
&lt;li&gt;社区支持，插件较多&lt;/li&gt;
&lt;li&gt;使用json格式事件格式&lt;/li&gt;
&lt;li&gt;可拔插的架构设计&lt;/li&gt;
&lt;li&gt;低资源要求&lt;/li&gt;
&lt;li&gt;内置高可靠性&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;查看&lt;code&gt;cluster/addons/fluentd-elasticsearch&lt;/code&gt;插件目录，获取到需要用到的docker镜像名称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$grep -rn &amp;quot;gcr.io&amp;quot; *.yaml
es-controller.yaml:24:      - image: gcr.io/google_containers/elasticsearch:v2.4.1-2
fluentd-es-ds.yaml:26:        image: gcr.io/google_containers/fluentd-elasticsearch:1.22
kibana-controller.yaml:22:        image: gcr.io/google_containers/kibana:v4.6.1-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;需要用到的镜像&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gcr.io/google_containers/kibana:v4.6.1-1&lt;/li&gt;
&lt;li&gt;gcr.io/google_containers/elasticsearch:v2.4.1-2&lt;/li&gt;
&lt;li&gt;gcr.io/google_containers/fluentd-elasticsearch:1.22&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为这些镜像在墙外，所以我特意备份了一份在本地还有时速云上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试环境镜像名称&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sz-pg-oam-docker-hub-001.tendcloud.com/library/elasticsearch:v2.4.1-2&lt;/li&gt;
&lt;li&gt;sz-pg-oam-docker-hub-001.tendcloud.com/library/kibana:v4.6.1-1&lt;/li&gt;
&lt;li&gt;sz-pg-oam-docker-hub-001.tendcloud.com/library/fluentd-elasticsearch:1.22&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;备份到时速云上的镜像名称&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;index.tenxcloud.com/jimmy/elasticsearch:v2.4.1-2&lt;/li&gt;
&lt;li&gt;index.tenxcloud.com/jimmy/kibana:v4.6.1-1&lt;/li&gt;
&lt;li&gt;index.tenxcloud.com/jimmy/fluentd-elasticsearch:1.22&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;修改上面的那三个yaml文件，将其中的镜像名称改成我们测试环境中的。&lt;/p&gt;

&lt;h3 id=&#34;启动集群&#34;&gt;启动集群&lt;/h3&gt;

&lt;p&gt;使用刚修改好yaml文件的那个目录启动fluentd-elasticsearch。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl create -f flucentd-elasticsearch
$kubectl get -f fluentd-elasticsearch/
NAME                          DESIRED   CURRENT   READY     AGE
rc/elasticsearch-logging-v1   2         2         2         13m

NAME                        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
svc/elasticsearch-logging   10.254.107.114   &amp;lt;none&amp;gt;        9200/TCP   13m

NAME                  DESIRED   CURRENT   READY     UP-TO-DATE   AVAILABLE   NODE-SELECTOR                              AGE
ds/fluentd-es-v1.22   0         0         0         0            0           beta.kubernetes.io/fluentd-ds-ready=true   13m

NAME                    DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deploy/kibana-logging   1         1         1            1           13m

NAME                 CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
svc/kibana-logging   10.254.104.215   &amp;lt;none&amp;gt;        5601/TCP   13m

$kubectl cluster-info
Kubernetes master is running at http://sz-pg-oam-docker-test-001:8080
Elasticsearch is running at http://sz-pg-oam-docker-test-001:8080/api/v1/proxy/namespaces/kube-system/services/elasticsearch-logging
Heapster is running at http://sz-pg-oam-docker-test-001:8080/api/v1/proxy/namespaces/kube-system/services/heapster
Kibana is running at http://sz-pg-oam-docker-test-001:8080/api/v1/proxy/namespaces/kube-system/services/kibana-logging
monitoring-grafana is running at http://sz-pg-oam-docker-test-001:8080/api/v1/proxy/namespaces/kube-system/services/monitoring-grafana
monitoring-influxdb is running at http://sz-pg-oam-docker-test-001:8080/api/v1/proxy/namespaces/kube-system/services/monitoring-influxdb

To further debug and diagnose cluster problems, use &#39;kubectl cluster-info dump&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动完成，但是查看pod的日志后会发现出错了。&lt;/p&gt;

&lt;p&gt;如何保证每个节点启动一个Fluentd呢？答案是使用DaemonSet。&lt;/p&gt;

&lt;h3 id=&#34;排错&#34;&gt;排错&lt;/h3&gt;

&lt;p&gt;查看启动的pod。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl --namespace=kube-system get all
NAME                                       READY     STATUS    RESTARTS   AGE
po/elasticsearch-logging-v1-nshz2          1/1       Running   0          16m
po/elasticsearch-logging-v1-q515j          1/1       Running   0          16m
po/heapster-3669180046-06n3d               1/1       Running   0          23h
po/kibana-logging-4247188994-h8jxx         1/1       Running   0          16m
po/kubernetes-dashboard-1074266307-hsgxx   1/1       Running   0          1d
po/monitoring-grafana-127711743-xl9v1      1/1       Running   0          23h
po/monitoring-influxdb-1411048194-cvxmm    1/1       Running   0          23h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该在个node节点上启动的&lt;strong&gt;fluentd&lt;/strong&gt;没有看到。查看logging pod的日志。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl -n kube-system logs po/elasticsearch-logging-v1-nshz2
F0406 08:30:05.488197       7 elasticsearch_logging_discovery.go:49] Failed to make client: open /var/run/secrets/kubernetes.io/serviceaccount/token: no such file or directory
goroutine 1 [running]:
...
[2017-04-06 08:30:23,450][WARN ][discovery.zen.ping.unicast] [elasticsearch-logging-v1-nshz2] failed to send ping to [{#zen_unicast_1#}{127.0.0.1}{127.0.0.1:9300}]
SendRequestTransportException[[][127.0.0.1:9300][internal:discovery/zen/unicast]]; nested: NodeNotConnectedException[[][127.0.0.1:9300] Node not connected];
	at org.elasticsearch.transport.TransportService.sendRequest(TransportService.java:340)
	at org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing.sendPingRequestToNode(UnicastZenPing.java:440)
	at org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing.sendPings(UnicastZenPing.java:426)
	at org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing.ping(UnicastZenPing.java:240)
	at org.elasticsearch.discovery.zen.ping.ZenPingService.ping(ZenPingService.java:106)
	at org.elasticsearch.discovery.zen.ping.ZenPingService.pingAndWait(ZenPingService.java:84)
	at org.elasticsearch.discovery.zen.ZenDiscovery.findMaster(ZenDiscovery.java:945)
	at org.elasticsearch.discovery.zen.ZenDiscovery.innerJoinCluster(ZenDiscovery.java:360)
	at org.elasticsearch.discovery.zen.ZenDiscovery.access$4400(ZenDiscovery.java:96)
	at org.elasticsearch.discovery.zen.ZenDiscovery$JoinThreadControl$1.run(ZenDiscovery.java:1296)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: NodeNotConnectedException[[][127.0.0.1:9300] Node not connected]
	at org.elasticsearch.transport.netty.NettyTransport.nodeChannel(NettyTransport.java:1141)
	at org.elasticsearch.transport.netty.NettyTransport.sendRequest(NettyTransport.java:830)
	at org.elasticsearch.transport.TransportService.sendRequest(TransportService.java:329)
	... 12 more
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到报错中有这样的描述：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;discovery.zen.ping.unicast failed to send ping to [{#zen_unicast_1#}{127.0.0.1}{127.0.0.1:9300}]
SendRequestTransportException[[internal:discovery/zen/unicast]]; nested: NodeNotConnectedException[ Node not connected]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面有两个错误：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无法访问到API Server&lt;/li&gt;
&lt;li&gt;elasticsearch两个节点间互ping失败&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个是镜像中的配置问题，配置文件在&lt;code&gt;fluentd-es-image/td-agent.conf&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;参考&lt;a href=&#34;http://tonybai.com/2017/03/03/implement-kubernetes-cluster-level-logging-with-fluentd-and-elasticsearch-stack/&#34;&gt;使用Fluentd和ElasticSearch Stack实现Kubernetes的集群Logging&lt;/a&gt;，Tony Bai也遇到了这个问题，我们了解下&lt;a href=&#34;https://kubernetes.io/docs/user-guide/configmap/&#34;&gt;ConfigMap&lt;/a&gt;还有&lt;a href=&#34;https://github.com/fabric8io/fluent-plugin-kubernetes_metadata_filter&#34;&gt;fluent-plugin-kubernetes_metadata_filter&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;参考我的另一片译文&lt;a href=&#34;rootsongjc.github.io/blogs/kubernetes-configmap-introduction&#34;&gt;Kubernetes中ConfigMap解析&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;问题排查&#34;&gt;问题排查&lt;/h2&gt;

&lt;p&gt;前面写的是直接使用&lt;code&gt;kubectl create -f flucentd-elasticsearch&lt;/code&gt;命令启动整个fluentd+elasticsearch集群，这样启动看似很简单，但是对于问题排查的时候不便于我们分析出错原因，因为你根本不知道服务之间的依赖关系和启动顺序，所以现在我们依次启动每个服务，看看背后都做了什么。&lt;/p&gt;

&lt;h3 id=&#34;启动fluentd&#34;&gt;启动fluentd&lt;/h3&gt;

&lt;p&gt;首先启动fluentd收集日志的服务，从&lt;code&gt;fluentd-es-ds.yaml&lt;/code&gt;的配置中可以看到fluentd是以&lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/&#34;&gt;DaemonSet&lt;/a&gt;方式来运行的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DaemonSet简介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DaemonSet能够让所有（或者一些特定）的Node节点运行同一个pod。当节点加入到kubernetes集群中，pod会被（DaemonSet）调度到该节点上运行，当节点从kubernetes集群中被移除，被（DaemonSet）调度的pod会被移除，如果删除DaemonSet，所有跟这个DaemonSet相关的pods都会被删除。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.dockerinfo.net/1139.html&#34;&gt;DaemonSet详细介绍&lt;/a&gt;，这是官方文档的中文翻译，其中还有示例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启动fluentd&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl create -f fluentd-es-ds.yaml
daemonset &amp;quot;fluentd-es-v1.22&amp;quot; created
$kubectl get -f fluentd-es-ds.yaml 
NAME               DESIRED   CURRENT   READY     UP-TO-DATE   AVAILABLE   NODE-SELECTOR                              AGE
fluentd-es-v1.22   0         0         0         0            0           beta.kubernetes.io/fluentd-ds-ready=true   2m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在没有修改&lt;code&gt;fluentd-es-ds.yaml&lt;/code&gt;的情况下直接启动fluentd，实际上一个Pod也没有启动起来，这是为什么呢？因为&lt;strong&gt;NODE-SELECTOR&lt;/strong&gt;选择的label是&lt;code&gt;beta.kubernetes.io/fluentd-ds-ready=true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们再来看下&lt;strong&gt;node&lt;/strong&gt;的&lt;strong&gt;label&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl describe node sz-pg-oam-docker-test-001.tendcloud.com
Name:			sz-pg-oam-docker-test-001.tendcloud.com
Role:			
Labels:			beta.kubernetes.io/arch=amd64
			beta.kubernetes.io/os=linux
			kubernetes.io/hostname=sz-pg-oam-docker-test-001.tendcloud.com
Annotations:		node.alpha.kubernetes.io/ttl=0
			volumes.kubernetes.io/controller-managed-attach-detach=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们没有给node设置&lt;code&gt;beta.kubernetes.io/fluentd-ds-ready=true&lt;/code&gt;的label，所以DaemonSet没有调度上去。&lt;/p&gt;

&lt;p&gt;我们需要手动给kubernetes集群的三个node添加label。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl label node sz-pg-oam-docker-test-001.tendcloud.com beta.kubernetes.io/fluentd-ds-ready=true
node &amp;quot;sz-pg-oam-docker-test-001.tendcloud.com&amp;quot; labeled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给另外两个node执行同样的操作。&lt;/p&gt;

&lt;p&gt;现在再查看下DaemonSet的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl get -f fluentd-es-ds.yaml 
NAME               DESIRED   CURRENT   READY     UP-TO-DATE   AVAILABLE   NODE-SELECTOR                              AGE
fluentd-es-v1.22   3         3         0         3            0           beta.kubernetes.io/fluentd-ds-ready=true   31m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以看到三个DeamonSet都启动起来了。&lt;/p&gt;

&lt;p&gt;查看下fluentd的日志&lt;code&gt;/var/log/fluentd.log&lt;/code&gt;，日志是mount到本地的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2017-04-07 03:53:42 +0000 [info]: adding match pattern=&amp;quot;fluent.**&amp;quot; type=&amp;quot;null&amp;quot;
2017-04-07 03:53:42 +0000 [info]: adding filter pattern=&amp;quot;kubernetes.**&amp;quot; type=&amp;quot;kubernetes_metadata&amp;quot;
2017-04-07 03:53:42 +0000 [error]: config error file=&amp;quot;/etc/td-agent/td-agent.conf&amp;quot; error=&amp;quot;Invalid Kubernetes API v1 endpoint https://10.254.0.1:443/api: SSL_connect returned=1 errno=0 state=error: certificate verify failed&amp;quot;
2017-04-07 03:53:42 +0000 [info]: process finished code=256
2017-04-07 03:53:42 +0000 [warn]: process died within 1 second. exit.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从日志的最后几行中可以看到，&lt;code&gt;Invalid Kubernetes API v1 endpoint https://10.254.0.1:443/api: SSL_connect returned=1 errno=0 state=error: certificate verify failed&lt;/code&gt;这样的错误，这些需要在&lt;code&gt;/etc/td-agent/td-agent.conf&lt;/code&gt;文件中配置的。&lt;/p&gt;

&lt;p&gt;但是这些配置已经在创建&lt;code&gt;gcr.io/google_containers/fluentd-elasticsearch:1.22&lt;/code&gt;镜像（该镜像是运行带有elasticsearch插件的fluentd的）的时候就已经copy进去了，从&lt;code&gt;fluentd-elasticsearch/fluentd-es-image/Dockerfile&lt;/code&gt;文件中就可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Copy the Fluentd configuration file.
COPY td-agent.conf /etc/td-agent/td-agent.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-configmap-introduction/&#34;&gt;ConfigMap&lt;/a&gt;，不用重新再build镜像，通过文件挂载的形式替换镜像中已有的td-agent.conf文件。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;tonybai.com&#34;&gt;Tony Bai&lt;/a&gt;给出的两点建议：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在基于td-agent.conf创建configmap资源之前，需要将td-agent.conf中的注释行都删掉，否则生成的configmap的内容可能不正确；&lt;/li&gt;
&lt;li&gt;fluentd pod将创建在kube-system下，因此ConfigMap资源也需要创建在kube-system namespace下面，否则kubectl create无法找到对应的ConfigMap。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在td-agent.conf的配置文件的&lt;filter kubernetes.**&gt;中增加两条配置配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;filter kubernetes.**&amp;gt;
  type kubernetes_metadata
  kubernetes_url sz-pg-oam-docker-test-001.tendcloud.com:8080
  verify_ssl false
&amp;lt;/filter&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;创建ConfigMap&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl create configmap td-agent-config --from-file=fluentd-elasticsearch/fluentd-es-image/td-agent.conf -n kube-system
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看刚创建的ConfigMap&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl -n kube-system get configmaps td-agent-config -o yaml
apiVersion: v1
data:
  td-agent.conf: |
    &amp;lt;match fluent.**&amp;gt;
      type null
    &amp;lt;/match&amp;gt;
...
&amp;lt;filter kubernetes.**&amp;gt;
  type kubernetes_metadata
  kubernetes_url http://sz-pg-oam-docker-test-001.tendcloud.com:8080
  verify_ssl false
&amp;lt;/filter&amp;gt;
...

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;⚠️ kubernetes_url地址要加上&lt;strong&gt;http&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;修改&lt;code&gt;fluentd-es-ds.yaml&lt;/code&gt;文件，在其中增加&lt;code&gt;td-agent.conf&lt;/code&gt;文件的volume。&lt;/p&gt;

&lt;p&gt;该文件的部分内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: DaemonSet
metadata:
...
    spec:
     ...
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
        - name: td-agent-config
          mountPath: /etc/td-agent
...
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
      - name: td-agent-config
        configMap:
          name: td-agent-config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动日志收集服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl create -f ./fluentd-elasticsearch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在再查看&lt;code&gt;/var/log/fluentd.log&lt;/code&gt;日志里面就没有错误了。&lt;/p&gt;

&lt;p&gt;查看下elasticsearch pod日志，发现里面还有错误，跟以前的一样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[2017-04-07 10:54:57,858][WARN ][discovery.zen.ping.unicast] [elasticsearch-logging-v1-wxd5f] failed to send ping to [{#zen_unicast_1#}{127.0.0.1}{127.0.0.1:9300}]
SendRequestTransportException[[][127.0.0.1:9300][internal:discovery/zen/unicast]]; nested: NodeNotConnectedException[[][127.0.0.1:9300] Node not connected];
	at org.elasticsearch.transport.TransportService.sendRequest(TransportService.java:340)
	at org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing.sendPingRequestToNode(UnicastZenPing.java:440)
	at org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing.sendPings(UnicastZenPing.java:426)
	at org.elasticsearch.discovery.zen.ping.unicast.UnicastZenPing.ping(UnicastZenPing.java:240)
	at org.elasticsearch.discovery.zen.ping.ZenPingService.ping(ZenPingService.java:106)
	at org.elasticsearch.discovery.zen.ping.ZenPingService.pingAndWait(ZenPingService.java:84)
	at org.elasticsearch.discovery.zen.ZenDiscovery.findMaster(ZenDiscovery.java:945)
	at org.elasticsearch.discovery.zen.ZenDiscovery.innerJoinCluster(ZenDiscovery.java:360)
	at org.elasticsearch.discovery.zen.ZenDiscovery.access$4400(ZenDiscovery.java:96)
	at org.elasticsearch.discovery.zen.ZenDiscovery$JoinThreadControl$1.run(ZenDiscovery.java:1296)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: NodeNotConnectedException[[][127.0.0.1:9300] Node not connected]
	at org.elasticsearch.transport.netty.NettyTransport.nodeChannel(NettyTransport.java:1141)
	at org.elasticsearch.transport.netty.NettyTransport.sendRequest(NettyTransport.java:830)
	at org.elasticsearch.transport.TransportService.sendRequest(TransportService.java:329)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看下elasticsearch:v2.4.1-2镜像的代码，在&lt;code&gt;fluentd-elasticsearch/es-image&lt;/code&gt;目录下，该目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config
Dockerfile
elasticsearch_logging_discovery.go
Makefile
run.sh
template-k8s-logstash.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从&lt;strong&gt;Dockerfile&lt;/strong&gt;中可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;RUN mkdir -p /elasticsearch/config/templates
COPY template-k8s-logstash.json /elasticsearch/config/templates/template-k8s-logstash.json

COPY config /elasticsearch/config

COPY run.sh /
COPY elasticsearch_logging_discovery /

RUN useradd --no-create-home --user-group elasticsearch \
    &amp;amp;&amp;amp; mkdir /data \
    &amp;amp;&amp;amp; chown -R elasticsearch:elasticsearch /elasticsearch

VOLUME [&amp;quot;/data&amp;quot;]
EXPOSE 9200 9300

CMD [&amp;quot;/run.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将本地的&lt;code&gt;config&lt;/code&gt;目录作为配置文件拷贝到了镜像里，&lt;code&gt;run.sh&lt;/code&gt;启动脚本中有三行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/elasticsearch_logging_discovery &amp;gt;&amp;gt; /elasticsearch/config/elasticsearch.yml

chown -R elasticsearch:elasticsearch /data

exec gosu elasticsearch /elasticsearch/bin/elasticsearch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再进入到镜像里查看下&lt;code&gt;/elasticsearch/config/elasticsearch.yml&lt;/code&gt;文件的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;cluster.name: kubernetes-logging

node.name: ${NODE_NAME}
node.master: ${NODE_MASTER}
node.data: ${NODE_DATA}

transport.tcp.port: ${TRANSPORT_PORT}
http.port: ${HTTP_PORT}

path.data: /data

network.host: 0.0.0.0

discovery.zen.minimum_master_nodes: ${MINIMUM_MASTER_NODES}
discovery.zen.ping.multicast.enabled: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;记录几个问题&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Kubernetes中的DNS没有配置。&lt;/li&gt;
&lt;li&gt;ElasticSearch的配置有问题。&lt;/li&gt;
&lt;li&gt;是否要用ServiceAccount？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tonybai.com/2017/03/03/implement-kubernetes-cluster-level-logging-with-fluentd-and-elasticsearch-stack/&#34;&gt;使用Fluentd和ElasticSearch Stack实现Kubernetes的集群Logging&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://my.oschina.net/newlife111/blog/714574&#34;&gt;在Kubernetes上搭建EFK（Fluentd＋Elasticsearch＋Kibana）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/muzhiye/p/elasticsearch_set_cluster.html&#34;&gt;elasticsearch2.2 集群搭建各种坑&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/fluentd-elasticsearch/es-image/elasticsearch_logging_discovery.go&#34;&gt;elasticsearch_logging_discovery.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fabric8io/fluent-plugin-kubernetes_metadata_filter&#34;&gt;fluent-plugin-kubernetes_metadata_filter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;To be continued…&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes的ConfigMap解析</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-configmap-introduction/</link>
      <pubDate>Thu, 06 Apr 2017 21:24:20 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-configmap-introduction/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20160430004.jpg&#34; alt=&#34;古北水镇&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：龙形灯笼@古北水镇 Apr 30,2016）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;为什么要翻译这篇文章，是因为我在&lt;a href=&#34;rootsongjc.github.io/blogs/kubernetes-fluentd-elasticsearch-installation&#34;&gt;使用Fluentd和ElasticSearch收集Kubernetes集群日志&lt;/a&gt;的时候遇到了需要修改镜像中配置的问题，&lt;a href=&#34;https://github.com/fabric8io/fluent-plugin-kubernetes_metadata_filter&#34;&gt;fluent-plugin-kubernetes_metadata&lt;/a&gt;里的需要的&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/fluentd-elasticsearch/fluentd-es-image/td-agent.conf&#34;&gt;td-agent.conf&lt;/a&gt;文件。&lt;/p&gt;

&lt;p&gt;其实ConfigMap功能在Kubernetes1.2版本的时候就有了，许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。这些配置信息需要与docker image解耦，你总不能每修改一个配置就重做一个image吧？ConfigMap API给我们提供了向容器中注入配置信息的机制，ConfigMap可以被用来保存单个属性，也可以用来保存整个配置文件或者JSON二进制大对象。&lt;/p&gt;

&lt;h2 id=&#34;configmap概览&#34;&gt;ConfigMap概览&lt;/h2&gt;

&lt;p&gt;The ConfigMap API resource holds key-value pairs of configuration data that can be consumed in pods or used to store configuration data for system components such as controllers. ConfigMap is similar to [Secrets](), but designed to more conveniently support working with strings that do not contain sensitive information.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ConfigMap API&lt;/strong&gt;资源用来保存&lt;strong&gt;key-value pair&lt;/strong&gt;配置数据，这个数据可以在&lt;strong&gt;pods&lt;/strong&gt;里使用，或者被用来为像&lt;strong&gt;controller&lt;/strong&gt;一样的系统组件存储配置数据。虽然ConfigMap跟&lt;a href=&#34;https://kubernetes.io/docs/user-guide/secrets/&#34;&gt;Secrets&lt;/a&gt;类似，但是ConfigMap更方便的处理不含敏感信息的字符串。
注意：&lt;u&gt;ConfigMaps不是属性配置文件的替代品。&lt;/u&gt;ConfigMaps只是作为多个properties文件的引用。你可以把它理解为Linux系统中的&lt;code&gt;/etc&lt;/code&gt;目录，专门用来存储配置文件的目录。下面举个例子，使用ConfigMap配置来创建Kuberntes Volumes，ConfigMap中的每个data项都会成为一个新文件。&lt;/p&gt;

&lt;p&gt;Note: ConfigMaps are not intended to act as a replacement for a properties file. ConfigMaps are intended to act as a reference to multiple properties files. You can think of them as way to represent something similar to the /etc directory, and the files within, on a Linux computer. One example of this model is creating Kubernetes Volumes from ConfigMaps, where each data item in the ConfigMap becomes a new file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;kind: ConfigMap
apiVersion: v1
metadata:
  creationTimestamp: 2016-02-18T19:14:38Z
  name: example-config
  namespace: default
data:
  example.property.1: hello
  example.property.2: world
  example.property.file: |-
    property.1=value-1
    property.2=value-2
    property.3=value-3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;data&lt;/code&gt;一栏包括了配置数据，ConfigMap可以被用来保存单个属性，也可以用来保存一个配置文件。
配置数据可以通过很多种方式在Pods里被使用。ConfigMaps可以被用来：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;设置环境变量的值&lt;/li&gt;
&lt;li&gt;在容器里设置命令行参数&lt;/li&gt;
&lt;li&gt;在数据卷里面创建config文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用户和系统组件两者都可以在ConfigMap里面存储配置数据。&lt;/p&gt;

&lt;p&gt;其实不用看下面的文章，直接从&lt;code&gt;kubectl create configmap -h&lt;/code&gt;的帮助信息中就可以对ConfigMap究竟如何创建略知一二了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Examples:
  # Create a new configmap named my-config based on folder bar
  kubectl create configmap my-config --from-file=path/to/bar
  
  # Create a new configmap named my-config with specified keys instead of file basenames on disk
  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt
  
  # Create a new configmap named my-config with key1=config1 and key2=config2
  kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建configmaps&#34;&gt;创建ConfigMaps&lt;/h2&gt;

&lt;p&gt;可以使用该命令，用给定值、文件或目录来创建ConfigMap。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl create configmap
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用目录创建&#34;&gt;使用目录创建&lt;/h3&gt;

&lt;p&gt;比如我们已经有个了包含一些配置文件，其中包含了我们想要设置的ConfigMap的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls docs/user-guide/configmap/kubectl/
game.properties
ui.properties

$ cat docs/user-guide/configmap/kubectl/game.properties
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30

$ cat docs/user-guide/configmap/kubectl/ui.properties
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面的命令可以创建一个包含目录中所有文件的ConfigMap。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create configmap game-config --from-file=docs/user-guide/configmap/kubectl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;—from-file&lt;/code&gt;指定在目录下的所有文件都会被用在ConfigMap里面创建一个键值对，键的名字就是文件名，值就是文件的内容。&lt;/p&gt;

&lt;p&gt;让我们来看一下这个命令创建的ConfigMap：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl describe configmaps game-config
Name:           game-config
Namespace:      default
Labels:         &amp;lt;none&amp;gt;
Annotations:    &amp;lt;none&amp;gt;

Data
====
game.properties:        158 bytes
ui.properties:          83 bytes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到那两个key是从kubectl指定的目录中的文件名。这些key的内容可能会很大，所以在kubectl describe的输出中，只能够看到键的名字和他们的大小。
如果想要看到键的值的话，可以使用&lt;code&gt;kubectl get&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl get configmaps game-config -o yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们以&lt;code&gt;yaml&lt;/code&gt;格式输出配置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
data:
  game.properties: |
    enemies=aliens
    lives=3
    enemies.cheat=true
    enemies.cheat.level=noGoodRotten
    secret.code.passphrase=UUDDLRLRBABAS
    secret.code.allowed=true
    secret.code.lives=30
  ui.properties: |
    color.good=purple
    color.bad=yellow
    allow.textmode=true
    how.nice.to.look=fairlyNice
kind: ConfigMap
metadata:
  creationTimestamp: 2016-02-18T18:34:05Z
  name: game-config
  namespace: default
  resourceVersion: &amp;quot;407&amp;quot;
  selfLink: /api/v1/namespaces/default/configmaps/game-config
  uid: 30944725-d66e-11e5-8cd0-68f728db1985
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用文件创建&#34;&gt;使用文件创建&lt;/h3&gt;

&lt;p&gt;刚才&lt;strong&gt;使用目录创建&lt;/strong&gt;的时候我们&lt;code&gt;—from-file&lt;/code&gt;指定的是一个目录，只要指定为一个文件就可以从单个文件中创建ConfigMap。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create configmap game-config-2 --from-file=docs/user-guide/configmap/kubectl/game.properties 

$ kubectl get configmaps game-config-2 -o yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: v1
data:
  game-special-key: |
    enemies=aliens
    lives=3
    enemies.cheat=true
    enemies.cheat.level=noGoodRotten
    secret.code.passphrase=UUDDLRLRBABAS
    secret.code.allowed=true
    secret.code.lives=30
kind: ConfigMap
metadata:
  creationTimestamp: 2016-02-18T18:54:22Z
  name: game-config-3
  namespace: default
  resourceVersion: &amp;quot;530&amp;quot;
  selfLink: /api/v1/namespaces/default/configmaps/game-config-3
  uid: 05f8da22-d671-11e5-8cd0-68f728db1985
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;—from-file&lt;/code&gt;这个参数可以使用多次，你可以使用两次分别指定上个实例中的那两个配置文件，效果就跟指定整个目录是一样的。&lt;/p&gt;

&lt;h3 id=&#34;使用literal值创建&#34;&gt;使用literal值创建&lt;/h3&gt;

&lt;p&gt;使用文字值创建，利用&lt;code&gt;—from-literal&lt;/code&gt;参数传递配置信息，该参数可以使用多次，格式如下；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charm

$ kubectl get configmaps special-config -o yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
data:
  special.how: very
  special.type: charm
kind: ConfigMap
metadata:
  creationTimestamp: 2016-02-18T19:14:38Z
  name: special-config
  namespace: default
  resourceVersion: &amp;quot;651&amp;quot;
  selfLink: /api/v1/namespaces/default/configmaps/special-config
  uid: dadce046-d673-11e5-8cd0-68f728db1985
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pod中使用configmap&#34;&gt;Pod中使用ConfigMap&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;使用ConfigMap来替代环境变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ConfigMap可以被用来填入环境变量。看下下面的ConfigMap。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
  special.type: charm
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: env-config
  namespace: default
data:
  log_level: INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以在Pod中这样使用ConfigMap：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox
      command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;env&amp;quot; ]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how
        - name: SPECIAL_TYPE_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.type
      envFrom:
        - configMapRef:
            name: env-config
  restartPolicy: Never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个Pod运行后会输出如下几行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;SPECIAL_LEVEL_KEY=very
SPECIAL_TYPE_KEY=charm
log_level=INFO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;用ConfigMap设置命令行参数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ConfigMap也可以被使用来设置容器中的命令或者参数值。它使用的是Kubernetes的$(VAR_NAME)替换语法。我们看下下面这个ConfigMap。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
  special.type: charm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了将ConfigMap中的值注入到命令行的参数里面，我们还要像前面那个例子一样使用环境变量替换语法&lt;code&gt;${VAR_NAME)&lt;/code&gt;。（其实这个东西就是给Docker容器设置环境变量，以前我创建镜像的时候经常这么玩，通过docker run的时候指定-e参数修改镜像里的环境变量，然后docker的CMD命令再利用该$(VAR_NAME)通过sed来来修改配置文件或者作为命令行启动参数。）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox
      command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&amp;quot; ]
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how
        - name: SPECIAL_TYPE_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.type
  restartPolicy: Never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这个Pod后会输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;very charm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;通过数据卷插件使用ConfigMap&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ConfigMap也可以在数据卷里面被使用。还是这个ConfigMap。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
  special.type: charm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在数据卷里面使用这个ConfigMap，有不同的选项。最基本的就是将文件填入数据卷，在这个文件中，键就是文件名，键值就是文件内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox
      command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;cat /etc/config/special.how&amp;quot; ]
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap:
        name: special-config
  restartPolicy: Never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这个Pod的输出是&lt;code&gt;very&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们也可以在ConfigMap值被映射的数据卷里控制路径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox
      command: [ &amp;quot;/bin/sh&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;cat /etc/config/path/to/special-key&amp;quot; ]
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap:
        name: special-config
        items:
        - key: special.how
          path: path/to/special-key
  restartPolicy: Never
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这个Pod后的结果是&lt;code&gt;very&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;还是那句话，如果你了解docker的ENV机制就会明白ConfigMap背后究竟发生了什么，so easy~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TensorFlow深度学习手写数字识别初体验</title>
      <link>http://rootsongjc.github.io/blogs/tensorflow-and-deep-learning-without-a-phd/</link>
      <pubDate>Wed, 05 Apr 2017 21:52:01 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/tensorflow-and-deep-learning-without-a-phd/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/201703085.jpg&#34; alt=&#34;禾雀&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：禾雀 @北京动物园 Apr 3,2017）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;TensorFlow学习曲线是陡峭的，不是所有的IT从业人员都很容易参与的，你需要有一定的数学专业知识，对于对深度学习没有经验的程序员，要想了解这门技术，最快捷的途径是先运行一个示例，我们认识事物都是先从感性、到理性的思辨过程。&lt;/p&gt;

&lt;p&gt;下面我们来跟随&lt;strong&gt;Martin Gorner&lt;/strong&gt;的&lt;a href=&#34;https://codelabs.developers.google.com/codelabs/cloud-tensorflow-mnist/#0&#34;&gt;TensorFlow and Deep Learing Without a PhD&lt;/a&gt;来编写我们的第一个TensorFlow程序——手写数字识别，这篇文章的中文版&lt;a href=&#34;http://www.jiqizhixin.com/article/2458&#34;&gt;没有博士学位如何玩转TensorFlow和深度学习&lt;/a&gt;于2017年3月13日发表在发表在&lt;a href=&#34;www.jiqizhixin.com&#34;&gt;机器之心&lt;/a&gt;上。这篇文章也是根据3月8日-10日的&lt;strong&gt;Google Cloud NEXT&amp;rsquo;17&lt;/strong&gt;大会上Martin Gorner做的讲解整理而成的，&lt;a href=&#34;http://it.sohu.com/20170124/n479480999.shtml&#34;&gt;教程 | 没有博士学位，照样玩转TensorFlow深度学习&lt;/a&gt;这篇文章是对Martin Gorner的简易教程的原文翻译，我们暂时不要求了解TensorFlow背后复杂的理论，我们先跟随这篇简易教程玩一把TensorFlow的手写数字识别。&lt;/p&gt;

&lt;p&gt;如果你想深入了解这本后的原理的话，可以查看哈尔滨工业大学社会计算与信息检索研究中心翻译的&lt;a href=&#34;https://www.gitbook.com/book/hit-scir/neural-networks-and-deep-learning-zh_cn/details&#34;&gt;《神经网络与深度学习》&lt;/a&gt;这本书，该书翻译自&lt;a href=&#34;http://neuralnetworksanddeeplearning.com/&#34;&gt;Neural Networks and Deep Learning&lt;/a&gt;的中文翻译，原文作者 Michael Nielsen，而且这还是一本免费的电子书，该书中系统讲解了&lt;a href=&#34;https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/chap1/c1s0.html&#34;&gt;使用神经网络识别手写数字&lt;/a&gt;背后的原理。该书托管在GitBook上，你可以点击&lt;a href=&#34;http://olz1di9xf.bkt.clouddn.com/neural-networks-and-deep-learning-zh_cn.pdf&#34;&gt;这里&lt;/a&gt;直接下载该书中文版的PDF。&lt;/p&gt;

&lt;h2 id=&#34;准备&#34;&gt;准备&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;下载代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个代码仓库里包含了手写数字识别和下载依赖的训练数据的代码，我们将只用到&lt;code&gt;mnist_1.0_softmax.py&lt;/code&gt;这一个代码文件。整个&lt;code&gt;mnist_1.0_softmax.py&lt;/code&gt;代码并不复杂，不算注释的话只有36行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone https://github.com/martin-gorner/tensorflow-mnist-tutorial.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载完后，可以看到有一个&lt;strong&gt;INSTALL.txt&lt;/strong&gt;，这篇文章是运行代码所必需的环境要求说明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装TensorFlow&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我之前写过详细的TensorFlow安装教程&lt;a href=&#34;http://rootsongjc.github.io/blogs/tensorflow-practice-02/&#34;&gt;TensorFlow实战（才云郑泽宇著）读书笔记——第二章TensorFlow环境搭建&lt;/a&gt;，这篇文章中主要讲怎样在docker里安装TensorFlow。&lt;/p&gt;

&lt;p&gt;我使用的Mac而且还是python2.7，所以我这样安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install --upgrade tensorflow --user -U
pip install --upgrade matplotlib --user -U
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;运行示例&#34;&gt;运行示例&lt;/h2&gt;

&lt;p&gt;运行手写数字训练示例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;python mnist_1.0_softmax.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行过程中你会看到一大段输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Collecting matplotlib
  Downloading matplotlib-2.0.0-cp27-cp27m-macosx_10_6_intel.macosx_10_9_intel.macosx_10_9_x86_64.macosx_10_10_intel.macosx_10_10_x86_64.whl (12.8MB)
    100% |████████████████████████████████| 12.8MB 26kB/s 
Requirement already up-to-date: pyparsing!=2.0.0,!=2.0.4,!=2.1.2,!=2.1.6,&amp;gt;=1.5.6 in /Users/jimmy/Library/Python/2.7/lib/python/site-packages (from matplotlib)
Requirement already up-to-date: numpy&amp;gt;=1.7.1 in /Users/jimmy/Library/Python/2.7/lib/python/site-packages (from matplotlib)
Collecting functools32 (from matplotlib)
  Downloading functools32-3.2.3-2.zip
Collecting pytz (from matplotlib)
  Downloading pytz-2017.2-py2.py3-none-any.whl (484kB)
    100% |████████████████████████████████| 491kB 33kB/s 
Requirement already up-to-date: six&amp;gt;=1.10 in /Users/jimmy/Library/Python/2.7/lib/python/site-packages (from matplotlib)
Collecting cycler&amp;gt;=0.10 (from matplotlib)
  Downloading cycler-0.10.0-py2.py3-none-any.whl
Collecting subprocess32 (from matplotlib)
  Downloading subprocess32-3.2.7.tar.gz (54kB)
    100% |████████████████████████████████| 61kB 26kB/s 
Collecting python-dateutil (from matplotlib)
  Downloading python_dateutil-2.6.0-py2.py3-none-any.whl (194kB)
    100% |████████████████████████████████| 194kB 45kB/s 
Building wheels for collected packages: functools32, subprocess32
  Running setup.py bdist_wheel for functools32 ... done
  Stored in directory: /Users/jimmy/Library/Caches/pip/wheels/3c/d0/09/cd78d0ff4d6cfecfbd730782a7815a4571cd2cd4d2ed6e69d9
  Running setup.py bdist_wheel for subprocess32 ... done
  Stored in directory: /Users/jimmy/Library/Caches/pip/wheels/7d/4c/a4/ce9ceb463dae01f4b95e670abd9afc8d65a45f38012f8030cc
Successfully built functools32 subprocess32
Installing collected packages: functools32, pytz, cycler, subprocess32, python-dateutil, matplotlib
Successfully installed cycler-0.10.0 functools32-3.2.3.post2 matplotlib-2.0.0 python-dateutil-2.6.0 pytz-2017.2 subprocess32-3.2.7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到这个过程中下载了一些python依赖库如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;matplotlib&lt;/li&gt;
&lt;li&gt;pytz&lt;/li&gt;
&lt;li&gt;subprocess32&lt;/li&gt;
&lt;li&gt;cycler&lt;/li&gt;
&lt;li&gt;python_dateutil&lt;/li&gt;
&lt;li&gt;functools32&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有的依赖都下载完成之后，就会弹出一个窗口，同时后台也会在不断滚动显示训练的阶段，直到2001步，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-01.jpg&#34; alt=&#34;tensorflow-mnist-01&#34; /&gt;&lt;/p&gt;

&lt;p&gt;正规的TensorFlow项目会使用&lt;strong&gt;TensorBoard&lt;/strong&gt;作可视化，我们用&lt;strong&gt;matplotlib&lt;/strong&gt;作为替代。&lt;/p&gt;

&lt;p&gt;至此整个训练过程结束了，但是我们还不明白这个窗口里的6个图分别表示的含义，下面将依次作出解释。&lt;/p&gt;

&lt;h2 id=&#34;窗口中的图片说明&#34;&gt;窗口中的图片说明&lt;/h2&gt;

&lt;p&gt;我们分别来看下MNIST窗口中的6个Panel。&lt;/p&gt;

&lt;h3 id=&#34;training-digits&#34;&gt;Training Digits&lt;/h3&gt;

&lt;p&gt;此&lt;strong&gt;DataSet&lt;/strong&gt;中一共有50000个&lt;u&gt;训练数字&lt;/u&gt;，每次&lt;strong&gt;Iteration&lt;/strong&gt;送入100个数字作为循环，500次迭代后可以将所有数字训练一次，叫做一个&lt;strong&gt;Epoch&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;上图中白色背景的数字表示识别正确的，红色背景的部分表示识别错误的，每个数字左边下标表示应该被识别成的正确结果，数字右边的下标是识别错误的结果。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-panel-01.jpg&#34; alt=&#34;training digits&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;test-digits&#34;&gt;Test Digits&lt;/h3&gt;

&lt;p&gt;此外也不能光有训练数字吧，MNIST数据集中还有10000个测试数字，此处你能看到每个数字对应的大约 1000 种书写形式，其中所有错误识别的数字列在顶部（有红色背景）。左边的刻度会给你一个粗略的分辨率精确度（正确识别的百分比）。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-panel-02.jpg&#34; alt=&#34;test digits&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到经过2000轮的训练后，已经对手写数字的识别率达到了92%。&lt;/p&gt;

&lt;h3 id=&#34;cross-entropy-loss&#34;&gt;Cross Entropy Loss&lt;/h3&gt;

&lt;p&gt;为了驱动训练，我们来定义&lt;strong&gt;损失函数&lt;/strong&gt;，即&lt;u&gt;一个展示出系统数字识别能力有多糟的值&lt;/u&gt;，并且系统会尽力将其最小化。损失函数（loss function，此处为&lt;a href=&#34;https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/content/chap3/c3s1.html&#34;&gt;交叉熵&lt;/a&gt;）的选择稍后会做出解释。你会看到，随着训练的进行，训练和测试数据的损失会减少，而这个现象是好的，意味着神经网络正在学习。X 轴表示了学习过程中的迭代。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-panel-03.jpg&#34; alt=&#34;cross entropy loss&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;accuracy&#34;&gt;Accuracy&lt;/h3&gt;

&lt;p&gt;这个准确度只是正确识别的数字的百分比，是在训练和测试集上计算出的。如果训练顺利，它便会上升。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-panel-04.jpg&#34; alt=&#34;accuratcy&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;weight-biases&#34;&gt;Weight &amp;amp; Biases&lt;/h3&gt;

&lt;p&gt;最后的两幅图表说明了内部变量所取的所有值的扩展，即随训练进行而变化的权重和偏置。比如偏置从 0 开始，且最终得到的值大致均匀地分布在-1.5 和 1.5 之间。如果系统不能很好地收敛，那么这些图可能有用。倘若你发现权重和偏差扩展到上百或上千，那么就可能有问题了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-panel-05.jpg&#34; alt=&#34;weight&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-mnist-panel-06.jpg&#34; alt=&#34;biases&#34; /&gt;&lt;/p&gt;

&lt;p&gt;剩下的部分就是理论讲解了，先复制过来，期待有朝一日我能看懂吧😄&lt;/p&gt;

&lt;h3 id=&#34;理论-单层神经网络&#34;&gt;理论 : 单层神经网络&lt;/h3&gt;

&lt;p&gt;MNIST 数据集中，手写数字是 28x28 像素的灰度图像。将它们进行分类的最简单的方法就是使用 28x28=784 个像素作为单层神经网络的输入。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/5070df2db57143eabd8549e038c95735_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;神经网络中的每个「神经元」对其所有的输入进行加权求和，并添加一个被称为「偏置（bias）」的常数，然后通过一些非线性激活函数来反馈结果。&lt;/p&gt;

&lt;p&gt;为了将数字分为 10 类（0 到 9），我们设计了一个具有 10 个输出神经元的单层神经网络。对于分类问题，softmax 是一个不错的激活函数。通过取每个元素的指数，然后归一化向量（使用任意的范数（norm），比如向量的普通欧几里得距离）从而将 softmax 应用于向量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/7648d231901a468a99cb9a849e8630a5_th.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那么为什么「softmax」会被称为 softmax 呢？指数是一种骤增的函数。这将加大向量中每个元素的差异。它也会迅速地产生一个巨大的值。然后，当进行向量的标准化时，支配范数（norm）的最大的元素将会被标准化为一个接近 1 的数字，其他的元素将会被一个较大的值分割并被标准化为一个接近 0 的数字。所得到的向量清楚地显示出了哪个是其最大的值，即「max」，但是却又保留了其值的原始的相对排列顺序，因此即为「soft」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/c85a5d9f37f045ceb8b7b0b457159782_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们现在将使用矩阵乘法将这个单层的神经元的行为总结进一个简单的公式当中。让我们直接这样做：100 个图像的「mini-batch」作为输入，产生 100 个预测（10 元素向量）作为输出。&lt;/p&gt;

&lt;p&gt;使用加权矩阵 W 的第一列权重，我们计算第一个图像所有像素的加权和。该和对应于第一神经元。使用第二列权重，我们对第二个神经元进行同样的操作，直到第 10 个神经元。然后，我们可以对剩余的 99 个图像重复操作。如果我们把一个包含 100 个图像的矩阵称为 X，那么我们的 10 个神经元在这 100 张图像上的加权和就是简单的 X.W（矩阵乘法）。&lt;/p&gt;

&lt;p&gt;每一个神经元都必须添加其偏置（一个常数）。因为我们有 10 个神经元，我们同样拥有 10 个偏置常数。我们将这个 10 个值的向量称为 b。它必须被添加到先前计算的矩阵中的每一行当中。使用一个称为 &amp;ldquo;broadcasting&amp;rdquo; 的魔法，我们将会用一个简单的加号写出它。&lt;/p&gt;

&lt;p&gt;「Broadcasting」是 Python 和 numpy（Python 的科学计算库）的一个标准技巧。它扩展了对不兼容维度的矩阵进行正常操作的方式。「Broadcasting add」意味着「如果你因为两个矩阵维度不同的原因而不能将其相加，那么你可以根据需要尝试复制一个小的矩阵使其工作。」&lt;/p&gt;

&lt;p&gt;我们最终应用 softmax 激活函数并且得到一个描述单层神经网络的公式，并将其应用于 100 张图像：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/cd007da75f714c96ade9a4e4c0187bfa_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;顺便说一下，什么是「tensor（张量）」？&lt;/p&gt;

&lt;p&gt;「张量（tensor）」像一个矩阵，但是却有着任意数量的维度。一个 1 维的张量是一个向量。一个二维的张量是一个矩阵。然后你可以有 3, 4, 5 或者更多维的张量。&lt;/p&gt;

&lt;h3 id=&#34;理论-梯度下降&#34;&gt;理论：梯度下降&lt;/h3&gt;

&lt;p&gt;现在我们的神经网络从输入图像中产生预测，我们需要知道它们可以做到什么样的程度，即在我们知道的事实和网络的预测之间到底有多大的距离。请记住，我们对于这个数据集中的所有图像都有一个真实的标签。&lt;/p&gt;

&lt;p&gt;任何一种定义的距离都可以进行这样的操作，普通欧几里得距离是可以的，但是对于分类问题，被称为「交叉熵（cross-entropy）」的距离更加有效。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/9fe5ab61209c490297769b729a471c81_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;「one-hot」编码意味着你使用一个 10 个值的向量，其中除了第 6 个值为 1 以外的所有值都是 0。这非常方便，因为这样的格式和我们神经网络预测输出的格式非常相似，同时它也作为一个 10 值的向量。&lt;/p&gt;

&lt;p&gt;「训练」一个神经网络实际上意味着使用训练图像和标签来调整权重和偏置，以便最小化交叉熵损失函数。它是这样工作的。&lt;/p&gt;

&lt;p&gt;交叉熵是一个关于权重、偏置、训练图像的像素和其已知标签的函数。&lt;/p&gt;

&lt;p&gt;如果我们相对于所有的权重和所有的偏置计算交叉熵的偏导数，我们就得到一个对于给定图像、标签和当前权重和偏置的「梯度」。请记住，我们有 7850 个权重和偏置，所以计算梯度需要大量的工作。幸运的是，TensorFlow 可以来帮我们做这项工作。&lt;/p&gt;

&lt;p&gt;梯度的数学意义在于它指向「上（up）」。因为我们想要到达一个交叉熵低的地方，那么我们就去向相反的方向。我们用一小部分的梯度更新权重和偏置并且使用下一批训练图像再次做同样的事情。我们希望的是，这可以使我们到达交叉熵最小的凹点的低部。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/b90ff98a395b46e392c21c6ebca0c7d6_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在这副图片当中，交叉熵被表示为一个具有两个权重的函数。事实上，还有更多。梯度下降算法遵循着一个最陡的坡度下降到局部最小值的路径。训练图像在每一次迭代中同样会被改变，这使得我们向着一个适用于所有图像的局部最小值收敛。&lt;/p&gt;

&lt;p&gt;「学习率（learning rate）」： 在整个梯度的长度上，你不能在每一次迭代的时候都对权重和偏置进行更新。这就会像是你穿着七里靴却试图到达一个山谷的底部。你会直接从山谷的一边到达另一边。为了到达底部，你需要一些更小的步伐，即只使用梯度的一部分，通常在 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1000&lt;/sub&gt; 区域中。我们称这个部分为「学习率（Learning rate）」。&lt;/p&gt;

&lt;p&gt;总结一下，以下是训练过程的步骤：&lt;/p&gt;

&lt;p&gt;Training digits and labels =&amp;gt; loss function =&amp;gt; gradient (partial derivatives) =&amp;gt; steepest descent =&amp;gt; update weights and biases =&amp;gt; repeat with next mini-batch of training images and labels&lt;/p&gt;

&lt;p&gt;训练数字和标签 =&amp;gt; 损失函数 =&amp;gt; 梯度（部分偏导数）=&amp;gt; 最陡的梯度 =&amp;gt; 更新权重和偏置 =&amp;gt; 使用下一个 mini-batch 的图像和标签重复这一过程&lt;/p&gt;

&lt;p&gt;为什么使用 100 个图像和标签的 mini-batch？&lt;/p&gt;

&lt;p&gt;你当然也可以只在一个示例图像中计算你的梯度并且立即更新权重和偏置（这在科学文献中被称为「随机梯度下降（stochastic gradient descent）」）。在 100 个样本上都这样做可以得到一个更好地表示由不同样本图像施加约束的梯度并且可能更快地朝着解决方案收敛。mini-batch 的大小是可调整的参数。还有一个更加技术化的原因：使用批处理也意味着使用较大的矩阵，而这些通常更容易在 GPU 上优化。&lt;/p&gt;

&lt;p&gt;常见问题&lt;/p&gt;

&lt;p&gt;为什么交叉熵是在分类问题中合适的定义距离？&lt;/p&gt;

&lt;p&gt;　　解答链接：&lt;a href=&#34;https://jamesmccaffrey.wordpress.com/2013/11/05/why-you-should-use-cross-entropy-error-instead-of-classification-error-or-mean-squared-error-for-neural-network-classifier-training/&#34;&gt;https://jamesmccaffrey.wordpress.com/2013/11/05/why-you-should-use-cross-entropy-error-instead-of-classification-error-or-mean-squared-error-for-neural-network-classifier-training/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;实验-让我们来看看代码&#34;&gt;实验：让我们来看看代码&lt;/h3&gt;

&lt;p&gt;单层神经网络的代码已经写好了。请打开 mnist_1.0_softmax.py 文件并按说明进行操作。&lt;/p&gt;

&lt;p&gt;你在本节的任务是理解开始代码，以便稍后对其改进。&lt;/p&gt;

&lt;p&gt;你应该看到，在文档中的说明和启动代码只有微小的差别。它们对应于可视化的函数，并且在注释中被标记。此处可忽略。&lt;/p&gt;

&lt;p&gt;　　mnist_1.0_softmax.py：&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&#34;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py&#34;&gt;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/b8be8ddc1a9e41d19ddbffe3ed1ddc05_th.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　我们首先定义 TensorFlow 的变量和占位符。变量是你希望训练算法为你确定的所有的参数。在我们的例子中参数是权重和偏差。&lt;/p&gt;

&lt;p&gt;占位符是在训练期间填充实际数据的参数，通常是训练图像。持有训练图像的张量的形式是 [None, 28, 28, 1]，其中的参数代表：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;28, 28, 1: 图像是 28x28 每像素 x 1（灰度）。最后一个数字对于彩色图像是 3 但在这里并非是必须的。&lt;/li&gt;
&lt;li&gt;None: 这是代表图像在小批量（mini-batch）中的数量。在训练时可以得到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　mnist_1.0_softmax.py：&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&#34;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py&#34;&gt;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/71fef16bc66b4939975a236b58dac8ba_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　第一行是我们单层神经网络的模型。公式是我们在前面的理论部分建立的。tf.reshape 命令将我们的 28×28 的图像转化成 784 个像素的单向量。在 reshape 中的「-1」意味着「计算机，计算出来，这只有一种可能」。在实际当中，这会是图像在小批次（mini-batch）中的数量。&lt;/p&gt;

&lt;p&gt;然后，我们需要一个额外的占位符用于训练标签，这些标签与训练图像一起被提供。&lt;/p&gt;

&lt;p&gt;现在我们有模型预测和正确的标签，所以我们计算交叉熵。tf.reduce_sum 是对向量的所有元素求和。&lt;/p&gt;

&lt;p&gt;最后两行计算了正确识别数字的百分比。这是留给读者的理解练习，使用 TensorFlow API 参考。你也可以跳过它们。&lt;/p&gt;

&lt;p&gt;　　mnist_1.0_softmax.py：&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&#34;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py)&#34;&gt;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　optimizer = tf.train.GradientDescentOptimizer(0.003)&lt;/p&gt;

&lt;p&gt;　　train_step = optimizer.minimize(cross_entropy)&lt;/p&gt;

&lt;p&gt;　　才是 TensorFlow 发挥它力量的地方。你选择一个适应器（optimiser，有许多可供选择）并且用它最小化交叉熵损失。在这一步中，TensorFlow 计算相对于所有权重和所有偏置（梯度）的损失函数的偏导数。这是一个形式衍生（ formal derivation），并非是一个耗时的数值型衍生。&lt;/p&gt;

&lt;p&gt;梯度然后被用来更新权重和偏置。学习率为 0.003。&lt;/p&gt;

&lt;p&gt;最后，是时候来运行训练循环了。到目前为止，所有的 TensorFlow 指令都在内存中准备了一个计算图，但是还未进行计算。&lt;/p&gt;

&lt;p&gt;TensorFlow 的 “延迟执行（deferred execution）” 模型：TensorFlow 是为分布式计算构建的。它必须知道你要计算的是什么、你的执行图（execution graph），然后才开始发送计算任务到各种计算机。这就是为什么它有一个延迟执行模型，你首先使用 TensorFlow 函数在内存中创造一个计算图，然后启动一个执行 Session 并且使用 Session.run 执行实际计算任务。在此时，图形无法被更改。&lt;/p&gt;

&lt;p&gt;由于这个模型，TensorFlow 接管了分布式运算的大量运筹。例如，假如你指示它在计算机 1 上运行计算的一部分 ，而在计算机 2 上运行另一部分，它可以自动进行必要的数据传输。&lt;/p&gt;

&lt;p&gt;计算需要将实际数据反馈进你在 TensorFlow 代码中定义的占位符。这是以 Python 的 dictionary 的形式给出的，其中的键是占位符的名称。&lt;/p&gt;

&lt;p&gt;　　mnist_1.0_softmax.py：&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&#34;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py&#34;&gt;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_1.0_softmax.py&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/a96dcaf397d342e18edb0ec24757f821.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　在这里执行的 train_step 是当我们要求 TensorFlow 最小化交叉熵时获得的。这是计算梯度和更新权重和偏置的步骤。&lt;/p&gt;

&lt;p&gt;最终，我们还需要一些值来显示，以便我们可以追踪我们模型的性能。&lt;/p&gt;

&lt;p&gt;在训练回路中使用该代码来计算准确度和交叉熵（例如每 10 次迭代）：&lt;/p&gt;

&lt;p&gt;　　# success ?&lt;/p&gt;

&lt;p&gt;　　a,c = sess.run([accuracy, cross_entropy], feed_dict=train_data)&lt;/p&gt;

&lt;p&gt;通过在馈送 dictionary 中提供测试而不是训练数据，可以对测试数据进行同样的计算（例如每 100 次迭代计算一次。有 10,000 个测试数字，所以会耗费 CPU 一些时间）：&lt;/p&gt;

&lt;p&gt;　　# success on test data ?&lt;/p&gt;

&lt;p&gt;　　test&lt;em&gt;data={X: mnist.test.images, Y&lt;/em&gt;: mnist.test.labels}&lt;/p&gt;

&lt;p&gt;　　a,c = sess.run([accuracy, cross_entropy], feed=test_data)&lt;/p&gt;

&lt;p&gt;TensorFlow 和 Numpy 是朋友：在准备计算图时，你只需要操纵 TensorFlow 张量和命令，比如 tf.matmul, tf.reshape 等。&lt;/p&gt;

&lt;p&gt;然而，只要执行 Session.run 命令，它的返回值就是 Numpy 张量，即 Numpy 可以使用的 numpy.ndarray 对象以及基于它的所有科学计算库。这就是使用 matplotlib（基于 Numpy 的标准 Python 绘图库）为本实验构建实时可视化的方法。&lt;/p&gt;

&lt;p&gt;这个简单的模型已经能识别 92% 的数字了。这不错，但是你现在要显著地改善它。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/e65dd7cd3b2f43ab85279a8d39de470a_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;实验-增加层&#34;&gt;实验:增加层&lt;/h3&gt;

&lt;p&gt;为了提高识别的准确度，我们将为神经网络增加更多的层。第二层神经元将计算前一层神经元输出的加权和，而非计算像素的加权和。这里有一个 5 层全相连的神经网络的例子：&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/1b4c2da0004c41988eb4bd83f28449dd_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们继续用 softmax 来作为最后一层的激活函数，这也是为什么在分类这个问题上它性能优异的原因。但在中间层，我们要使用最经典的激活函数：sigmoid：在这一节中你的任务是为你的模型增加一到两个中间层以提高它的性能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/6e069d408df443c49317ccd7784874b8_th.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;答案可以在 mnist_2.0_five_layers_sigmoid.py 中找到。只有当你实在想不出来的时候再使用它！为了增加一个层，你需要为中间层增加一个额外的权重矩阵和一个额外的偏置向量：&lt;/p&gt;

&lt;p&gt;　　W1 = tf.Variable(tf.truncated_normal([28*28, 200] ,stddev=0.1))&lt;/p&gt;

&lt;p&gt;　　B1 = tf.Variable(tf.zeros([200]))&lt;/p&gt;

&lt;p&gt;　　W2 = tf.Variable(tf.truncated_normal([200, 10], stddev=0.1))&lt;/p&gt;

&lt;p&gt;　　B2 = tf.Variable(tf.zeros([10]))&lt;/p&gt;

&lt;p&gt;对，就这么做。通过 2 个中间层以及例子中 200 个和 100 个神经元，你现在应该能够把你的神经网络的准确度推高到 97% 了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/e60d8b29dad048fa8e5917c95c7a6153_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;实验-深度网络需要特别注意的地方&#34;&gt;实验：深度网络需要特别注意的地方&lt;/h3&gt;

&lt;p&gt;随着层数的增加，神经网络越来越难以收敛。但现在我们知道如何控制它们的行为了。这里是一些只用 1 行就可以实现的改进，当你看到准确度曲线出现如下情况的时候，这些小技巧会帮到你：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/5b31861eff624a32bca2e5c29169a7c1_th.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;修正线性单元（ReLU）激活函数&lt;/p&gt;

&lt;p&gt;在深度网络里，sigmoid 激活函数确实能带来很多问题。它把所有的值都挤到了 0 到 1 之间，而且当你重复做的时候，神经元的输出和它们的梯度都归零了。值得一提的是，出于历史原因，一些现代神经网络使用了 ReLU（修正线性单元），它大致是如下这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/a06abc6c13f743c28dd4b28018854629.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;升级 1/4：用 RELU 替换你所有的 sigmoid，然后你会得到一个更快的初始收敛并且当我们继续增加层的时候也避免了一些后续问题的产生。仅仅在代码中简单地用 tf.nn.relu 来替换 tf.nn.sigmoid 就可以了。&lt;/p&gt;

&lt;p&gt;一个更好的优化器&lt;/p&gt;

&lt;p&gt;在一个特别多维的空间里，就像当前这个情况——我们有 10K 量级的权值和偏置值——「鞍点 (saddle points）」会频繁出现。这些点不是局部最小值点，但它的梯度却是零，那么梯度降的优化会卡在这里。TensorFlow 有一系列可以用的优化器，包括一些带有一定的惯性，能够安全越过鞍点的优化器。&lt;/p&gt;

&lt;p&gt;升级 2/4：现在将你的 tf.train.GradientDescentOptimiser 替换为 tf.train.AdamOptimizer。&lt;/p&gt;

&lt;p&gt;随机初始化&lt;/p&gt;

&lt;p&gt;准确性一直卡在 0.1？你把你的权值初始化成随机值了没？对于偏置值，如果用 ReLU 的话，最好的办法就是把它们都初始化成小的正值，这样神经元一开始就会工作在 ReLU 的非零区域内。&lt;/p&gt;

&lt;p&gt;　　W = tf.Variable(tf.truncated_normal([K, L] ,stddev=0.1))&lt;/p&gt;

&lt;p&gt;　　B = tf.Variable(tf.ones([L])/10)&lt;/p&gt;

&lt;p&gt;升级 3/4：现在检查是否你所有的权值和偏置值都被初始化好了。上图所示的 0.1 会作为偏置值。&lt;/p&gt;

&lt;p&gt;不定值（NaN）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/18bf142ee7894aa18c015ddba8c645ab_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果你看到你的精确曲线陡然下滑并且调试口输出的交叉熵是 NaN，不用感到头疼，你其实是正在尝试计算 log(0)，而这肯定是个不定值（NaN）。还记得吗，交叉熵的计算涉及到对 softmax 层的输出取对数。鉴于 softmax 基本上是一个指数，它肯定不是 0，我们如果用 32 位精度的浮点运算就还好，exp(-100) 基本上可以算作是 0 了。&lt;/p&gt;

&lt;p&gt;很幸运，TensorFlow 有一个非常方便的函数可以在单步内计算 softmax 和交叉熵，它是以一种数值上较为稳定的方式实现的。如果要使用它，你需要在应用 softmax 之前将原始的权重和加上你最后一层的偏置隔离开来（在神经网络的术语里叫「logits」）。&lt;/p&gt;

&lt;p&gt;　　如果你模型的最后一行是这样的：&lt;/p&gt;

&lt;p&gt;　　Y = tf.nn.softmax(tf.matmul(Y4, W5) + B5)&lt;/p&gt;

&lt;p&gt;　　你需要把它替换成：&lt;/p&gt;

&lt;p&gt;　　Ylogits = tf.matmul(Y4, W5) + B5Y = tf.nn.softmax(Ylogits)&lt;/p&gt;

&lt;p&gt;　　并且你现在能以一种安全的方式计算交叉熵了：&lt;/p&gt;

&lt;p&gt;　　cross_entropy = tf.nn.softmax_cross_entropy_with&lt;em&gt;logits(Ylogits, Y&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;同样加上下面这行代码使得测试和训练的交叉熵能够同框显示：&lt;/p&gt;

&lt;p&gt;　　cross_entropy = tf.reduce_mean(cross_entropy)*100&lt;/p&gt;

&lt;p&gt;升级 4/4：请把 tf.nn.softmax_cross_entropy_with_logits 加到你的代码里。你也可以跳过这一步，等你真在你的输出里看到 NaN 以后再来做这步。现在，你已经准备好实现「深度」了。&lt;/p&gt;

&lt;h3 id=&#34;实验-学习速率衰退&#34;&gt;实验：学习速率衰退&lt;/h3&gt;

&lt;p&gt;通过两个、三个或者四个中间层，你现在可以将准确度提升至接近 98%，当然，你的迭代次数要达到 5000 次以上。不过你会发现你并不总是会得到这样的结果。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/a4492d6cbbb343aab07a355246c915de_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这些曲线很嘈杂，看看测试精确度吧：它在全百分比范围内跳上跳下。这意味着即使 0.003 的学习率我们还是太快了。但我们不能仅仅将学习率除以十或者永远不停地做训练。一个好的解决方案是开始很快随后将学习速率指数级衰减至比如说 0.0001。&lt;/p&gt;

&lt;p&gt;这个小改变的影响是惊人的。你会看到大部分的噪声消失了并且测试精确度持续稳定在 98% 以上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/41294f08d52d4959bb4b01c8e925f056_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再看看训练精确度曲线。在好多个 epoch 里都达到了 100%（一个 epoch=500 次迭代=全部训练图片训练一次）。第一次我们能很好地识别训练图片了。&lt;/p&gt;

&lt;p&gt;请把学习率衰退加到你的代码里。为了把一个不同的学习率在每次迭代时传给 AdamOptimizer，你需要定义一个新的占位符（placeholder）并在每次迭代时通过 feed_dict 赋给它一个新的参数。&lt;/p&gt;

&lt;p&gt;这里是一个指数级衰减的方程：lr = lrmin+(lrmax-lrmin)*exp(-i/2000) 答案可以在这个文件里找到：mnist_2.1_five_layers_relu_lrdecay.py。如果你被卡住了可以用它。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/260e6a3277984432adc3e945251e5f18_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;实验-dropout-过拟合&#34;&gt;实验：dropout、过拟合&lt;/h3&gt;

&lt;p&gt;你可能已经注意到在数千次迭代之后，测试和训练数据的交叉熵曲线开始不相连。学习算法只是在训练数据上做工作并相应地优化训练的交叉熵。它再也看不到测试数据了，所以这一点也不奇怪：过了一会儿它的工作不再对测试交叉熵产生任何影响，交叉熵停止了下降，有时甚至反弹回来。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/2b215ed2c1984612bdba47bf0dba1188_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;它不会立刻影响你模型对于真实世界的识别能力，但是它会使你运行的众多迭代毫无用处，而且这基本上是一个信号——告诉我们训练已经不能再为模型提供进一步改进了。这种无法连接通常会被标明「过拟合（overfitting）」，而且当你看到这个的时候，你可以尝试采用一种规范化（regularization）技术，称之为「dropout」。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/8ba81eadbd6f4383a4af3a8dc13bbe53_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在 dropout 里，在每一次训练迭代的时候，你可以从网络中随机地放弃一些神经元。你可以选择一个使神经元继续保留的概率 pkeep，通常是 50% 到 75% 之间，然后在每一次训练的迭代时，随机地把一些神经元连同它们的权重和偏置一起去掉。在一次迭代里，不同的神经元可以被一起去掉（而且你也同样需要等比例地促进剩余神经元的输出，以确保下一层的激活不会移动）。当测试你神经网络性能的时候，你再把所有的神经元都装回来 (pkeep=1)。&lt;/p&gt;

&lt;p&gt;TensorFlow 提供一个 dropout 函数可以用在一层神经网络的输出上。它随机地清零一些输出并且把剩下的提升 1/pkeep。这里是如何把它用在一个两层神经网络上的例子。&lt;/p&gt;

&lt;p&gt;　　# feed in 1 when testing, 0.75 when training&lt;/p&gt;

&lt;p&gt;　　pkeep = tf.placeholder(tf.float32)&lt;/p&gt;

&lt;p&gt;　　Y1 = tf.nn.relu(tf.matmul(X, W1) + B1)&lt;/p&gt;

&lt;p&gt;　　Y1d = tf.nn.dropout(Y1, pkeep)&lt;/p&gt;

&lt;p&gt;　　Y = tf.nn.softmax(tf.matmul(Y1d, W2) + B2)&lt;/p&gt;

&lt;p&gt;你现在可以在网络中每个中间层以后插入 dropout。如果你没时间深入阅读的话，这是本项目里的可选步骤。&lt;/p&gt;

&lt;p&gt;该解决方案可以在 &lt;a href=&#34;https://github.com/martin-gorner/tensorflow-mnist-tutorial/blob/master/mnist_2.2_five_layers_relu_lrdecay_dropout.py&#34;&gt;mnist_2.2_five_layers_relu_lrdecay_dropout.py&lt;/a&gt;里找到。如果你被难住了，可以用它。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/59419fef6dbd401aa484dfb9983712f7_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;你会看到测试损失已经被搞回来了，已经在可控范围内了，不过至少在这个例子中噪声重新出现了（如果你知道 dropout 的工作原理的话，这一点也不奇怪）。测试的准确度依然没变，这倒是有点小失望。这个「过拟合」一定还有其它原因。在我们继续进行下一步之前，我们先扼要重述一下我们到目前为止用过的所有工具：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/cfcb109bbbe040d29e61d02d78059124_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;无论我们做什么，我们看上去都不可能很显著地解决 98% 的障碍，而且我们的损失曲线依然显示「过拟合」无法连接。什么是真正的「过拟合」？过拟合发生在该神经网络学得「不好」的时候，在这种情况下该神经网络对于训练样本做得很好，对真实场景却并不是很好。有一些像 dropout 一样的规范化技术能够迫使它学习得更好，不过过拟合还有更深层的原因。&lt;/p&gt;

&lt;p&gt;基本的过拟合发生在一个神经网络针对手头的问题有太多的自由度的时候。想象一下我们有如此多的神经元以至于所组成的网络可以存储我们所有的训练图像并依靠特征匹配来识别它们。它会在真实世界的数据里迷失。一个神经网络必须有某种程度上的约束以使它能够归纳推理它在学习中所学到的东西。&lt;/p&gt;

&lt;p&gt;如果你只有很少的训练数据，甚至一个很小的网络都能够用心学习它。一般来说，你总是需要很多数据来训练神经网络。&lt;/p&gt;

&lt;p&gt;最后，如果你已经做完了所有的步骤，包括实验了不同大小的网络以确保它的自由度已经约束好了、采用了 dropout、并且训练了大量的数据，你可能会发现你还是被卡在了当前的性能层次上再也上不去了。这说明你的神经网络在它当前的形态下已经无法从你提供的数据中抽取到更多的信息了，就像我们这个例子这样。&lt;/p&gt;

&lt;p&gt;还记得我们如何使用我们的图像吗？是所有的像素都展平到一个向量里么？这是一个很糟糕的想法。手写的数字是由一个个形状组成的，当我们把像素展平后我们会丢掉这些形状信息。不过，有一种神经网络可以利用这些形状信息：卷积网络（convolutional network）。让我们来试试。&lt;/p&gt;

&lt;h3 id=&#34;理论-卷积网络&#34;&gt;理论：卷积网络&lt;/h3&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/0eb4bf030ecc488a8d2f990c11e7272c_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在卷积网络层中，一个「神经元」仅对该图像上的一个小部分的像素求加权和。然后，它通常会添加一个偏置单元，并且将得到的加权和传递给激活函数。与全连接网络相比，其最大的区别在于卷积网络的每个神经元重复使用相同的权重，而不是每个神经元都有自己的权重。&lt;/p&gt;

&lt;p&gt;在上面的动画中，你可以看到通过连续修改图片上两个方向的权重（卷积），能够获得与图片上的像素点数量相同的输出值（尽管在边缘处需要填充（padding））。&lt;/p&gt;

&lt;p&gt;要产生一个输出值平面，我们使用了一张 4x4 大小的彩色图片作为出输入。在这个动画当中，我们需要 4x4x3=48 个权重，这还不够，为了增加更多自由度，我们还需要选取不同组的权重值重复实验。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/cda66c477aa946eeba45408d4129b274_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;通过向权重张量添加一个维度，能够将两组或更多组的权重重写为一组权重，这样就给出了一个卷积层的权重张量的通用实现。由于输入、输出通道的数量都是参数，我们可以开始堆叠式（stacking）和链式（chaining）的卷积层。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/10228a2a4d134aa0aa3077cb019d34a9_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最后，我们需要提取信息。在最后一层中，我们仅仅想使用 10 个神经元来分类 0-9 十个不同的数字。传统上，这是通过「最大池化（max-pooling）」层来完成的。即使今天有许多更简单的方法能够实现这分类任务，但是，「最大池化」能够帮助我们直觉地理解卷积神经网络是怎么工作的。如果你认为在训练的过程中，我们的小块权重会发展成能够过滤基本形状（水平线、垂直线或曲线等）的过滤器（filter），那么，提取有用信息的方式就是识别输出层中哪种形状具有最大的强度。实际上，在最大池化层中，神经元的输出是在 2x2 的分组中被处理，最后仅仅保留输出最大强度的神经元。&lt;/p&gt;

&lt;p&gt;这里有一种更简单的方法：如果你是以一步两个像素移动图片上的滑块而不是以每步一个像素地移动图片上的滑块。这种方法就是有效的，今天的卷积网络仅仅使用了卷积层。&lt;/p&gt;

&lt;p&gt;让我们建立一个用于手写数字识别的卷积网络。在顶部，我们将使用 3 个卷积层；在底部，我们使用传统的 softmax 读出层，并将它们用完全连接层连接。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/d3ae69380cae4dddbfc0f3523a264f4e_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意，第二与第三卷积层神经元数量以 2x2 为倍数减少，这就解释了为什么它们的输出值从 28x28 减少为 14x14，然后再到 7x7。卷积层的大小变化使神经元的数量在每层下降约为：28x28x14≈3000-&amp;gt;14x14x8≈1500 → 7x7x12≈500 → 200。下一节中，我们将给出该网络的具体实现。&lt;/p&gt;

&lt;h3 id=&#34;实现-一个卷积网络&#34;&gt;实现：一个卷积网络&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/bf6ccfdee1bc440db5e14229a5799aa3_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了将我们的代码转化为卷积模型，我们需要为卷积层定义适当的权重张量，然后将该卷积层添加到模型中。我们已经理解到卷积层需要以下形式的权重张量。下面代码是用 TensorFlow 语法来对其初始化：&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/dee5ee4d2bda42298813d9819ce61a24_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　W = tf.Variable(tf.truncated_normal([4, 4, 3, 2], stddev=0.1))&lt;/p&gt;

&lt;p&gt;　　B = tf.Variable(tf.ones([2])/10) # 2 is the number of output channels&lt;/p&gt;

&lt;p&gt;在 TensorFlow 中，使用 tf.nn.conv2d 函数实现卷积层，该函数使用提供的权重在两个方向上扫描输入图片。这仅仅是神经元的加权和部分，你需要添加偏置单元并将加权和提供给激活函数。&lt;/p&gt;

&lt;p&gt;　　stride = 1 # output is still 28x28&lt;/p&gt;

&lt;p&gt;　　Ycnv = tf.nn.conv2d(X, W, strides=[1, stride, stride, 1], padding=&amp;lsquo;SAME&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;　　Y = tf.nn.relu(Ycnv + B)&lt;/p&gt;

&lt;p&gt;不要过分在意 stride 的复杂语法，查阅文档就能获取完整的详细信息。这里的填充（padding）策略是为了复制图片的边缘的像素。所有的数字都在一个统一的背景下，所以这仅仅是扩展了背景，并且不应该添加不需要的任何样式。&lt;/p&gt;

&lt;p&gt;现在该你了。修改你的模型并将其转化为卷积模型。你可以使用上图中的值来修改它，你可以减小你的学习速率但是务必先移除 dropout。&lt;/p&gt;

&lt;p&gt;你的模型的准确率应该会超过 98%，并且最终达到约 99%。眼看目标就要实现，我们不能停止！看看测试的交叉熵曲线。在你的头脑中，此时，是否解决方案正在形成？&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/cb5d786d95ac44a5a9bc42c90d212f69_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;99-准确率的挑战&#34;&gt;99% 准确率的挑战&lt;/h3&gt;

&lt;p&gt;调整你的神经网络的一个好方法：先去实现一个限制较多的神经网络，然后给它更多的自由度并且增加 dropout，使神经网络避免过拟合。最终你将得到一个相当不错的神经网络。&lt;/p&gt;

&lt;p&gt;例如，我们在第一层卷积层中仅仅使用了 4 个 patch，如果这些权重的 patch 在训练的过程中发展成不同的识别器，你可以直观地看到这对于解决我们的问题是不够的。手写数字模式远多于 4 种基本样式。&lt;/p&gt;

&lt;p&gt;因此，让我们稍微增加 patch 的数量，将我们卷积层中 patch 的数量从 4，8，12 增加到 6，12，24，并且在全连接层上添加 dropout。它们的神经元重复使用相同的权重，在一次训练迭代中，通过冻结（限制）一些不会对它们起作用的权重，dropout 能够有效地工作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/5792c4f41a734c44b4f1c3ee40e47742_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;加油吧，去打破 99％的限制。增加 patch 数量和通道的数量，如上图所示，在卷积层中添加 dropout。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/e2e13da25b6146f2b0274a19187e18c0_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;解决方案可以在文件 mnist_3.1_convolutional_bigger_dropout.py 中找到。&lt;/p&gt;

&lt;p&gt;使用上图所示的模型，在 10000 个测试的数字中，结果仅仅错误了 72 个。你可以在 MNIST 网站上发现，数字识别准确率的世界纪录大约为 99.7%，这仅比我们用 100 行 Python/TensorFlow 代码构建的模型的准确率高 0.4%。&lt;/p&gt;

&lt;p&gt;最后，不同的 dropout 使我们能够训练更大的卷积网络。增加神经网络的额外自由度，使模型的最终准确率从 98.9% 达到 99.1%。向卷积层中增加 dropout 不仅减少了测试误差，而且使我们模型的准确率突破 99%，甚至达到了 99.3%。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://img.mp.itc.cn/upload/20170124/70c0a9eed13d48e793d06de2317a006f_th.jpeg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;恭喜&#34;&gt;恭喜&lt;/h3&gt;

&lt;p&gt;你已经建立了你的第一个神经网络，并且训练精度达到了 99%。在这个学习过程中，你所学到的技术，并不局限于 MNIST 数据集。实际上，这些技术在训练神经网络的过程中被广泛使用。作为礼物，下面提供的内容可以用来帮助你回忆已经所学的内容。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在完成了完全神经网络和卷积网络后，你应该学习循环神经网络：&lt;a href=&#34;https://www.tensorflow.org/tutorials/recurrent/。&#34;&gt;https://www.tensorflow.org/tutorials/recurrent/。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在本教程中，你已经学习了如何在矩阵层次构建 TensorFlow 模型。Tensorflow 还有更高级的 API，称为 tf.learn：&lt;a href=&#34;https://www.tensorflow.org/tutorials/tflearn/&#34;&gt;https://www.tensorflow.org/tutorials/tflearn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;要在云上的分布式框架上训练，我们提供 Cloud ML 服务：&lt;a href=&#34;https://cloud.google.com/ml&#34;&gt;https://cloud.google.com/ml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;最后，我们希望收到你的反馈。如果你在发现了本实验中的些许错误，或者你认为有什么需要改进的地方，请告诉我们。我们通过 GitHub 处理反馈，&lt;a href=&#34;https://github.com/googlecodelabs/feedback/issues/new?title=[cloud-tensorflow-mnist]:&amp;amp;labels[]=content-platform&amp;amp;labels[]=cloud&#34;&gt;反馈链接&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;虽然看不懂，但是先混个脸熟，以后慢慢再看。本文大部分内容复制自&lt;a href=&#34;http://it.sohu.com/20170124/n479480999.shtml&#34;&gt;教程 | 没有博士学位，照样玩转TensorFlow深度学习&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes heapster监控插件安装文档</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-heapster-installation/</link>
      <pubDate>Wed, 05 Apr 2017 18:41:19 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-heapster-installation/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20170403064.jpg&#34; alt=&#34;嗑猫薄荷的白化孟加拉虎&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：嗑猫薄荷的白化孟加拉虎@北京动物园 Apr 3,2017）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;前面几篇文章中记录了我们&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-installation-on-centos/&#34;&gt;安装好了Kubernetes集群&lt;/a&gt;、&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-network-config/&#34;&gt;配置好了flannel网络&lt;/a&gt;、&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-dashboard-installation/&#34;&gt;安装了Kubernetes Dashboard&lt;/a&gt;，但是还没法查看Pod的监控信息，虽然kubelet默认集成了&lt;strong&gt;cAdvisor&lt;/strong&gt;（在每个node的4194端口可以查看到），但是很不方便，因此我们选择安装heapster。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;下载heapster的代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;直接现在Github上的最新代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;git pull https://github.com/kubernetes/heapster.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目前的最高版本是1.3.0。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;heapster/deploy/kube-config/influxdb&lt;/code&gt;目录下有几个&lt;code&gt;yaml&lt;/code&gt;文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grafana-deployment.yaml
grafana-service.yaml
heapster-deployment.yaml
heapster-service.yaml
influxdb-deployment.yaml
influxdb-service.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们再看下用了哪些镜像：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grafana-deployment.yaml:16:        image: gcr.io/google_containers/heapster-grafana-amd64:v4.0.2
heapster-deployment.yaml:16:        image: gcr.io/google_containers/heapster-amd64:v1.3.0-beta.1
influxdb-deployment.yaml:16:        image: gcr.io/google_containers/heapster-influxdb-amd64:v1.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;下载镜像&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们下载好了这些images后，存储到私有镜像仓库里：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sz-pg-oam-docker-hub-001.tendcloud.com/library/heapster-amd64:v1.3.0-beta.1&lt;/li&gt;
&lt;li&gt;sz-pg-oam-docker-hub-001.tendcloud.com/library/heapster-grafana-amd64:v4.0.2&lt;/li&gt;
&lt;li&gt;sz-pg-oam-docker-hub-001.tendcloud.com/library/heapster-influxdb-amd64:v1.1.1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我已经将官方镜像克隆到了&lt;a href=&#34;www.tenxcloud.com&#34;&gt;时速云&lt;/a&gt;上，镜像地址：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;index.tenxcloud.com/jimmy/heapster-amd64:v1.3.0-beta.1&lt;/li&gt;
&lt;li&gt;index.tenxcloud.com/jimmy/heapster-influxdb-amd64:v1.1.1&lt;/li&gt;
&lt;li&gt;index.tenxcloud.com/jimmy/heapster-grafana-amd64:v4.0.2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要的可以去下载，下载前需要用时速云账户登陆，然后再执行pull操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker login index.tendcloud.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;p&gt;参考&lt;a href=&#34;https://github.com/kubernetes/heapster/blob/master/docs/influxdb.md&#34;&gt;Run Heapster in a Kubernetes cluster with an InfluxDB backend and a Grafana UI&lt;/a&gt;和&lt;a href=&#34;https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md&#34;&gt;Configuring Source&lt;/a&gt;，需要修改yaml文件中的几个配置。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先修改三个deployment.yaml文件，将其中的镜像文件地址改成我们自己的私有镜像仓库的&lt;/li&gt;
&lt;li&gt;修改heapster-deployment.yaml文件中的&lt;code&gt;--source&lt;/code&gt;参数为&lt;code&gt;—source=kubernetes:http://sz-pg-oam-docker-test-001.tendcloud.com:8080?inClusterConfig=false&amp;amp;useServiceAccount=false&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;修改完配置的&lt;code&gt;heapster-deployment.yaml&lt;/code&gt;文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: heapster
  namespace: kube-system
spec:
  replicas: 1
  template:
    metadata:
      labels:
        task: monitoring
        k8s-app: heapster
    spec:
      containers:
      - name: heapster
        image: sz-pg-oam-docker-hub-001.tendcloud.com/library/heapster-amd64:v1.3.0-beta.1
        imagePullPolicy: IfNotPresent
        command:
        - /heapster
        - --source=kubernetes:http://sz-pg-oam-docker-test-001.tendcloud.com:8080?inClusterConfig=false&amp;amp;useServiceAccount=false
        - --sink=influxdb:http://monitoring-influxdb:8086
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;启动&#34;&gt;启动&lt;/h2&gt;

&lt;p&gt;在准备好镜像和修改完配置文件后就可以一键启动了，这不就是使用kbuernetes的方便之处吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启动heaspter&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl create -f deploy/kube-config/influxdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;查看状态&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl get -f deploy/kube-config/influxdb/
NAME                        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deploy/monitoring-grafana   1         1         1            1           1h

NAME                     CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
svc/monitoring-grafana   10.254.250.27   &amp;lt;none&amp;gt;        80/TCP    1h

NAME              DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deploy/heapster   1         1         1            1           1h

NAME           CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
svc/heapster   10.254.244.187   &amp;lt;none&amp;gt;        80/TCP    1h

NAME                         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deploy/monitoring-influxdb   1         1         1            1           1h

NAME                      CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
svc/monitoring-influxdb   10.254.151.157   &amp;lt;none&amp;gt;        8086/TCP   1h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;查看页面&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在再打开Dashboard页面就可以看到CPU和Memory的监控信息了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/kubernetes-heapster-01.jpg&#34; alt=&#34;kubernetes-heapster&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;虽然在安装了heapster插件后可以在dashboard中看到CPU和Memory的监控信息，但是这仅仅是近实时的监控，收集的metrics被保存到了InfluxDB中，还可以通过Kibana或者Grafana来展示更详细的信息和历史数据，还是有很多事情可以做的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes Dashboard/Web UI安装全记录</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-dashboard-installation/</link>
      <pubDate>Wed, 05 Apr 2017 14:28:51 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-dashboard-installation/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2017040301.jpg&#34; alt=&#34;晒太阳的袋鼠&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：晒太阳的袋鼠@北京动物园 Apr 3,2017）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;前几天&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-installation-on-centos/&#34;&gt;在CentOS7.2上安装Kubernetes1.6&lt;/a&gt;和安装好&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-network-config/&#34;&gt;flannel网络配置&lt;/a&gt;，今天我们来安装下kuberentnes的dashboard。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/dashboard&#34;&gt;Dashboard&lt;/a&gt;是Kubernetes的一个插件，代码在单独的开源项目里。1年前还是特别简单的一个UI，只能在上面查看pod的信息和部署pod而已，现在已经做的跟&lt;a href=&#34;https://www.docker.com/enterprise-edition&#34;&gt;Docker Enterprise Edition&lt;/a&gt;的&lt;strong&gt;Docker Datacenter&lt;/strong&gt;很像了。&lt;/p&gt;

&lt;h2 id=&#34;安装dashboard&#34;&gt;安装Dashboard&lt;/h2&gt;

&lt;p&gt;官网的安装文档&lt;a href=&#34;https://kubernetes.io/docs/user-guide/ui/，其实官网是让我们使用现成的image来用kubernetes部署即可。&#34;&gt;https://kubernetes.io/docs/user-guide/ui/，其实官网是让我们使用现成的image来用kubernetes部署即可。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先需要一个&lt;strong&gt;kubernetes-dashboard.yaml&lt;/strong&gt;的配置文件，可以直接在&lt;a href=&#34;https://github.com/kubernetes/dashboard/blob/master/src/deploy/kubernetes-dashboard.yaml&#34;&gt;Github的src/deploy/kubernetes-dashboard.yaml&lt;/a&gt;下载。&lt;/p&gt;

&lt;p&gt;我们能看下这个文件的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Copyright 2015 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Configuration to deploy release version of the Dashboard UI.
#
# Example usage: kubectl create -f &amp;lt;this_file&amp;gt;

kind: Deployment
apiVersion: extensions/v1beta1
metadata:
  labels:
    app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kube-system
spec:
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: kubernetes-dashboard
  template:
    metadata:
      labels:
        app: kubernetes-dashboard
      # Comment the following annotation if Dashboard must not be deployed on master
      annotations:
        scheduler.alpha.kubernetes.io/tolerations: |
          [
            {
              &amp;quot;key&amp;quot;: &amp;quot;dedicated&amp;quot;,
              &amp;quot;operator&amp;quot;: &amp;quot;Equal&amp;quot;,
              &amp;quot;value&amp;quot;: &amp;quot;master&amp;quot;,
              &amp;quot;effect&amp;quot;: &amp;quot;NoSchedule&amp;quot;
            }
          ]
    spec:
      containers:
      - name: kubernetes-dashboard
        image: sz-pg-oam-docker-hub-001.tendcloud.com/library/kubernetes-dashboard-amd64:v1.6.0
        imagePullPolicy: Always
        ports:
        - containerPort: 9090
          protocol: TCP
        args:
          # Uncomment the following line to manually specify Kubernetes API server Host
          # If not specified, Dashboard will attempt to auto discover the API server and connect
          # to it. Uncomment only if the default does not work.
          # - --apiserver-host=http://my-address:port
          - --apiserver-host=http://sz-pg-oam-docker-test-001.tendcloud.com:8080
        livenessProbe:
          httpGet:
            path: /
            port: 9090
          initialDelaySeconds: 30
          timeoutSeconds: 30
---
kind: Service
apiVersion: v1
metadata:
  labels:
    app: kubernetes-dashboard
  name: kubernetes-dashboard
  namespace: kube-system
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: 9090
  selector:
    app: kubernetes-dashboard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⚠️ 官方提供的image名为&lt;code&gt;gcr.io/google_containers/kubernetes-dashboard-amd64:v1.6.0&lt;/code&gt;，需要翻墙才能访问，我自己拉下来push到我们的私有镜像仓库了。我将这个镜像push到了docker hub上，如果你无法翻墙的话，可以到下载这个镜像：&lt;code&gt;index.tenxcloud.com/jimmy/kubernetes-dashboard-amd64:v1.6.0&lt;/code&gt;。时速云的镜像存储，速度就是快。&lt;/p&gt;

&lt;p&gt;准备好image后就可以部署了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl create -f kubernetes-dashboard.yaml
deployment &amp;quot;kubernetes-dashboard&amp;quot; created
service &amp;quot;kubernetes-dashboard&amp;quot; created
$kubectl get -f kubernetes-dashboard.yaml
NAME                          DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deploy/kubernetes-dashboard   1         1         1            1           9s

NAME                       CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
svc/kubernetes-dashboard   10.254.113.226   &amp;lt;nodes&amp;gt;       80:31370/TCP   8s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就可以访问&lt;a href=&#34;http://sz-pg-oam-docker-test-001.tendcloud.com:8080/ui了，效果如图：&#34;&gt;http://sz-pg-oam-docker-test-001.tendcloud.com:8080/ui了，效果如图：&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/kubernetes-dashboard-01.jpg&#34; alt=&#34;kubernetes-dashboard&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;troubleshooting&#34;&gt;Troubleshooting&lt;/h2&gt;

&lt;h3 id=&#34;如果你没启动service-account身份认证&#34;&gt;如果你没启动Service Account身份认证&lt;/h3&gt;

&lt;p&gt;那就好办了，检查下你的&lt;strong&gt;kubernetes-dashboard.yaml&lt;/strong&gt;文件，看看是不是API Server地址配错了，或者查看下pod的log，我就是在log里发现，原来API Server的主机名无法解析导致服务启动失败。在DNS里添加API Server主机的DNS记录即可。&lt;/p&gt;

&lt;h3 id=&#34;如果你启动api-server的serviceaccount身份认证&#34;&gt;如果你启动API Server的ServiceAccount身份认证&lt;/h3&gt;

&lt;p&gt;启动service的时候出错。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl --namespace=kube-system logs kubernetes-dashboard-1680927228-pdv45
Using HTTP port: 9090
Error while initializing connection to Kubernetes apiserver. This most likely means that the cluster is misconfigured (e.g., it has invalid apiserver certificates or service accounts configuration) or the --apiserver-host param points to a server that does not exist. Reason: open /var/run/secrets/kubernetes.io/serviceaccount/token: no such file or directory
Refer to the troubleshooting guide for more information: https://github.com/kubernetes/dashboard/blob/master/docs/user-guide/troubleshooting.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/dashboard/blob/master/docs/user-guide/troubleshooting.md&#34;&gt;troubleshooting.md&lt;/a&gt;文件已经说明了，这是可能是你配置API server地址或&lt;strong&gt;Service Account&lt;/strong&gt;的问题。&lt;/p&gt;

&lt;p&gt;如果是配置Service Account的问题，可以借鉴Tony Bai的&lt;a href=&#34;http://tonybai.com/2017/01/19/install-dashboard-addon-for-k8s/&#34;&gt;Kubernetes集群Dashboard插件安装&lt;/a&gt;这篇文章。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启动&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kubectl proxy --address=&#39;0.0.0.0&#39; --accept-hosts=&#39;^*$&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;报错信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;kind&amp;quot;: &amp;quot;Status&amp;quot;,
  &amp;quot;apiVersion&amp;quot;: &amp;quot;v1&amp;quot;,
  &amp;quot;metadata&amp;quot;: {},
  &amp;quot;status&amp;quot;: &amp;quot;Failure&amp;quot;,
  &amp;quot;message&amp;quot;: &amp;quot;no endpoints available for service \&amp;quot;kubernetes-dashboard\&amp;quot;&amp;quot;,
  &amp;quot;reason&amp;quot;: &amp;quot;ServiceUnavailable&amp;quot;,
  &amp;quot;code&amp;quot;: 503
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# start a container that contains curl
$ kubectl run test --image=sz-pg-oam-docker-hub-001.tendcloud.com/library/curl:latest -- sleep 10000
$kubectl get pod
NAME                     READY     STATUS    RESTARTS   AGE
test-2428763157-pxkps    1/1       Running   0          6s
$kubectl exec test-2428763157-pxkps ls /var/run/secrets/kubernetes.io/serviceaccount/
ls: cannot access /var/run/secrets/kubernetes.io/serviceaccount/: No such file or directory
$kubectl get secrets
No resources found.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/var/run/secrets/kubernetes.io/serviceaccount/&lt;/code&gt;这个目录还是不存在，我们安装的Kubernetes压根就没有设置secret。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/dashboard/blob/master/docs/user-guide/troubleshooting.md&#34;&gt;troubleshooting.md&lt;/a&gt;上说需要用&lt;code&gt;—admission-control&lt;/code&gt;配置API Server，在配置这个之前还要了解下&lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/&#34;&gt;Service Accounts&lt;/a&gt;和&lt;a href=&#34;https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/&#34;&gt;如何管理Service Accounts&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;一年前我安装Kubernetes Dashboard（那时候好像还叫Kube-UI）的时候没有其功能还极其不完善，经过一年多的发展，已经有模有样了，如果不启用&lt;strong&gt;Service Account&lt;/strong&gt;的话，安装Dashboard还是很简单的。接下来我还要在Dashboard上安装其它Add-on，如Heapster用来监控Pod状态。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes基于flannel的网络配置</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-network-config/</link>
      <pubDate>Fri, 31 Mar 2017 11:05:18 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-network-config/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2014100402.jpg&#34; alt=&#34;西安鼓楼&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：西安鼓楼 Oct 4,2014）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;书接上文&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-installation-on-centos/&#34;&gt;在CentOS中安装Kubernetes详细指南&lt;/a&gt;，这是一个系列文章，作为学习Kubernetes的心路历程吧。&lt;/p&gt;

&lt;p&gt;本文主要讲解&lt;strong&gt;Kubernetes的网络配置&lt;/strong&gt;，👆文中有一个安装&lt;strong&gt;Flannel&lt;/strong&gt;的步骤，但是安装好后并没有相应的配置说明。&lt;/p&gt;

&lt;h2 id=&#34;配置flannel&#34;&gt;配置flannel&lt;/h2&gt;

&lt;p&gt;我们直接使用的yum安装的flannle，安装好后会生成&lt;code&gt;/usr/lib/systemd/system/flanneld.service&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Flanneld overlay address etcd agent
After=network.target
After=network-online.target
Wants=network-online.target
After=etcd.service
Before=docker.service

[Service]
Type=notify
EnvironmentFile=/etc/sysconfig/flanneld
EnvironmentFile=-/etc/sysconfig/docker-network
ExecStart=/usr/bin/flanneld-start $FLANNEL_OPTIONS
ExecStartPost=/usr/libexec/flannel/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/docker
Restart=on-failure

[Install]
WantedBy=multi-user.target
RequiredBy=docker.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到flannel环境变量配置文件在&lt;code&gt;/etc/sysconfig/flanneld&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ini&#34;&gt;# Flanneld configuration options  

# etcd url location.  Point this to the server where etcd runs
FLANNEL_ETCD_ENDPOINTS=&amp;quot;http://sz-pg-oam-docker-test-001.tendcloud.com:2379&amp;quot;

# etcd config key.  This is the configuration key that flannel queries
# For address range assignment
FLANNEL_ETCD_PREFIX=&amp;quot;/kube-centos/network&amp;quot;

# Any additional options that you want to pass
#FLANNEL_OPTIONS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;etcd的地址&lt;code&gt;FLANNEL_ETCD_ENDPOINT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;etcd查询的目录，包含docker的IP地址段配置。&lt;code&gt;FLANNEL_ETCD_PREFIX&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;在etcd中创建网络配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行下面的命令为docker分配IP地址段。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;etcdctl mkdir /kube-centos/network
etcdctl mk /kube-centos/network/config &amp;quot;{ \&amp;quot;Network\&amp;quot;: \&amp;quot;172.30.0.0/16\&amp;quot;, \&amp;quot;SubnetLen\&amp;quot;: 24, \&amp;quot;Backend\&amp;quot;: { \&amp;quot;Type\&amp;quot;: \&amp;quot;vxlan\&amp;quot; } }&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置Docker&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Flannel的&lt;a href=&#34;https://github.com/coreos/flannel/blob/master/Documentation/running.md&#34;&gt;文档&lt;/a&gt;中有写&lt;strong&gt;Docker Integration&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;Docker daemon accepts &lt;code&gt;--bip&lt;/code&gt; argument to configure the subnet of the docker0 bridge. It also accepts &lt;code&gt;--mtu&lt;/code&gt; to set the MTU for docker0 and veth devices that it will be creating. Since flannel writes out the acquired subnet and MTU values into a file, the script starting Docker can source in the values and pass them to Docker daemon:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source /run/flannel/subnet.env
docker daemon --bip=${FLANNEL_SUBNET} --mtu=${FLANNEL_MTU} &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Systemd users can use &lt;code&gt;EnvironmentFile&lt;/code&gt; directive in the .service file to pull in &lt;code&gt;/run/flannel/subnet.env&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下载flannel github release中的tar包，解压后会获得一个&lt;strong&gt;mk-docker-opts.sh&lt;/strong&gt;文件。&lt;/p&gt;

&lt;p&gt;这个文件是用来&lt;code&gt;Generate Docker daemon options based on flannel env file&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;执行&lt;code&gt;./mk-docker-opts.sh -i&lt;/code&gt;将会生成如下两个文件环境变量文件。&lt;/p&gt;

&lt;p&gt;/run/flannel/subnet.env&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FLANNEL_NETWORK=172.30.0.0/16
FLANNEL_SUBNET=172.30.46.1/24
FLANNEL_MTU=1450
FLANNEL_IPMASQ=false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/run/docker_opts.env&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DOCKER_OPT_BIP=&amp;quot;--bip=172.30.46.1/24&amp;quot;
DOCKER_OPT_IPMASQ=&amp;quot;--ip-masq=true&amp;quot;
DOCKER_OPT_MTU=&amp;quot;--mtu=1450&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在查询etcd中的内容可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$etcdctl ls /kube-centos/network/subnets
/kube-centos/network/subnets/172.30.14.0-24
/kube-centos/network/subnets/172.30.38.0-24
/kube-centos/network/subnets/172.30.46.0-24
$etcdctl get /kube-centos/network/config
{ &amp;quot;Network&amp;quot;: &amp;quot;172.30.0.0/16&amp;quot;, &amp;quot;SubnetLen&amp;quot;: 24, &amp;quot;Backend&amp;quot;: { &amp;quot;Type&amp;quot;: &amp;quot;vxlan&amp;quot; } }
$etcdctl get /kube-centos/network/subnets/172.30.14.0-24
{&amp;quot;PublicIP&amp;quot;:&amp;quot;172.20.0.114&amp;quot;,&amp;quot;BackendType&amp;quot;:&amp;quot;vxlan&amp;quot;,&amp;quot;BackendData&amp;quot;:{&amp;quot;VtepMAC&amp;quot;:&amp;quot;56:27:7d:1c:08:22&amp;quot;}}
$etcdctl get /kube-centos/network/subnets/172.30.38.0-24
{&amp;quot;PublicIP&amp;quot;:&amp;quot;172.20.0.115&amp;quot;,&amp;quot;BackendType&amp;quot;:&amp;quot;vxlan&amp;quot;,&amp;quot;BackendData&amp;quot;:{&amp;quot;VtepMAC&amp;quot;:&amp;quot;12:82:83:59:cf:b8&amp;quot;}}
$etcdctl get /kube-centos/network/subnets/172.30.46.0-24
{&amp;quot;PublicIP&amp;quot;:&amp;quot;172.20.0.113&amp;quot;,&amp;quot;BackendType&amp;quot;:&amp;quot;vxlan&amp;quot;,&amp;quot;BackendData&amp;quot;:{&amp;quot;VtepMAC&amp;quot;:&amp;quot;e6:b2:fd:f6:66:96&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;设置docker0网桥的IP地址&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;source /run/flannel/subnet.env
ifconfig docker0 $FLANNEL_SUBNET
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样docker0和flannel网桥会在同一个子网中，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;6: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN 
    link/ether 02:42:da:bf:83:a2 brd ff:ff:ff:ff:ff:ff
    inet 172.30.38.1/24 brd 172.30.38.255 scope global docker0
       valid_lft forever preferred_lft forever
7: flannel.1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue state UNKNOWN 
    link/ether 9a:29:46:61:03:44 brd ff:ff:ff:ff:ff:ff
    inet 172.30.38.0/32 scope global flannel.1
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就可以重启docker了。&lt;/p&gt;

&lt;p&gt;重启了docker后还要重启kubelet，这时又遇到问题，kubelet启动失败。报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Mar 31 16:44:41 sz-pg-oam-docker-test-002.tendcloud.com kubelet[81047]: error: failed to run Kubelet: failed to create kubelet: misconfiguration: kubelet cgroup driver: &amp;quot;cgroupfs&amp;quot; is different from docker cgroup driver: &amp;quot;systemd&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是kubelet与docker的&lt;strong&gt;cgroup driver&lt;/strong&gt;不一致导致的，kubelet启动的时候有个&lt;code&gt;—cgroup-driver&lt;/code&gt;参数可以指定为&amp;rdquo;cgroupfs&amp;rdquo;或者“systemd”。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--cgroup-driver string                                    Driver that the kubelet uses to manipulate cgroups on the host.  Possible values: &#39;cgroupfs&#39;, &#39;systemd&#39; (default &amp;quot;cgroupfs&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;启动flannel&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl daemon-reload
systemctl start flanneld
systemctl status flanneld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新登录这三台主机，可以看到每台主机都多了一个IP。&lt;/p&gt;

&lt;p&gt;参考Kubernetes官方文档的&lt;a href=&#34;https://kubernetes.io/docs/tutorials/stateless-application/expose-external-ip-address/&#34;&gt;Exposing an External IP Address to Access an Application in a Cluster&lt;/a&gt;，官方使用的Hello World测试，我们启动Nginx服务测试。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;#启动nginx的pod
kubectl run nginx --replicas=2 --labels=&amp;quot;run=load-balancer-example&amp;quot; --image=sz-pg-oam-docker-hub-001.tendcloud.com/library/nginx:1.9  --port=80
#创建名为example-service的服务
kubectl expose deployment nginx --type=NodePort --name=example-service
#查看状态
kubectl get deployments nginx
kubectl describe deployments nginx
kubectl get replicasets
kubectl describe replicasets
kubectl describe svc example-service
###################################################
Name:			example-service
Namespace:		default
Labels:			run=load-balancer-example
Annotations:		&amp;lt;none&amp;gt;
Selector:		run=load-balancer-example
Type:			NodePort
IP:			10.254.180.209
Port:			&amp;lt;unset&amp;gt;	80/TCP
NodePort:		&amp;lt;unset&amp;gt;	32663/TCP
Endpoints:		172.30.14.2:80,172.30.46.2:80
Session Affinity:	None
Events:			&amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们上面启动的serivce的type是&lt;strong&gt;NodePort&lt;/strong&gt;，Kubernetes的service支持三种类型的service，参考&lt;a href=&#34;http://www.cnblogs.com/xuxinkun/p/5331728.html&#34;&gt;Kubernetes Serivce分析&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;现在访问三台物理机的IP:80端口就可以看到nginx的页面了。&lt;/p&gt;

&lt;p&gt;稍等一会在访问ClusterIP + Port也可以访问到nginx。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$curl 10.254.180.209:80
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Welcome to nginx!&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;For online documentation and support please refer to
&amp;lt;a href=&amp;quot;http://nginx.org/&amp;quot;&amp;gt;nginx.org&amp;lt;/a&amp;gt;.&amp;lt;br/&amp;gt;
Commercial support is available at
&amp;lt;a href=&amp;quot;http://nginx.com/&amp;quot;&amp;gt;nginx.com&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Thank you for using nginx.&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;虚拟地址&#34;&gt;虚拟地址&lt;/h2&gt;

&lt;p&gt;Kubernetes中的Service了使用了虚拟地址；该地址无法ping通过，但可以访问其端口。通过下面的命令可以看到，该虚拟地址是若干条iptables的规则。到10.254.124.145:8080端口的请求会被重定向到172.30.38.2或172.30.46.2的8080端口。这些规则是由kube-proxy生成；如果需要某台机器可以访问Service，则需要在该主机启动kube-proxy。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看service的iptables&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$iptables-save|grep example-service
-A KUBE-NODEPORTS -p tcp -m comment --comment &amp;quot;default/example-service:&amp;quot; -m tcp --dport 32663 -j KUBE-MARK-MASQ
-A KUBE-NODEPORTS -p tcp -m comment --comment &amp;quot;default/example-service:&amp;quot; -m tcp --dport 32663 -j KUBE-SVC-BR4KARPIGKMRMN3E
-A KUBE-SEP-NCPBOLUH5XTTHG3E -s 172.30.46.2/32 -m comment --comment &amp;quot;default/example-service:&amp;quot; -j KUBE-MARK-MASQ
-A KUBE-SEP-NCPBOLUH5XTTHG3E -p tcp -m comment --comment &amp;quot;default/example-service:&amp;quot; -m tcp -j DNAT --to-destination 172.30.46.2:80
-A KUBE-SEP-ONEKQBIWICF7RAR3 -s 172.30.14.2/32 -m comment --comment &amp;quot;default/example-service:&amp;quot; -j KUBE-MARK-MASQ
-A KUBE-SEP-ONEKQBIWICF7RAR3 -p tcp -m comment --comment &amp;quot;default/example-service:&amp;quot; -m tcp -j DNAT --to-destination 172.30.14.2:80
-A KUBE-SERVICES -d 10.254.180.209/32 -p tcp -m comment --comment &amp;quot;default/example-service: cluster IP&amp;quot; -m tcp --dport 80 -j KUBE-SVC-BR4KARPIGKMRMN3E
-A KUBE-SVC-BR4KARPIGKMRMN3E -m comment --comment &amp;quot;default/example-service:&amp;quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-ONEKQBIWICF7RAR3
-A KUBE-SVC-BR4KARPIGKMRMN3E -m comment --comment &amp;quot;default/example-service:&amp;quot; -j KUBE-SEP-NCPBOLUH5XTTHG3E
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;查看clusterIP的iptables&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$iptables -t nat -nL|grep 10.254
KUBE-SVC-NPX46M4PTMTKRN6Y  tcp  --  0.0.0.0/0            10.254.0.1           /* default/kubernetes:https cluster IP */ tcp dpt:443
KUBE-SVC-BR4KARPIGKMRMN3E  tcp  --  0.0.0.0/0            10.254.180.209       /* default/example-service: cluster IP */ tcp dpt:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到在PREROUTING环节，k8s设置了一个target: KUBE-SERVICES。而KUBE-SERVICES下面又设置了许多target，一旦destination和dstport匹配，就会沿着chain进行处理。&lt;/p&gt;

&lt;p&gt;比如：当我们在pod网络curl 10.254.198.44 80时，匹配到下面的KUBE-SVC-BR4KARPIGKMRMN3E target：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KUBE-SVC-BR4KARPIGKMRMN3E  tcp  --  0.0.0.0/0            10.254.180.209       /* default/example-service: cluster IP */ tcp dpt:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考&lt;a href=&#34;http://tonybai.com/2017/01/17/understanding-flannel-network-for-kubernetes/&#34;&gt;理解Kubernetes网络之Flannel网络&lt;/a&gt;，Tony Bai的文章中有对flannel的详细介绍。&lt;/p&gt;

&lt;h2 id=&#34;遇到的问题&#34;&gt;遇到的问题&lt;/h2&gt;

&lt;p&gt;在设置网络的过程中遇到了很多问题，记录如下。&lt;/p&gt;

&lt;h3 id=&#34;问题一&#34;&gt;问题一&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Kube-proxy开放的&lt;strong&gt;NodePort&lt;/strong&gt;端口无法访问。即无法使用NodeIP加NodePort的方式访问service，而且本地telnet也不通，但是端口确确实实在那。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;已解决&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实这不是问题，是因为从上面的操作记录中我们可以看到，&lt;strong&gt;在启动Nginx的Pod&lt;/strong&gt;时，指定port为80即可。以ClusterIP + Port的方式访问serivce需要等一段时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;反思&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个问题困扰了我们差不多两天时间，出现这个问题的根源还是因为&lt;u&gt;思想观念没有从运行docker的命令中解放出来&lt;/u&gt;,还把&lt;code&gt;kubelet run —port&lt;/code&gt;当成是docker run中的端口映射，这种想法是大错特错的，该端口是image中的应用实际暴露的端口，如nginx的80端口。😔&lt;/p&gt;

&lt;h3 id=&#34;问题二&#34;&gt;问题二&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在没有删除service和deploy的情况下就重启kubelet的时候，会遇到kubelet启动失败的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;出错信息&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Apr 01 14:24:08 sz-pg-oam-docker-test-001.tendcloud.com kubelet[103932]: I0401 14:24:08.359839  103932 kubelet.go:1752] skipping pod synchronization - [Failed to start ContainerManager failed to initialise top level QOS containers: failed to create top level Burstable QOS cgroup : Unit kubepods-burstable.slice already exists.]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.osbaike.net/article-show-id-229028.html&#34;&gt;Kubernetes Resource QoS机制解读&lt;/a&gt;，这篇文章详细介绍了QoS的机制。&lt;/p&gt;

&lt;p&gt;Kubernetes根据Pod中Containers Resource的&lt;code&gt;request&lt;/code&gt;和&lt;code&gt;limit&lt;/code&gt;的值来定义Pod的QoS Class。&lt;/p&gt;

&lt;p&gt;对于每一种Resource都可以将容器分为3中QoS Classes: Guaranteed, Burstable, and Best-Effort，它们的QoS级别依次递减。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Guaranteed&lt;/strong&gt;：如果Pod中所有Container的所有Resource的&lt;code&gt;limit&lt;/code&gt;和&lt;code&gt;request&lt;/code&gt;都相等且不为0，则这个Pod的QoS Class就是Guaranteed。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Burstable&lt;/strong&gt;：除了符合Guaranteed和Best-Effort的场景，其他场景的Pod QoS Class都属于Burstable。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Best-Effort&lt;/strong&gt;：如果Pod中所有容器的所有Resource的request和limit都没有赋值，则这个Pod的QoS Class就是Best-Effort。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个暂时还没找到根本的解决办法，参考Github上的&lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/43856&#34;&gt;Failed to start ContainerManager failed to initialize top level QOS containers #43856&lt;/a&gt;，重启主机后确实正常了，不过这只是临时解决方法。&lt;/p&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;其实昨天就已经安装完毕了，是我们使用的姿势不对，白白耽误这么长时间，身边差个老司机啊，滴～学生卡。&lt;/p&gt;

&lt;p&gt;感谢&lt;a href=&#34;tonybai.com&#34;&gt;Tony Bai&lt;/a&gt;、&lt;a href=&#34;https://godliness.github.io/&#34;&gt;Peter Ma&lt;/a&gt;的大力支持。&lt;/p&gt;

&lt;p&gt;Apr 1,2017 愚人节，东直门&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TensorFlow实战（才云郑泽宇著）读书笔记——第三章TensorFlow入门</title>
      <link>http://rootsongjc.github.io/blogs/tensorflow-practice-03/</link>
      <pubDate>Thu, 30 Mar 2017 21:34:33 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/tensorflow-practice-03/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2015052401.jpg&#34; alt=&#34;扬州东关&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：扬州东关 May 24,2015）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这是我阅读&lt;a href=&#34;caicloud.io&#34;&gt;才云科技&lt;/a&gt;郑泽宇的《TensorFlow实战Google深度学习框架》的读书笔记系列文章，按照文章的章节顺序来写的。整本书的笔记归档在&lt;a href=&#34;http://rootsongjc.github.io/tags/tensorflow-practice-reading-notes/&#34;&gt;这里&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;P.S 本书的&lt;strong&gt;官方读者交流微信群（作者也在群里）&lt;/strong&gt;已经超过100人，您可以先加我微信后我拉您进去，我的二维码在&lt;a href=&#34;rootsongjc.github.io/about&#34;&gt;这里&lt;/a&gt;，或者直接搜索我的微信号jimmysong。&lt;/p&gt;

&lt;p&gt;这一章从三个角度带大家入门。&lt;/p&gt;

&lt;p&gt;分别是TensorFlow的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算模型&lt;/li&gt;
&lt;li&gt;数据模型&lt;/li&gt;
&lt;li&gt;运行模型&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-1-tensorflow的计算模型-图计算&#34;&gt;3.1 TensorFlow的计算模型——图计算&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;计算图&lt;/strong&gt;是TensorFlow中的一个最基本的概念，&lt;u&gt;TensorFlow中的所有计算都会转化成计算图上的节点&lt;/u&gt;。&lt;/p&gt;

&lt;p&gt;其实TensorFlow的名字已经暗示了它的实现方式了，&lt;strong&gt;Tensor&lt;/strong&gt;表示的是数据结构——张量，&lt;strong&gt;Flow&lt;/strong&gt;表示数据流——Tensor通过数据流相互转化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用的方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在python中导入tensorflow：import tensorflow as tf&lt;/li&gt;
&lt;li&gt;获取当前默认的计算图：tf.get_default_graph()&lt;/li&gt;
&lt;li&gt;生成新的计算图：tf.Graph()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;书中这里都有例子讲解，可以从Github中&lt;a href=&#34;https://github.com/caicloud/tensorflow-tutorial&#34;&gt;下载代码&lt;/a&gt;，或者如果你使用才云提供的docker镜像的方式安装的话，在jupyter中可以看到各个章节的代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义两个不同的图&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import tensorflow as tf

g1 = tf.Graph()
with g1.as_default():
    v = tf.get_variable(&amp;quot;v&amp;quot;, [1], initializer = tf.zeros_initializer) # 设置初始值为0

g2 = tf.Graph()
with g2.as_default():
    v = tf.get_variable(&amp;quot;v&amp;quot;, [1], initializer = tf.ones_initializer())  # 设置初始值为1
    
with tf.Session(graph = g1) as sess:
    tf.global_variables_initializer().run()
    with tf.variable_scope(&amp;quot;&amp;quot;, reuse=True):
        print(sess.run(tf.get_variable(&amp;quot;v&amp;quot;)))

with tf.Session(graph = g2) as sess:
    tf.global_variables_initializer().run()
    with tf.variable_scope(&amp;quot;&amp;quot;, reuse=True):
        print(sess.run(tf.get_variable(&amp;quot;v&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到这里面用了&lt;a href=&#34;https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/&#34;&gt;python中的with语法&lt;/a&gt;，不了解的可以到前面那个链接看看。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;TensorFlow中维护的集合列表&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;集合名称&lt;/th&gt;
&lt;th&gt;集合内容&lt;/th&gt;
&lt;th&gt;使用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.VARIABLES&lt;/td&gt;
&lt;td&gt;所有变量&lt;/td&gt;
&lt;td&gt;持久化TensorFlow模型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.TRAINABLE_VARIABLES&lt;/td&gt;
&lt;td&gt;可学习的变量（一般指神经网络中的参数）&lt;/td&gt;
&lt;td&gt;模型训练、生活从呢个模型可视化内容&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.SUMMARIES&lt;/td&gt;
&lt;td&gt;与日志有关的张量&lt;/td&gt;
&lt;td&gt;TensorFlow计算可视化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.QUEUE_RUNNERS&lt;/td&gt;
&lt;td&gt;处理输入的QueueRunner&lt;/td&gt;
&lt;td&gt;输入处理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.MOVING_AVERAGE_VARIABLES&lt;/td&gt;
&lt;td&gt;所有计算了滑动平均值的变量&lt;/td&gt;
&lt;td&gt;计算变量的滑动平均值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;所谓的滑动平均值即移动平均值，熟悉股票的应该都知道均线的概念吧，5日均线，20日均线，30日均线啥的，一般称作MA(Moving Average)。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-2-tensorflow数据模型-张量&#34;&gt;3.2 TensorFlow数据模型——张量&lt;/h2&gt;

&lt;p&gt;张量（Tensor）是TensorFlow中所有数据的表现形式。我们可以简单的将Tensor理解为&lt;strong&gt;多维数组&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0阶的话就是一个标量（Scalar），可以是一个数也可以是一个字符串&lt;/li&gt;
&lt;li&gt;一阶的话是向量（Vector）&lt;/li&gt;
&lt;li&gt;n阶的话就是n维数组&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tensor在TensorFlow中并不是直接采用数组的形式，而是&lt;strong&gt;对TF中计算结果的引用&lt;/strong&gt;，保存的是如何得到这些数字的过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;举个例子&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;import tensorflow as tf
a = tf.constant([1.0, 2.0], name=&amp;quot;a&amp;quot;)
b = tf.constant([2.0, 3.0], name=&amp;quot;b&amp;quot;)
result = tf.add(a,b,name=&amp;quot;add&amp;quot;)
print result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Tensor(&amp;quot;add:0&amp;quot;, shape=(2,), dtype=float32)
[ 3.  5.]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子只是简单的做了个加法，下面结合上面的例子来讲解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tensor的3个属性&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;名字（Name）&lt;/strong&gt;：Tensor的唯一标识符，如例子中的a, b, result，这是我们手动指定的，实际上Tensor是与计算图上的每个节点一一对应的，tensor的命名可以通过&lt;code&gt;node:src_output&lt;/code&gt;的形式给出，如例子输出中的计算结果名字为&lt;strong&gt;add:0&lt;/strong&gt;，0表示的是计算节点&lt;strong&gt;add&lt;/strong&gt;输出的第一个结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;维度（Shape）&lt;/strong&gt;：如上面例子结果输出中的&lt;strong&gt;shape=(2,)&lt;/strong&gt;，表示这个张量是一维数组，数组的长度是2。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型（Type）&lt;/strong&gt;：所有参与运算的张量的类型必须是相同的，比如不能float和int之间运算。TensorFlow会自动检查张量的类型，可以通过&lt;strong&gt;dtype=df.float32&lt;/strong&gt;这样的声明来指定类型，如果不指定的话，TF会根据值确定默认类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Tensor的用途&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;作为对计算中间结果的引用，比如上面例子中的a和b，在复杂计算中使用tensor能够增加代码的可阅读性。&lt;/li&gt;
&lt;li&gt;用来获取计算结果。张量本身没有存储具体的数字，但是可以使用&lt;strong&gt;会话&lt;/strong&gt;的tf.Session().run(result)来获取计算结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-3-tensorflow的运行模型-会话&#34;&gt;3.3 TensorFlow的运行模型——会话&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;会话（Session）拥有和管理TensorFlow中所有的运算，可以执行定义好的运算。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建和关闭会话&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 创建一个会话。
sess = tf.Session()

# 使用会话得到之前计算的结果。
print(sess.run(result))

# 关闭会话使得本次运行中使用到的资源可以被释放。
sess.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议使用Python的&lt;strong&gt;上下文管理器&lt;/strong&gt;，即通过&lt;strong&gt;with&lt;/strong&gt;语法来创建会话，能够避免资源泄漏。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with tf.Session() as sess:
    print(sess.run(result))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在交互式环境下（比如Jupyter）直接使用&lt;strong&gt;tf.InteractiveSession&lt;/strong&gt;函数创建&lt;strong&gt;交互式会话&lt;/strong&gt;，将产生的会话直接注册为默认会话。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sess = tf.InteractiveSession ()
print(result.eval())
sess.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不论使用哪种会话都可以通过&lt;strong&gt;ConfigProto&lt;/strong&gt;来配置&lt;code&gt;并行线程数&lt;/code&gt;、&lt;code&gt;GPU分配策略&lt;/code&gt;、&lt;code&gt;运算超时时间&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;常用的两个配置有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;allow_soft_placement&lt;/strong&gt;：布尔值，默认false，以下任何一个条件满足时则为true，允许将GPU上的运算放到CPU上进行。

&lt;ul&gt;
&lt;li&gt;运算无法在GPU上运行&lt;/li&gt;
&lt;li&gt;GPU资源不足（没有GPU或者指定的GPU个数不够）&lt;/li&gt;
&lt;li&gt;运算输入包括对CPU计算结果的引用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;log_device_placement&lt;/strong&gt;：布尔值，默认值是？如果为true的话，日志中将会记录每个节点被安排在哪个设备上，这方便调试。生产环境中一般设置为false，能够减少日志量。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-4-tensorflow实现神经网络&#34;&gt;3.4 TensorFlow实现神经网络&lt;/h2&gt;

&lt;p&gt;To be continued…&lt;/p&gt;

&lt;p&gt;10:39 p.m Thu Mar 30,2017&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在CentOS上安装kubernetes详细指南</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-installation-on-centos/</link>
      <pubDate>Thu, 30 Mar 2017 20:44:20 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-installation-on-centos/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2014082501.jpg&#34; alt=&#34;圆明园&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：北京圆明园 Aug 25,2014）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;作者：&lt;a href=&#34;rootsongjc.github.io/about&#34;&gt;Jimmy Song&lt;/a&gt;，&lt;a href=&#34;https://godliness.github.io/&#34;&gt;Peter Ma&lt;/a&gt;，2017年3月30日&lt;/p&gt;

&lt;p&gt;最近决定从Docker Swarm Mode投入到Kubernetes的怀抱，对Docker的战略和企业化发展前景比较堪忧，而Kubernetes是&lt;a href=&#34;https://www.cncf.io/&#34;&gt;CNCF&lt;/a&gt;的成员之一。&lt;/p&gt;

&lt;p&gt;这篇是根据&lt;a href=&#34;https://kubernetes.io/docs/getting-started-guides/centos/centos_manual_config/#prerequisites&#34;&gt;官方安装文档&lt;/a&gt;实践整理的，操作系统是纯净的CentOS7.2。&lt;/p&gt;

&lt;p&gt;另外还有一个Peter Ma写的&lt;a href=&#34;https://godliness.github.io/2017/03/29/%E5%9C%A8CentOS7%E4%B8%8A%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Kubernetes/&#34;&gt;在CentOS上手动安装kubernetes的文档&lt;/a&gt;可以参考。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;角色分配&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面以在三台主机上安装Kubernetes为例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;172.20.0.113 master/node kube-apiserver kube-controller-manager kube-scheduler kubelet kube-proxy etcd flannel
172.20.0.114 node kubectl kube-proxy flannel
172.20.0.115 node kubectl kube-proxy flannel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一台主机既作为master也作为node。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Centos 7.2.1511&lt;/li&gt;
&lt;li&gt;docker 1.12.6&lt;/li&gt;
&lt;li&gt;etcd 3.1.5&lt;/li&gt;
&lt;li&gt;kubernetes 1.6.0&lt;/li&gt;
&lt;li&gt;flannel 0.7.0-1&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;p&gt;下面给出两种安装方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;配置yum源后，使用yum安装，好处是简单，坏处也很明显，需要google更新yum源才能获得最新版本的软件，而所有软件的依赖又不能自己指定，尤其是你的操作系统版本如果低的话，使用yum源安装的kubernetes的版本也会受到限制。&lt;/li&gt;
&lt;li&gt;使用二进制文件安装，好处是可以安装任意版本的kubernetes，坏处是配置比较复杂。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们最终选择使用第二种方式安装。&lt;/p&gt;

&lt;p&gt;本文的很多安装步骤和命令是参考的Kubernetes官网&lt;a href=&#34;https://kubernetes.io/docs/getting-started-guides/centos/centos_manual_config/&#34;&gt;CentOS Manual Config&lt;/a&gt;文档。&lt;/p&gt;

&lt;h2 id=&#34;第一种方式-centos系统中直接使用yum安装&#34;&gt;第一种方式：CentOS系统中直接使用yum安装&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;给yum源增加一个Repo&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[virt7-docker-common-release]
name=virt7-docker-common-release
baseurl=http://cbs.centos.org/repos/virt7-docker-common-release/x86_64/os/
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;安装docker、kubernetes、etcd、flannel一步到位&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install --enablerepo=virt7-docker-common-release kubernetes etcd flannel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装好了之后需要修改一系列配置文件。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个repo在CentOS7.3下是毫无意义的，因为CentOS官方源的extras中已经包含了Kubernetes1.5.2，如果你使用的是CentOS7.3的话，会自动下载安装Kubernetes1.5.2（Till March 30,2017）。如果你使用的是CentOS7.2的化，这个源就有用了，但是不幸的是，它会自动下载安装Kubernentes1.1。我们现在要安装目前的最新版本Kubernetes1.6，而使用的又是CentOS7.2，所以我们不使用yum安装（当前yum源支持的最高版本的kuberentes是1.5.2）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二种方式-使用二进制文件安装&#34;&gt;第二种方式：使用二进制文件安装&lt;/h2&gt;

&lt;p&gt;这种方式安装的话，需要自己一个一个组件的安装。&lt;/p&gt;

&lt;h3 id=&#34;安装docker&#34;&gt;安装Docker&lt;/h3&gt;

&lt;p&gt;yum localinstall ./docker-engine*&lt;/p&gt;

&lt;p&gt;将使用CentOS的&lt;strong&gt;extras&lt;/strong&gt; repo下载。&lt;/p&gt;

&lt;h3 id=&#34;关闭防火墙和selinux&#34;&gt;关闭防火墙和SELinux&lt;/h3&gt;

&lt;p&gt;这是官网上建议的，我是直接将iptables-services和firewlld卸载掉了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;setenforce 0
systemctl disable iptables-services firewalld
systemctl stop iptables-services firewalld
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装etcd&#34;&gt;安装etcd&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;下载二进制文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;DOWNLOAD_URL=https://storage.googleapis.com/etcd  #etcd存储地址
ETCD_VER=v3.1.5  #设置etcd版本号
wget ${DOWNLOAD_URL}/${ETCD_VER}/etcd-${ETCD_VER}-linux-amd64.tar.gz
tar xvf etcd-${ETCD_VER}-linux-amd64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;部署文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将如下内容写入文件 /etc/etcd/etcd.conf 中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;# [member]
ETCD_NAME=default
ETCD_DATA_DIR=&amp;quot;/var/lib/etcd/default.etcd&amp;quot;
# ETCD_WAL_DIR=&amp;quot;&amp;quot;
# ETCD_SNAPSHOT_COUNT=&amp;quot;10000&amp;quot;
# ETCD_HEARTBEAT_INTERVAL=&amp;quot;100&amp;quot;
# ETCD_ELECTION_TIMEOUT=&amp;quot;1000&amp;quot;
# ETCD_LISTEN_PEER_URLS=&amp;quot;http://localhost:2380&amp;quot;
ETCD_LISTEN_CLIENT_URLS=&amp;quot;http://0.0.0.0:2379&amp;quot;
# ETCD_MAX_SNAPSHOTS=&amp;quot;5&amp;quot;
# ETCD_MAX_WALS=&amp;quot;5&amp;quot;
# ETCD_CORS=&amp;quot;&amp;quot;
#
# [cluster]
# ETCD_INITIAL_ADVERTISE_PEER_URLS=&amp;quot;http://localhost:2380&amp;quot;
# if you use different ETCD_NAME (e.g. test), set ETCD_INITIAL_CLUSTER value for this name, i.e. &amp;quot;test=http://...&amp;quot;
# ETCD_INITIAL_CLUSTER=&amp;quot;default=http://localhost:2380&amp;quot;
# ETCD_INITIAL_CLUSTER_STATE=&amp;quot;new&amp;quot;
# ETCD_INITIAL_CLUSTER_TOKEN=&amp;quot;etcd-cluster&amp;quot;
ETCD_ADVERTISE_CLIENT_URLS=&amp;quot;http://0.0.0.0:2379&amp;quot;
# ETCD_DISCOVERY=&amp;quot;&amp;quot;
# ETCD_DISCOVERY_SRV=&amp;quot;&amp;quot;
# ETCD_DISCOVERY_FALLBACK=&amp;quot;proxy&amp;quot;
# ETCD_DISCOVERY_PROXY=&amp;quot;&amp;quot;
#
# [proxy]
# ETCD_PROXY=&amp;quot;off&amp;quot;
# ETCD_PROXY_FAILURE_WAIT=&amp;quot;5000&amp;quot;
# ETCD_PROXY_REFRESH_INTERVAL=&amp;quot;30000&amp;quot;
# ETCD_PROXY_DIAL_TIMEOUT=&amp;quot;1000&amp;quot;
# ETCD_PROXY_WRITE_TIMEOUT=&amp;quot;5000&amp;quot;
# ETCD_PROXY_READ_TIMEOUT=&amp;quot;0&amp;quot;
#
# [security]
# ETCD_CERT_FILE=&amp;quot;&amp;quot;
# ETCD_KEY_FILE=&amp;quot;&amp;quot;
# ETCD_CLIENT_CERT_AUTH=&amp;quot;false&amp;quot;
# ETCD_TRUSTED_CA_FILE=&amp;quot;&amp;quot;
# ETCD_PEER_CERT_FILE=&amp;quot;&amp;quot;
# ETCD_PEER_KEY_FILE=&amp;quot;&amp;quot;
# ETCD_PEER_CLIENT_CERT_AUTH=&amp;quot;false&amp;quot;
# ETCD_PEER_TRUSTED_CA_FILE=&amp;quot;&amp;quot;
# [logging]
# ETCD_DEBUG=&amp;quot;false&amp;quot;
# examples for -log-package-levels etcdserver=WARNING,security=DEBUG
# ETCD_LOG_PACKAGE_LEVELS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将 etcd, etcdctl放入 /usr/bin/下，并将如下内容写进/usr/lib/systemd/system/etcd.service文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ini&#34;&gt;[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
WorkingDirectory=/var/lib/etcd/
EnvironmentFile=-/etc/etcd/etcd.conf
User=etcd
# set GOMAXPROCS to number of processors
ExecStart=/bin/bash -c &amp;quot;GOMAXPROCS=$(nproc) /usr/bin/etcd --name=\&amp;quot;${ETCD_NAME}\&amp;quot; --data-dir=\&amp;quot;${ETCD_DATA_DIR}\&amp;quot; --listen-client-urls=\&amp;quot;${ETCD_LISTEN_CLIENT_URLS}\&amp;quot;&amp;quot;
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;启动并校验&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;systemctl start etcd
systemctl enable etcd
systemctl status etcd
etcdctl ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;集群&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;若要部署多节点集群也比较简单，只要更改etcd.conf文件以及etcd.service添加相应配置即可&lt;/p&gt;

&lt;p&gt;可以参考链接：&lt;a href=&#34;https://github.com/coreos/etcd/blob/master/Documentation/op-guide/clustering.md&#34;&gt;https://github.com/coreos/etcd/blob/master/Documentation/op-guide/clustering.md&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装flannel&#34;&gt;安装flannel&lt;/h3&gt;

&lt;p&gt;可以直接使用&lt;code&gt;yum install flannel&lt;/code&gt;安装。&lt;/p&gt;

&lt;p&gt;因为网络这块的配置比较复杂，我将在后续文章中说明。&lt;/p&gt;

&lt;h3 id=&#34;安装kubernetes&#34;&gt;安装Kubernetes&lt;/h3&gt;

&lt;p&gt;根据《Kubernetes权威指南（第二版）》中的介绍，直接使用GitHub上的release里的二进制文件安装。&lt;/p&gt;

&lt;p&gt;执行下面的命令安装。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://github.com/kubernetes/kubernetes/releases/download/v1.6.0/kubernetes.tar.gz
tar kubernetes.tar.gz
cd kubernetes
./cluster/get-kube-binaries.sh
cd server
tar xvf kubernetes-server-linux-amd64.tar.gz
rm -f *_tag *.tar
chmod 755 *
mv * /usr/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际下载kubernetes-server-linux-amd64.tar.gz from &lt;a href=&#34;https://storage.googleapis.com/kubernetes-release/release/v1.6.0&#34;&gt;https://storage.googleapis.com/kubernetes-release/release/v1.6.0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解压完后获得的二进制文件有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cloud-controller-manager
hyperkube
kubeadm
kube-aggregator
kube-apiserver
kube-controller-manager
kubectl
kubefed
kubelet
kube-proxy
kube-scheduler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;cluster/juju/layers/kubernetes-master/templates&lt;/code&gt;目录下有service和环境变量配置文件的模板，这个模板本来是为了使用&lt;a href=&#34;https://jujucharms.com/&#34;&gt;juju&lt;/a&gt;安装写的。&lt;/p&gt;

&lt;h4 id=&#34;master节点的配置&#34;&gt;Master节点的配置&lt;/h4&gt;

&lt;p&gt;Master节点需要配置的kubernetes的组件有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kube-apiserver&lt;/li&gt;
&lt;li&gt;kube-controller-manager&lt;/li&gt;
&lt;li&gt;kube-scheduler&lt;/li&gt;
&lt;li&gt;kube-proxy&lt;/li&gt;
&lt;li&gt;kubectl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;配置kube-apiserver&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编写&lt;code&gt;/usr/lib/systemd/system/kube-apiserver.service&lt;/code&gt;文件。&lt;a href=&#34;http://blog.csdn.net/yuesichiu/article/details/51485147&#34;&gt;CentOS中的service配置文件参考&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes API Service
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=network.target
After=etcd.service

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/apiserver
ExecStart=/usr/bin/kube-apiserver \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_ETCD_SERVERS \
	    $KUBE_API_ADDRESS \
	    $KUBE_API_PORT \
	    $KUBELET_PORT \
	    $KUBE_ALLOW_PRIV \
	    $KUBE_SERVICE_ADDRESSES \
	    $KUBE_ADMISSION_CONTROL \
	    $KUBE_API_ARGS
Restart=on-failure
Type=notify
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建kubernetes的配置文件目录&lt;code&gt;/etc/kubernetes&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;添加&lt;code&gt;config&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
# kubernetes system config
#
# The following values are used to configure various aspects of all
# kubernetes services, including
#
#   kube-apiserver.service
#   kube-controller-manager.service
#   kube-scheduler.service
#   kubelet.service
#   kube-proxy.service
# logging to stderr means we get it in the systemd journal
KUBE_LOGTOSTDERR=&amp;quot;--logtostderr=true&amp;quot;

# journal message level, 0 is debug
KUBE_LOG_LEVEL=&amp;quot;--v=0&amp;quot;

# Should this cluster be allowed to run privileged docker containers
KUBE_ALLOW_PRIV=&amp;quot;--allow-privileged=false&amp;quot;

# How the controller-manager, scheduler, and proxy find the apiserver
KUBE_MASTER=&amp;quot;--master=http://sz-pg-oam-docker-test-001.tendcloud.com:8080&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加&lt;code&gt;apiserver&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
## kubernetes system config
##
## The following values are used to configure the kube-apiserver
##
#
## The address on the local server to listen to.
KUBE_API_ADDRESS=&amp;quot;--address=sz-pg-oam-docker-test-001.tendcloud.com&amp;quot;
#
## The port on the local server to listen on.
KUBE_API_PORT=&amp;quot;--port=8080&amp;quot;
#
## Port minions listen on
KUBELET_PORT=&amp;quot;--kubelet-port=10250&amp;quot;
#
## Comma separated list of nodes in the etcd cluster
KUBE_ETCD_SERVERS=&amp;quot;--etcd-servers=http://127.0.0.1:2379&amp;quot;
#
## Address range to use for services
KUBE_SERVICE_ADDREKUBELET_POD_INFRA_CONTAINERSSES=&amp;quot;--service-cluster-ip-range=10.254.0.0/16&amp;quot;
#
## default admission control policies
KUBE_ADMISSION_CONTROL=&amp;quot;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ResourceQuota&amp;quot;
#
## Add your own!
#KUBE_API_ARGS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;—admission-control&lt;/code&gt;参数是Kubernetes的安全机制配置，这些安全机制都是以插件的形式用来对API Serve进行准入控制，一开始我们没有配置&lt;code&gt;ServiceAccount&lt;/code&gt;，这是为了方便集群之间的通信，不需要进行身份验证。如果你需要更高级的身份验证和鉴权的话就需要加上它了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;配置kube-controller-manager&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编写&lt;code&gt;/usr/lib/systemd/system/kube-controller.service&lt;/code&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ini&#34;&gt;Description=Kubernetes Controller Manager
Documentation=https://github.com/GoogleCloudPlatform/kubernetes

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/controller-manager
ExecStart=/usr/bin/kube-controller-manager \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_MASTER \
	    $KUBE_CONTROLLER_MANAGER_ARGS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;/etc/kubernetes&lt;/code&gt;目录下添加&lt;code&gt;controller-manager&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
# The following values are used to configure the kubernetes controller-manager

# defaults from config and apiserver should be adequate

# Add your own!
KUBE_CONTROLLER_MANAGER_ARGS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置kube-scheduler&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编写&lt;code&gt;/usr/lib/systemd/system/kube-scheduler.service&lt;/code&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes Scheduler Plugin
Documentation=https://github.com/GoogleCloudPlatform/kubernetes

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/scheduler
ExecStart=/usr/bin/kube-scheduler \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_MASTER \
	    $KUBE_SCHEDULER_ARGS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;/etc/kubernetes&lt;/code&gt;目录下添加&lt;code&gt;scheduler&lt;/code&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
# kubernetes scheduler config

# default config should be adequate

# Add your own!
KUBE_SCHEDULER_ARGS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置kube-proxy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编写&lt;code&gt;/usr/lib/systemd/system/kube-proxy.service&lt;/code&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes Kube-Proxy Server
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=network.target

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/proxy
ExecStart=/usr/bin/kube-proxy \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_MASTER \
	    $KUBE_PROXY_ARGS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;/etc/kubernetes&lt;/code&gt;目录下添加&lt;code&gt;proxy&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
# kubernetes proxy config

# default config should be adequate

# Add your own!
KUBE_PROXY_ARGS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置kubelet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编写&lt;code&gt;/usr/lib/systemd/system/kubelet.service&lt;/code&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes Kubelet Server
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=docker.service
Requires=docker.service

[Service]
WorkingDirectory=/var/lib/kubelet
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/kubelet
ExecStart=/usr/bin/kubelet \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBELET_API_SERVER \
	    $KUBELET_ADDRESS \
	    $KUBELET_PORT \
	    $KUBELET_HOSTNAME \
	    $KUBE_ALLOW_PRIV \
	    $KUBELET_POD_INFRA_CONTAINER \
	    $KUBELET_ARGS
Restart=on-failure

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;/etc/kubernetes&lt;/code&gt;目录下添加&lt;code&gt;kubelet&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
## kubernetes kubelet (minion) config
#
## The address for the info server to serve on (set to 0.0.0.0 or &amp;quot;&amp;quot; for all interfaces)
KUBELET_ADDRESS=&amp;quot;--address=0.0.0.0&amp;quot;
#
## The port for the info server to serve on
KUBELET_PORT=&amp;quot;--port=10250&amp;quot;
#
## You may leave this blank to use the actual hostname
KUBELET_HOSTNAME=&amp;quot;--hostname-override=sz-pg-oam-docker-test-001.tendcloud.com&amp;quot;
#
## location of the api-server
KUBELET_API_SERVER=&amp;quot;--api-servers=http://sz-pg-oam-docker-test-001.tendcloud.com:8080&amp;quot;
#
## pod infrastructure container
KUBELET_POD_INFRA_CONTAINER=&amp;quot;--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest&amp;quot;
#
## Add your own!
KUBELET_ARGS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⚠️&lt;code&gt;KUBELET_POD_INFRA_CONTAINER&lt;/code&gt;在生产环境中配置成自己私有仓库里的image。&lt;/p&gt;

&lt;h4 id=&#34;node节点配置&#34;&gt;Node节点配置&lt;/h4&gt;

&lt;p&gt;Node节点需要配置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kube-proxy&lt;/li&gt;
&lt;li&gt;kubectl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;kube-proxy&lt;/code&gt;的配置与master节点的kube-proxy配置相同。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kubectl&lt;/code&gt;的配置需要修改&lt;code&gt;KUBELET_HOST&lt;/code&gt;为本机的hostname，其它配置相同。&lt;/p&gt;

&lt;h1 id=&#34;启动&#34;&gt;启动&lt;/h1&gt;

&lt;p&gt;在&lt;strong&gt;Master&lt;/strong&gt;节点上执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;for SERVICES in etcd kube-apiserver kube-controller-manager kube-scheduler kube-proxy kubelet flanneld; do
    systemctl restart $SERVICES
    systemctl enable $SERVICES
    systemctl status $SERVICES
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在另外两台Node节点上执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;for SERVICES in kube-proxy kubelet flanneld; do
    systemctl restart $SERVICES
    systemctl enable $SERVICES
    systemctl status $SERVICES
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;验证&#34;&gt;验证&lt;/h1&gt;

&lt;p&gt;在Master节点上运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl get all
NAME             CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
svc/kubernetes   10.254.0.1   &amp;lt;none&amp;gt;        443/TCP   1h
$kubectl get nodes
NAME                                      STATUS    AGE       VERSION
sz-pg-oam-docker-test-001.tendcloud.com   Ready     7m        v1.6.0
sz-pg-oam-docker-test-002.tendcloud.com   Ready     4m        v1.6.0
sz-pg-oam-docker-test-003.tendcloud.com   Ready     10s       v1.6.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以正常使用啦。&lt;/p&gt;

&lt;h3 id=&#34;后记&#34;&gt;后记&lt;/h3&gt;

&lt;p&gt;另外Kuberntes还提供第三中安装方式，请看Tony Bai写的&lt;a href=&#34;http://tonybai.com/2017/01/24/explore-kubernetes-cluster-installed-by-kubeadm/&#34;&gt;使用Kubeadm方式安装Kubernetes集群的探索&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;时隔一年重新捡起kubernetes，正好现在KubeCon正在德国柏林举行，IDC 发布的报告显示，2017年大数据全球市场规模将达324亿美元，年复合增长率为27%，其中市场增长最快的领域是数据存储领域（53.4%）&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pivotal Cloud foundry快速开始指南</title>
      <link>http://rootsongjc.github.io/blogs/cloud-foundry-tryout/</link>
      <pubDate>Thu, 23 Mar 2017 22:54:18 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/cloud-foundry-tryout/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2013100302.jpg&#34; alt=&#34;黄山日出&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：黄山日出后的云海 Oct 3,2013）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近研究了下&lt;strong&gt;Pivotal&lt;/strong&gt;的&lt;strong&gt;Cloud foundry&lt;/strong&gt;，CF本身是一款开源软件，很多PAAS厂商都加入了CF，我们用的是的&lt;strong&gt;PCF Dev&lt;/strong&gt;（PCF Dev是一款可以在工作站上运行的轻量级PCF安装）来试用的，因为它可以部署在自己的环境里，而&lt;strong&gt;Pivotal Web Services&lt;/strong&gt;只免费两个月，之后就要收费。&lt;a href=&#34;https://pivotal.io/cn/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry-dev/introduction&#34;&gt;这里&lt;/a&gt;有官方的详细教程。&lt;/p&gt;

&lt;h2 id=&#34;开始&#34;&gt;开始&lt;/h2&gt;

&lt;p&gt;根据官网的示例，我们将运行一个Java程序示例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装命令行终端&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pivotal.io/cn/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry-dev/install-the-cf-cli&#34;&gt;下载&lt;/a&gt;后双击安装即可，然后执行&lt;code&gt;cf help&lt;/code&gt;能够看到帮助。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装PCF Dev&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先&lt;a href=&#34;https://network.pivotal.io/products/pcfdev&#34;&gt;下载&lt;/a&gt;，如果你没有Pivotal network账号的话，还需要注册个用户，然后用以下命令安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;
$./pcfdev-VERSION-osx &amp;amp;&amp;amp; \
cf dev start
Less than 4096 MB of free memory detected, continue (y/N): &amp;gt; y
Please sign in with your Pivotal Network account.
Need an account? Join Pivotal Network: https://network.pivotal.io

Email&amp;gt; 849122844@qq.com

Password&amp;gt; 
Downloading VM...
Progress: |+++++++++++++=======&amp;gt;| 100% 
VM downloaded.
Allocating 4096 MB out of 16384 MB total system memory (3514 MB free).
Importing VM...
Starting VM...
Provisioning VM...
Waiting for services to start...
8 out of 57 running
8 out of 57 running
8 out of 57 running
46 out of 57 running
57 out of 57 running
 _______  _______  _______    ______   _______  __   __
|       ||       ||       |  |      | |       ||  | |  |
|    _  ||       ||    ___|  |  _    ||    ___||  |_|  |
|   |_| ||       ||   |___   | | |   ||   |___ |       |
|    ___||      _||    ___|  | |_|   ||    ___||       |
|   |    |     |_ |   |      |       ||   |___  |     |
|___|    |_______||___|      |______| |_______|  |___|
is now running.
To begin using PCF Dev, please run:
   cf login -a https://api.local.pcfdev.io --skip-ssl-validation
Apps Manager URL: https://local.pcfdev.io
Admin user =&amp;gt; Email: admin / Password: admin
Regular user =&amp;gt; Email: user / Password: pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动过程中还需要&lt;strong&gt;Sign In&lt;/strong&gt;，所以注册完后要记住用户名（邮箱地址）和密码（必须超过8位要有特殊字符和大写字母）。这个过程中还要下载VM，对内存要求至少4G。而且下载速度比较慢，我下载的了大概3个多小时吧。&lt;/p&gt;

&lt;p&gt;下面部署一个应用到PCF Dev上试一试。&lt;/p&gt;

&lt;h2 id=&#34;部署应用&#34;&gt;部署应用&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;下载代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$git clone https://github.com/cloudfoundry-samples/spring-music
$cd ./spring-music
$cf login -a api.local.pcfdev.io --skip-ssl-validation
API endpoint: api.local.pcfdev.io

Email&amp;gt; user

Password&amp;gt; pass
Authenticating...
OK

Targeted org pcfdev-org

Targeted space pcfdev-space


                
API endpoint:   https://api.local.pcfdev.io (API version: 2.65.0)
User:           user
Org:            pcfdev-org
Space:          pcfdev-space
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;编译应用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用gradle来编译。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$./gradlew assemble
:compileJava UP-TO-DATE
:processResources UP-TO-DATE
:classes UP-TO-DATE
:findMainClass
:jar
:bootRepackage
Download https://repo1.maven.org/maven2/com/sun/jersey/jersey-client/1.13/jersey-client-1.13.jar
Download https://repo1.maven.org/maven2/com/sun/jersey/jersey-json/1.13/jersey-json-1.13.jar
Download https://repo1.maven.org/maven2/org/apache/httpcomponents/httpcore/4.4.5/httpcore-4.4.5.jar
Download https://repo1.maven.org/maven2/com/nimbusds/oauth2-oidc-sdk/4.5/oauth2-oidc-sdk-4.5.jar
Download https://repo1.maven.org/maven2/com/google/code/gson/gson/2.3.1/gson-2.3.1.jar
Download https://repo1.maven.org/maven2/com/sun/jersey/jersey-core/1.13/jersey-core-1.13.jar
Download https://repo1.maven.org/maven2/org/codehaus/jackson/jackson-core-asl/1.9.2/jackson-core-asl-1.9.2.jar
Download https://repo1.maven.org/maven2/org/codehaus/jackson/jackson-mapper-asl/1.9.2/jackson-mapper-asl-1.9.2.jar
Download https://repo1.maven.org/maven2/org/codehaus/jackson/jackson-jaxrs/1.9.2/jackson-jaxrs-1.9.2.jar
Download https://repo1.maven.org/maven2/org/codehaus/jackson/jackson-xc/1.9.2/jackson-xc-1.9.2.jar
Download https://repo1.maven.org/maven2/net/jcip/jcip-annotations/1.0/jcip-annotations-1.0.jar
Download https://repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.3.1/commons-lang3-3.3.1.jar
Download https://repo1.maven.org/maven2/net/minidev/json-smart/1.1.1/json-smart-1.1.1.jar
Download https://repo1.maven.org/maven2/com/nimbusds/lang-tag/1.4/lang-tag-1.4.jar
Download https://repo1.maven.org/maven2/com/nimbusds/nimbus-jose-jwt/3.1.2/nimbus-jose-jwt-3.1.2.jar
Download https://repo1.maven.org/maven2/stax/stax-api/1.0.1/stax-api-1.0.1.jar
Download https://repo1.maven.org/maven2/org/bouncycastle/bcprov-jdk15on/1.51/bcprov-jdk15on-1.51.jar
Download https://repo1.maven.org/maven2/javax/mail/mail/1.4.7/mail-1.4.7.jar
:assemble

BUILD SUCCESSFUL

Total time: 1 mins 25.649 secs

This build could be faster, please consider using the Gradle Daemon: https://docs.gradle.org/2.14/userguide/gradle_daemon.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;上传应用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置应用的主机名为spring-music。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf push --hostname spring-music
Using manifest file /Users/jimmy/Workspace/github/cloudfoundry-samples/spring-music/manifest.yml

Creating app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

Creating route spring-music.local.pcfdev.io...
OK

Binding spring-music.local.pcfdev.io to spring-music...
OK

Uploading spring-music...
Uploading app files from: /var/folders/61/f7mqkyjn1nz5mfmfvdztgzjw0000gn/T/unzipped-app139680305
Uploading 38.9M, 234 files
Done uploading               
OK

Starting app spring-music in org pcfdev-org / space pcfdev-space as user...
Downloading dotnet-core_buildpack...
Downloading go_buildpack...
Downloading python_buildpack...
Downloading php_buildpack...
Downloading staticfile_buildpack...
Downloaded staticfile_buildpack
Downloading binary_buildpack...
Downloaded binary_buildpack (9.3K)
Downloading java_buildpack...
Downloaded java_buildpack (249.1M)
Downloaded dotnet-core_buildpack (169.3M)
Downloading ruby_buildpack...
Downloading nodejs_buildpack...
Downloaded python_buildpack (255.3M)
Downloaded nodejs_buildpack (109.4M)
Downloaded go_buildpack (392M)
Downloaded php_buildpack (310.4M)
Downloaded ruby_buildpack (260.8M)
Creating container
Successfully created container
Downloading app package...
Downloaded app package (38.8M)
Staging...
-----&amp;gt; Java Buildpack Version: v3.10 (offline) | https://github.com/cloudfoundry/java-buildpack.git#193d6b7
-----&amp;gt; Downloading Open Jdk JRE 1.8.0_111 from https://java-buildpack.cloudfoundry.org/openjdk/trusty/x86_64/openjdk-1.8.0_111.tar.gz (found in cache)
       Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.4s)
-----&amp;gt; Downloading Open JDK Like Memory Calculator 2.0.2_RELEASE from https://java-buildpack.cloudfoundry.org/memory-calculator/trusty/x86_64/memory-calculator-2.0.2_RELEASE.tar.gz (found in cache)
       Memory Settings: -Xss349K -Xmx681574K -XX:MaxMetaspaceSize=104857K -Xms681574K -XX:MetaspaceSize=104857K
-----&amp;gt; Downloading Spring Auto Reconfiguration 1.10.0_RELEASE from https://java-buildpack.cloudfoundry.org/auto-reconfiguration/auto-reconfiguration-1.10.0_RELEASE.jar (found in cache)
Exit status 0
Staging complete
Uploading droplet, build artifacts cache...
Uploading build artifacts cache...
Uploading droplet...
Uploaded build artifacts cache (108B)
Uploaded droplet (83.9M)
Uploading complete
Destroying container
Successfully destroyed container

0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
1 of 1 instances running

App started


OK

App spring-music was started using this command `CALCULATED_MEMORY=$($PWD/.java-buildpack/open_jdk_jre/bin/java-buildpack-memory-calculator-2.0.2_RELEASE -memorySizes=metaspace:64m..,stack:228k.. -memoryWeights=heap:65,metaspace:10,native:15,stack:10 -memoryInitials=heap:100%,metaspace:100% -stackThreads=300 -totMemory=$MEMORY_LIMIT) &amp;amp;&amp;amp; JAVA_OPTS=&amp;quot;-Djava.io.tmpdir=$TMPDIR -XX:OnOutOfMemoryError=$PWD/.java-buildpack/open_jdk_jre/bin/killjava.sh $CALCULATED_MEMORY&amp;quot; &amp;amp;&amp;amp; SERVER_PORT=$PORT eval exec $PWD/.java-buildpack/open_jdk_jre/bin/java $JAVA_OPTS -cp $PWD/. org.springframework.boot.loader.JarLauncher`

Showing health and status for app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

requested state: started
instances: 1/1
usage: 1G x 1 instances
urls: spring-music.local.pcfdev.io
last uploaded: Thu Mar 23 14:29:46 UTC 2017
stack: cflinuxfs2
buildpack: java-buildpack=v3.10-offline-https://github.com/cloudfoundry/java-buildpack.git#193d6b7 java-main open-jdk-like-jre=1.8.0_111 open-jdk-like-memory-calculator=2.0.2_RELEASE spring-auto-reconfiguration=1.10.0_RELEASE

     state     since                    cpu      memory       disk             details
#0   running   2017-03-23 10:31:36 PM   160.7%   442M of 1G   165.6M of 512M
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在浏览器中访问app&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;spring-music.local.pcfdev.io&#34;&gt;spring-music.local.pcfdev.io&lt;/a&gt;页面如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/pivotal-cloudfoundry-spring-music.jpg&#34; alt=&#34;spring-music&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;requested state: started
instances: 1/1
usage: 512M x 1 instances
urls: spring-music.local.pcfdev.io
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;查看日志&#34;&gt;查看日志&lt;/h2&gt;

&lt;p&gt;PCF提供应用的日志聚合功能，你可以查看HTTP请求、对应用操作时候的output，如扩容、重启等。&lt;/p&gt;

&lt;p&gt;每行日志中都包括如下信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Timestamp&lt;/li&gt;
&lt;li&gt;Log type&lt;/li&gt;
&lt;li&gt;Channel&lt;/li&gt;
&lt;li&gt;Message&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看刚才那个应用的日志信息：&lt;/p&gt;

&lt;p&gt;查看最近输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf logs spring-music --recent
2017-03-23T22:34:05.17+0800 [RTR/0]      OUT spring-music.local.pcfdev.io - [23/03/2017:14:34:05.163 +0000] &amp;quot;GET /templates/albumForm.html HTTP/1.1&amp;quot; 200 0 2518 &amp;quot;http://spring-music.local.pcfdev.io/&amp;quot; &amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36&amp;quot; 192.168.11.1:52097 10.0.2.15:60012 x_forwarded_for:&amp;quot;-&amp;quot; x_forwarded_proto:&amp;quot;http&amp;quot; vcap_request_id:c6b5f34d-bc5a-4c66-77aa-cb768b273f21 response_time:0.007390127 app_id:fdc7a43e-61b8-40e9-b1dc-38b858037da9 app_index:0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看实时输出流：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf logs spring-music
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;连接数据库&#34;&gt;连接数据库&lt;/h2&gt;

&lt;p&gt;在上面的那个例子中用的是内存数据库。我们可以改用mysql数据库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看可用的数据&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf marketplace -s p-mysql
Getting service plan information for service p-mysql as user...
OK

service plan   description            free or paid
512mb          PCF Dev MySQL Server   free
1gb            PCF Dev MySQL Server   free
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;创建数据库&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf create-service p-mysql 512mb my-spring-db
Creating service instance my-spring-db in org pcfdev-org / space pcfdev-space as user...
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将它与我们上面的示例应用程序绑定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf bind-service spring-music my-spring-db
Binding service my-spring-db to app spring-music in org pcfdev-org / space pcfdev-space as user...
OK
TIP: Use &#39;cf restage spring-music&#39; to ensure your env variable changes take effect
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启app&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf restart spring-music
Stopping app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

Starting app spring-music in org pcfdev-org / space pcfdev-space as user...

0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
1 of 1 instances running

App started


OK

App spring-music was started using this command `CALCULATED_MEMORY=$($PWD/.java-buildpack/open_jdk_jre/bin/java-buildpack-memory-calculator-2.0.2_RELEASE -memorySizes=metaspace:64m..,stack:228k.. -memoryWeights=heap:65,metaspace:10,native:15,stack:10 -memoryInitials=heap:100%,metaspace:100% -stackThreads=300 -totMemory=$MEMORY_LIMIT) &amp;amp;&amp;amp; JAVA_OPTS=&amp;quot;-Djava.io.tmpdir=$TMPDIR -XX:OnOutOfMemoryError=$PWD/.java-buildpack/open_jdk_jre/bin/killjava.sh $CALCULATED_MEMORY&amp;quot; &amp;amp;&amp;amp; SERVER_PORT=$PORT eval exec $PWD/.java-buildpack/open_jdk_jre/bin/java $JAVA_OPTS -cp $PWD/. org.springframework.boot.loader.JarLauncher`

Showing health and status for app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

requested state: started
instances: 1/1
usage: 1G x 1 instances
urls: spring-music.local.pcfdev.io
last uploaded: Thu Mar 23 14:29:46 UTC 2017
stack: cflinuxfs2
buildpack: java-buildpack=v3.10-offline-https://github.com/cloudfoundry/java-buildpack.git#193d6b7 java-main open-jdk-like-jre=1.8.0_111 open-jdk-like-memory-calculator=2.0.2_RELEASE spring-auto-reconfiguration=1.10.0_RELEASE

     state     since                    cpu      memory         disk             details
#0   running   2017-03-23 10:44:18 PM   150.4%   461.6M of 1G   165.6M of 512M
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们再查看下自己的service。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf services
Getting services in org pcfdev-org / space pcfdev-space as user...
OK

name           service   plan    bound apps     last operation
my-spring-db   p-mysql   512mb   spring-music   create succeeded
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;应用扩容&#34;&gt;应用扩容&lt;/h2&gt;

&lt;p&gt;扩展应用的示例数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf scale spring-music -i 2
Scaling app spring-music in org pcfdev-org / space pcfdev-space as user...
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再查看下&lt;code&gt;spring-music&lt;/code&gt;应用的信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf app spring-music
Showing health and status for app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

requested state: started
instances: 2/2
usage: 1G x 2 instances
urls: spring-music.local.pcfdev.io
last uploaded: Thu Mar 23 14:29:46 UTC 2017
stack: cflinuxfs2
buildpack: java-buildpack=v3.10-offline-https://github.com/cloudfoundry/java-buildpack.git#193d6b7 java-main open-jdk-like-jre=1.8.0_111 open-jdk-like-memory-calculator=2.0.2_RELEASE spring-auto-reconfiguration=1.10.0_RELEASE

     state      since                    cpu    memory         disk             details
#0   running    2017-03-23 10:44:18 PM   0.5%   451.4M of 1G   165.6M of 512M
#1   starting   2017-03-23 10:46:19 PM   0.0%   348.3M of 1G   165.6M of 512M

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以对内存进行扩容。这个操作会重启应用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf scale spring-music -m 1G
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
1 of 2 instances running, 1 down

App started


OK

App spring-music was started using this command `CALCULATED_MEMORY=$($PWD/.java-buildpack/open_jdk_jre/bin/java-buildpack-memory-calculator-2.0.2_RELEASE -memorySizes=metaspace:64m..,stack:228k.. -memoryWeights=heap:65,metaspace:10,native:15,stack:10 -memoryInitials=heap:100%,metaspace:100% -stackThreads=300 -totMemory=$MEMORY_LIMIT) &amp;amp;&amp;amp; JAVA_OPTS=&amp;quot;-Djava.io.tmpdir=$TMPDIR -XX:OnOutOfMemoryError=$PWD/.java-buildpack/open_jdk_jre/bin/killjava.sh $CALCULATED_MEMORY&amp;quot; &amp;amp;&amp;amp; SERVER_PORT=$PORT eval exec $PWD/.java-buildpack/open_jdk_jre/bin/java $JAVA_OPTS -cp $PWD/. org.springframework.boot.loader.JarLauncher`

Showing health and status for app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

requested state: started
instances: 1/2
usage: 1G x 2 instances
urls: spring-music.local.pcfdev.io
last uploaded: Thu Mar 23 14:29:46 UTC 2017
stack: cflinuxfs2
buildpack: java-buildpack=v3.10-offline-https://github.com/cloudfoundry/java-buildpack.git#193d6b7 java-main open-jdk-like-jre=1.8.0_111 open-jdk-like-memory-calculator=2.0.2_RELEASE spring-auto-reconfiguration=1.10.0_RELEASE

     state     since                    cpu      memory         disk             details
#0   running   2017-03-23 10:48:43 PM   145.1%   412.2M of 1G   165.6M of 512M
#1   down      2017-03-23 10:48:14 PM   0.7%     436.2M of 1G   165.6M of 512M   insufficient resources: memory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以增加应用的磁盘大小。这个操作也会重启应用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf scale spring-music -k 512M
This will cause the app to restart. Are you sure you want to scale spring-music?&amp;gt; y

Scaling app spring-music in org pcfdev-org / space pcfdev-space as user...
OK
Stopping app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

Starting app spring-music in org pcfdev-org / space pcfdev-space as user...

0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
1 of 2 instances running, 1 down

App started


OK

App spring-music was started using this command `CALCULATED_MEMORY=$($PWD/.java-buildpack/open_jdk_jre/bin/java-buildpack-memory-calculator-2.0.2_RELEASE -memorySizes=metaspace:64m..,stack:228k.. -memoryWeights=heap:65,metaspace:10,native:15,stack:10 -memoryInitials=heap:100%,metaspace:100% -stackThreads=300 -totMemory=$MEMORY_LIMIT) &amp;amp;&amp;amp; JAVA_OPTS=&amp;quot;-Djava.io.tmpdir=$TMPDIR -XX:OnOutOfMemoryError=$PWD/.java-buildpack/open_jdk_jre/bin/killjava.sh $CALCULATED_MEMORY&amp;quot; &amp;amp;&amp;amp; SERVER_PORT=$PORT eval exec $PWD/.java-buildpack/open_jdk_jre/bin/java $JAVA_OPTS -cp $PWD/. org.springframework.boot.loader.JarLauncher`

Showing health and status for app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

requested state: started
instances: 1/2
usage: 1G x 2 instances
urls: spring-music.local.pcfdev.io
last uploaded: Thu Mar 23 14:29:46 UTC 2017
stack: cflinuxfs2
buildpack: java-buildpack=v3.10-offline-https://github.com/cloudfoundry/java-buildpack.git#193d6b7 java-main open-jdk-like-jre=1.8.0_111 open-jdk-like-memory-calculator=2.0.2_RELEASE spring-auto-reconfiguration=1.10.0_RELEASE

     state     since                    cpu      memory         disk             details
#0   running   2017-03-23 10:50:57 PM   130.8%   376.2M of 1G   165.6M of 512M
#1   down      2017-03-23 10:50:32 PM   0.6%     438.5M of 1G   165.6M of 512M   insufficient resources: memory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的操作中可以看到，连续性特别强，所有的操作都可以在几秒钟内完成，特别适合&lt;strong&gt;微服务&lt;/strong&gt;的部署和&lt;strong&gt;Cloud Native&lt;/strong&gt; APP。&lt;/p&gt;

&lt;p&gt;关于&lt;strong&gt;Pivotal Cloud Foundry&lt;/strong&gt;的更多文档可以访问：&lt;a href=&#34;https://pivotal.io/cn/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry-dev/next-steps&#34;&gt;https://pivotal.io/cn/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry-dev/next-steps&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>