<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jimmy&#39;s blog</title>
    <link>http://rootsongjc.github.io/index.xml</link>
    <description>Recent content on Jimmy&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 31 Mar 2017 11:05:18 +0800</lastBuildDate>
    <atom:link href="http://rootsongjc.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Kubernetes基于flannel的网络配置</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-network-config/</link>
      <pubDate>Fri, 31 Mar 2017 11:05:18 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-network-config/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2014100402.jpg&#34; alt=&#34;西安鼓楼&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：西安鼓楼 Oct 4,2014）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;书接上文&lt;a href=&#34;http://rootsongjc.github.io/blogs/kubernetes-installation-on-centos/&#34;&gt;在CentOS中安装Kubernetes详细指南&lt;/a&gt;，这是一个系列文章，作为学习Kubernetes的心路历程吧。&lt;/p&gt;

&lt;p&gt;本文主要讲解&lt;strong&gt;Kubernetes的网络配置&lt;/strong&gt;，👆文中有一个安装&lt;strong&gt;Flannel&lt;/strong&gt;的步骤，但是安装好后并没有相应的配置说明。&lt;/p&gt;

&lt;h2 id=&#34;配置flannel&#34;&gt;配置flannel&lt;/h2&gt;

&lt;p&gt;我们直接使用的yum安装的flannle，安装好后会生成&lt;code&gt;/usr/lib/systemd/system/flanneld.service&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Flanneld overlay address etcd agent
After=network.target
After=network-online.target
Wants=network-online.target
After=etcd.service
Before=docker.service

[Service]
Type=notify
EnvironmentFile=/etc/sysconfig/flanneld
EnvironmentFile=-/etc/sysconfig/docker-network
ExecStart=/usr/bin/flanneld-start $FLANNEL_OPTIONS
ExecStartPost=/usr/libexec/flannel/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/docker
Restart=on-failure

[Install]
WantedBy=multi-user.target
RequiredBy=docker.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到flannel环境变量配置文件在&lt;code&gt;/etc/sysconfig/flanneld&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ini&#34;&gt;# Flanneld configuration options  

# etcd url location.  Point this to the server where etcd runs
FLANNEL_ETCD_ENDPOINTS=&amp;quot;http://sz-pg-oam-docker-test-001.tendcloud.com:2379&amp;quot;

# etcd config key.  This is the configuration key that flannel queries
# For address range assignment
FLANNEL_ETCD_PREFIX=&amp;quot;/kube-centos/network&amp;quot;

# Any additional options that you want to pass
#FLANNEL_OPTIONS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;etcd的地址&lt;code&gt;FLANNEL_ETCD_ENDPOINT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;etcd查询的目录，包含docker的IP地址段配置。&lt;code&gt;FLANNEL_ETCD_PREFIX&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;在etcd中创建网络配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行下面的命令为docker分配IP地址段。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;etcdctl mkdir /kube-centos/network
etcdctl mk /kube-centos/network/config &amp;quot;{ \&amp;quot;Network\&amp;quot;: \&amp;quot;172.30.0.0/16\&amp;quot;, \&amp;quot;SubnetLen\&amp;quot;: 24, \&amp;quot;Backend\&amp;quot;: { \&amp;quot;Type\&amp;quot;: \&amp;quot;vxlan\&amp;quot; } }&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置Docker&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Flannel的&lt;a href=&#34;https://github.com/coreos/flannel/blob/master/Documentation/running.md&#34;&gt;文档&lt;/a&gt;中有写&lt;strong&gt;Docker Integration&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;Docker daemon accepts &lt;code&gt;--bip&lt;/code&gt; argument to configure the subnet of the docker0 bridge. It also accepts &lt;code&gt;--mtu&lt;/code&gt; to set the MTU for docker0 and veth devices that it will be creating. Since flannel writes out the acquired subnet and MTU values into a file, the script starting Docker can source in the values and pass them to Docker daemon:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source /run/flannel/subnet.env
docker daemon --bip=${FLANNEL_SUBNET} --mtu=${FLANNEL_MTU} &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Systemd users can use &lt;code&gt;EnvironmentFile&lt;/code&gt; directive in the .service file to pull in &lt;code&gt;/run/flannel/subnet.env&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下载flannel github release中的tar包，解压后会获得一个&lt;strong&gt;mk-docker-opts.sh&lt;/strong&gt;文件。&lt;/p&gt;

&lt;p&gt;这个文件是用来&lt;code&gt;Generate Docker daemon options based on flannel env file&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;执行&lt;code&gt;./mk-docker-opts.sh -i&lt;/code&gt;将会生成如下两个文件环境变量文件。&lt;/p&gt;

&lt;p&gt;/run/flannel/subnet.env&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FLANNEL_NETWORK=172.30.0.0/16
FLANNEL_SUBNET=172.30.46.1/24
FLANNEL_MTU=1450
FLANNEL_IPMASQ=false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/run/docker_opts.env&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DOCKER_OPT_BIP=&amp;quot;--bip=172.30.46.1/24&amp;quot;
DOCKER_OPT_IPMASQ=&amp;quot;--ip-masq=true&amp;quot;
DOCKER_OPT_MTU=&amp;quot;--mtu=1450&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在查询etcd中的内容可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$etcdctl ls /kube-centos/network/subnets
/kube-centos/network/subnets/172.30.14.0-24
/kube-centos/network/subnets/172.30.38.0-24
/kube-centos/network/subnets/172.30.46.0-24
$etcdctl get /kube-centos/network/config
{ &amp;quot;Network&amp;quot;: &amp;quot;172.30.0.0/16&amp;quot;, &amp;quot;SubnetLen&amp;quot;: 24, &amp;quot;Backend&amp;quot;: { &amp;quot;Type&amp;quot;: &amp;quot;vxlan&amp;quot; } }
$etcdctl get /kube-centos/network/subnets/172.30.14.0-24
{&amp;quot;PublicIP&amp;quot;:&amp;quot;172.20.0.114&amp;quot;,&amp;quot;BackendType&amp;quot;:&amp;quot;vxlan&amp;quot;,&amp;quot;BackendData&amp;quot;:{&amp;quot;VtepMAC&amp;quot;:&amp;quot;56:27:7d:1c:08:22&amp;quot;}}
$etcdctl get /kube-centos/network/subnets/172.30.38.0-24
{&amp;quot;PublicIP&amp;quot;:&amp;quot;172.20.0.115&amp;quot;,&amp;quot;BackendType&amp;quot;:&amp;quot;vxlan&amp;quot;,&amp;quot;BackendData&amp;quot;:{&amp;quot;VtepMAC&amp;quot;:&amp;quot;12:82:83:59:cf:b8&amp;quot;}}
$etcdctl get /kube-centos/network/subnets/172.30.46.0-24
{&amp;quot;PublicIP&amp;quot;:&amp;quot;172.20.0.113&amp;quot;,&amp;quot;BackendType&amp;quot;:&amp;quot;vxlan&amp;quot;,&amp;quot;BackendData&amp;quot;:{&amp;quot;VtepMAC&amp;quot;:&amp;quot;e6:b2:fd:f6:66:96&amp;quot;}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;设置docker0网桥的IP地址&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;source /run/flannel/subnet.env
ifconfig docker0 $FLANNEL_SUBNET
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样docker0和flannel网桥会在同一个子网中，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;6: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN 
    link/ether 02:42:da:bf:83:a2 brd ff:ff:ff:ff:ff:ff
    inet 172.30.38.1/24 brd 172.30.38.255 scope global docker0
       valid_lft forever preferred_lft forever
7: flannel.1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue state UNKNOWN 
    link/ether 9a:29:46:61:03:44 brd ff:ff:ff:ff:ff:ff
    inet 172.30.38.0/32 scope global flannel.1
       valid_lft forever preferred_lft forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就可以重启docker了。&lt;/p&gt;

&lt;p&gt;重启了docker后还要重启kubelet，这时又遇到问题，kubelet启动失败。报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Mar 31 16:44:41 sz-pg-oam-docker-test-002.tendcloud.com kubelet[81047]: error: failed to run Kubelet: failed to create kubelet: misconfiguration: kubelet cgroup driver: &amp;quot;cgroupfs&amp;quot; is different from docker cgroup driver: &amp;quot;systemd&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是kubelet与docker的&lt;strong&gt;cgroup driver&lt;/strong&gt;不一致导致的，kubelet启动的时候有个&lt;code&gt;—cgroup-driver&lt;/code&gt;参数可以指定为&amp;rdquo;cgroupfs&amp;rdquo;或者“systemd”。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;--cgroup-driver string                                    Driver that the kubelet uses to manipulate cgroups on the host.  Possible values: &#39;cgroupfs&#39;, &#39;systemd&#39; (default &amp;quot;cgroupfs&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;启动flannel&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl daemon-reload
systemctl start flanneld
systemctl status flanneld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新登录这三台主机，可以看到每台主机都多了一个IP。&lt;/p&gt;

&lt;p&gt;参考Kubernetes官方文档的&lt;a href=&#34;https://kubernetes.io/docs/tutorials/stateless-application/expose-external-ip-address/&#34;&gt;Exposing an External IP Address to Access an Application in a Cluster&lt;/a&gt;，官方使用的Hello World测试，我们启动Nginx服务测试。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;#启动nginx的pod
kubectl run nginx --replicas=2 --labels=&amp;quot;run=load-balancer-example&amp;quot; --image=sz-pg-oam-docker-hub-001.tendcloud.com/library/nginx:1.9  --port=80
#创建名为example-service的服务
kubectl expose deployment nginx --type=NodePort --name=example-service
#查看状态
kubectl get deployments nginx
kubectl describe deployments nginx
kubectl get replicasets
kubectl describe replicasets
kubectl describe svc example-service
###################################################
Name:			example-service
Namespace:		default
Labels:			run=load-balancer-example
Annotations:		&amp;lt;none&amp;gt;
Selector:		run=load-balancer-example
Type:			NodePort
IP:			10.254.180.209
Port:			&amp;lt;unset&amp;gt;	80/TCP
NodePort:		&amp;lt;unset&amp;gt;	32663/TCP
Endpoints:		172.30.14.2:80,172.30.46.2:80
Session Affinity:	None
Events:			&amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们上面启动的serivce的type是&lt;strong&gt;NodePort&lt;/strong&gt;，Kubernetes的service支持三种类型的service，参考&lt;a href=&#34;http://www.cnblogs.com/xuxinkun/p/5331728.html&#34;&gt;Kubernetes Serivce分析&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;现在访问三台物理机的IP:80端口就可以看到nginx的页面了。&lt;/p&gt;

&lt;p&gt;稍等一会在访问ClusterIP + Port也可以访问到nginx。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$curl 10.254.180.209:80
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Welcome to nginx!&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;For online documentation and support please refer to
&amp;lt;a href=&amp;quot;http://nginx.org/&amp;quot;&amp;gt;nginx.org&amp;lt;/a&amp;gt;.&amp;lt;br/&amp;gt;
Commercial support is available at
&amp;lt;a href=&amp;quot;http://nginx.com/&amp;quot;&amp;gt;nginx.com&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Thank you for using nginx.&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;虚拟地址&#34;&gt;虚拟地址&lt;/h2&gt;

&lt;p&gt;Kubernetes中的Service了使用了虚拟地址；该地址无法ping通过，但可以访问其端口。通过下面的命令可以看到，该虚拟地址是若干条iptables的规则。到10.254.124.145:8080端口的请求会被重定向到172.30.38.2或172.30.46.2的8080端口。这些规则是由kube-proxy生成；如果需要某台机器可以访问Service，则需要在该主机启动kube-proxy。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看service的iptables&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$iptables-save|grep example-service
-A KUBE-NODEPORTS -p tcp -m comment --comment &amp;quot;default/example-service:&amp;quot; -m tcp --dport 32663 -j KUBE-MARK-MASQ
-A KUBE-NODEPORTS -p tcp -m comment --comment &amp;quot;default/example-service:&amp;quot; -m tcp --dport 32663 -j KUBE-SVC-BR4KARPIGKMRMN3E
-A KUBE-SEP-NCPBOLUH5XTTHG3E -s 172.30.46.2/32 -m comment --comment &amp;quot;default/example-service:&amp;quot; -j KUBE-MARK-MASQ
-A KUBE-SEP-NCPBOLUH5XTTHG3E -p tcp -m comment --comment &amp;quot;default/example-service:&amp;quot; -m tcp -j DNAT --to-destination 172.30.46.2:80
-A KUBE-SEP-ONEKQBIWICF7RAR3 -s 172.30.14.2/32 -m comment --comment &amp;quot;default/example-service:&amp;quot; -j KUBE-MARK-MASQ
-A KUBE-SEP-ONEKQBIWICF7RAR3 -p tcp -m comment --comment &amp;quot;default/example-service:&amp;quot; -m tcp -j DNAT --to-destination 172.30.14.2:80
-A KUBE-SERVICES -d 10.254.180.209/32 -p tcp -m comment --comment &amp;quot;default/example-service: cluster IP&amp;quot; -m tcp --dport 80 -j KUBE-SVC-BR4KARPIGKMRMN3E
-A KUBE-SVC-BR4KARPIGKMRMN3E -m comment --comment &amp;quot;default/example-service:&amp;quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-ONEKQBIWICF7RAR3
-A KUBE-SVC-BR4KARPIGKMRMN3E -m comment --comment &amp;quot;default/example-service:&amp;quot; -j KUBE-SEP-NCPBOLUH5XTTHG3E
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;查看clusterIP的iptables&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$iptables -t nat -nL|grep 10.254
KUBE-SVC-NPX46M4PTMTKRN6Y  tcp  --  0.0.0.0/0            10.254.0.1           /* default/kubernetes:https cluster IP */ tcp dpt:443
KUBE-SVC-BR4KARPIGKMRMN3E  tcp  --  0.0.0.0/0            10.254.180.209       /* default/example-service: cluster IP */ tcp dpt:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到在PREROUTING环节，k8s设置了一个target: KUBE-SERVICES。而KUBE-SERVICES下面又设置了许多target，一旦destination和dstport匹配，就会沿着chain进行处理。&lt;/p&gt;

&lt;p&gt;比如：当我们在pod网络curl 10.254.198.44 80时，匹配到下面的KUBE-SVC-BR4KARPIGKMRMN3E target：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;KUBE-SVC-BR4KARPIGKMRMN3E  tcp  --  0.0.0.0/0            10.254.180.209       /* default/example-service: cluster IP */ tcp dpt:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考&lt;a href=&#34;http://tonybai.com/2017/01/17/understanding-flannel-network-for-kubernetes/&#34;&gt;理解Kubernetes网络之Flannel网络&lt;/a&gt;，Tony Bai的文章中有对flannel的详细介绍。&lt;/p&gt;

&lt;h2 id=&#34;遇到的问题&#34;&gt;遇到的问题&lt;/h2&gt;

&lt;p&gt;在设置网络的过程中遇到了很多问题，记录如下。&lt;/p&gt;

&lt;h3 id=&#34;问题一&#34;&gt;问题一&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Kube-proxy开放的&lt;strong&gt;NodePort&lt;/strong&gt;端口无法访问。即无法使用NodeIP加NodePort的方式访问service，而且本地telnet也不通，但是端口确确实实在那。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;已解决&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实这不是问题，是因为从上面的操作记录中我们可以看到，&lt;strong&gt;在启动Nginx的Pod&lt;/strong&gt;时，指定port为80即可。以ClusterIP + Port的方式访问serivce需要等一段时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;反思&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个问题困扰了我们差不多两天时间，出现这个问题的根源还是因为&lt;u&gt;思想观念没有从运行docker的命令中解放出来&lt;/u&gt;,还把&lt;code&gt;kubelet run —port&lt;/code&gt;当成是docker run中的端口映射，这种想法是大错特错的，该端口是image中的应用实际暴露的端口，如nginx的80端口。😔&lt;/p&gt;

&lt;h3 id=&#34;问题二&#34;&gt;问题二&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在没有删除service和deploy的情况下就重启kubelet的时候，会遇到kubelet启动失败的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;出错信息&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Apr 01 14:24:08 sz-pg-oam-docker-test-001.tendcloud.com kubelet[103932]: I0401 14:24:08.359839  103932 kubelet.go:1752] skipping pod synchronization - [Failed to start ContainerManager failed to initialise top level QOS containers: failed to create top level Burstable QOS cgroup : Unit kubepods-burstable.slice already exists.]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.osbaike.net/article-show-id-229028.html&#34;&gt;Kubernetes Resource QoS机制解读&lt;/a&gt;，这篇文章详细介绍了QoS的机制。&lt;/p&gt;

&lt;p&gt;Kubernetes根据Pod中Containers Resource的&lt;code&gt;request&lt;/code&gt;和&lt;code&gt;limit&lt;/code&gt;的值来定义Pod的QoS Class。&lt;/p&gt;

&lt;p&gt;对于每一种Resource都可以将容器分为3中QoS Classes: Guaranteed, Burstable, and Best-Effort，它们的QoS级别依次递减。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Guaranteed&lt;/strong&gt;：如果Pod中所有Container的所有Resource的&lt;code&gt;limit&lt;/code&gt;和&lt;code&gt;request&lt;/code&gt;都相等且不为0，则这个Pod的QoS Class就是Guaranteed。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Burstable&lt;/strong&gt;：除了符合Guaranteed和Best-Effort的场景，其他场景的Pod QoS Class都属于Burstable。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Best-Effort&lt;/strong&gt;：如果Pod中所有容器的所有Resource的request和limit都没有赋值，则这个Pod的QoS Class就是Best-Effort。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个暂时还没找到根本的解决办法，参考Github上的&lt;a href=&#34;https://github.com/kubernetes/kubernetes/issues/43856&#34;&gt;Failed to start ContainerManager failed to initialize top level QOS containers #43856&lt;/a&gt;，重启主机后确实正常了，不过这只是临时解决方法。&lt;/p&gt;

&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;

&lt;p&gt;其实昨天就已经安装完毕了，是我们使用的姿势不对，白白耽误这么长时间，身边差个老司机啊，滴～学生卡。&lt;/p&gt;

&lt;p&gt;感谢&lt;a href=&#34;tonybai.com&#34;&gt;Tony Bai&lt;/a&gt;、&lt;a href=&#34;https://godliness.github.io/&#34;&gt;Peter Ma&lt;/a&gt;的大力支持。&lt;/p&gt;

&lt;p&gt;Apr 1,2017 愚人节，东直门&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TensorFlow实战（才云郑泽宇著）读书笔记——第三章TensorFlow入门</title>
      <link>http://rootsongjc.github.io/blogs/tensorflow-practice-03/</link>
      <pubDate>Thu, 30 Mar 2017 21:34:33 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/tensorflow-practice-03/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2015052401.jpg&#34; alt=&#34;扬州东关&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：扬州东关 May 24,2015）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这是我阅读&lt;a href=&#34;caicloud.io&#34;&gt;才云科技&lt;/a&gt;郑泽宇的《TensorFlow实战Google深度学习框架》的读书笔记系列文章，按照文章的章节顺序来写的。整本书的笔记归档在&lt;a href=&#34;http://rootsongjc.github.io/tags/tensorflow-practice-reading-notes/&#34;&gt;这里&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;P.S 本书的&lt;strong&gt;官方读者交流微信群（作者也在群里）&lt;/strong&gt;已经超过100人，您可以先加我微信后我拉您进去，我的二维码在&lt;a href=&#34;rootsongjc.github.io/about&#34;&gt;这里&lt;/a&gt;，或者直接搜索我的微信号jimmysong。&lt;/p&gt;

&lt;p&gt;这一章从三个角度带大家入门。&lt;/p&gt;

&lt;p&gt;分别是TensorFlow的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算模型&lt;/li&gt;
&lt;li&gt;数据模型&lt;/li&gt;
&lt;li&gt;运行模型&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-1-tensorflow的计算模型-图计算&#34;&gt;3.1 TensorFlow的计算模型——图计算&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;计算图&lt;/strong&gt;是TensorFlow中的一个最基本的概念，&lt;u&gt;TensorFlow中的所有计算都会转化成计算图上的节点&lt;/u&gt;。&lt;/p&gt;

&lt;p&gt;其实TensorFlow的名字已经暗示了它的实现方式了，&lt;strong&gt;Tensor&lt;/strong&gt;表示的是数据结构——张量，&lt;strong&gt;Flow&lt;/strong&gt;表示数据流——Tensor通过数据流相互转化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用的方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在python中导入tensorflow：import tensorflow as tf&lt;/li&gt;
&lt;li&gt;获取当前默认的计算图：tf.get_default_graph()&lt;/li&gt;
&lt;li&gt;生成新的计算图：tf.Graph()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;书中这里都有例子讲解，可以从Github中&lt;a href=&#34;https://github.com/caicloud/tensorflow-tutorial&#34;&gt;下载代码&lt;/a&gt;，或者如果你使用才云提供的docker镜像的方式安装的话，在jupyter中可以看到各个章节的代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义两个不同的图&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import tensorflow as tf

g1 = tf.Graph()
with g1.as_default():
    v = tf.get_variable(&amp;quot;v&amp;quot;, [1], initializer = tf.zeros_initializer) # 设置初始值为0

g2 = tf.Graph()
with g2.as_default():
    v = tf.get_variable(&amp;quot;v&amp;quot;, [1], initializer = tf.ones_initializer())  # 设置初始值为1
    
with tf.Session(graph = g1) as sess:
    tf.global_variables_initializer().run()
    with tf.variable_scope(&amp;quot;&amp;quot;, reuse=True):
        print(sess.run(tf.get_variable(&amp;quot;v&amp;quot;)))

with tf.Session(graph = g2) as sess:
    tf.global_variables_initializer().run()
    with tf.variable_scope(&amp;quot;&amp;quot;, reuse=True):
        print(sess.run(tf.get_variable(&amp;quot;v&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到这里面用了&lt;a href=&#34;https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/&#34;&gt;python中的with语法&lt;/a&gt;，不了解的可以到前面那个链接看看。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;TensorFlow中维护的集合列表&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;集合名称&lt;/th&gt;
&lt;th&gt;集合内容&lt;/th&gt;
&lt;th&gt;使用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.VARIABLES&lt;/td&gt;
&lt;td&gt;所有变量&lt;/td&gt;
&lt;td&gt;持久化TensorFlow模型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.TRAINABLE_VARIABLES&lt;/td&gt;
&lt;td&gt;可学习的变量（一般指神经网络中的参数）&lt;/td&gt;
&lt;td&gt;模型训练、生活从呢个模型可视化内容&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.SUMMARIES&lt;/td&gt;
&lt;td&gt;与日志有关的张量&lt;/td&gt;
&lt;td&gt;TensorFlow计算可视化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.QUEUE_RUNNERS&lt;/td&gt;
&lt;td&gt;处理输入的QueueRunner&lt;/td&gt;
&lt;td&gt;输入处理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tf.GraphKeys.MOVING_AVERAGE_VARIABLES&lt;/td&gt;
&lt;td&gt;所有计算了滑动平均值的变量&lt;/td&gt;
&lt;td&gt;计算变量的滑动平均值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;所谓的滑动平均值即移动平均值，熟悉股票的应该都知道均线的概念吧，5日均线，20日均线，30日均线啥的，一般称作MA(Moving Average)。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-2-tensorflow数据模型-张量&#34;&gt;3.2 TensorFlow数据模型——张量&lt;/h2&gt;

&lt;p&gt;张量（Tensor）是TensorFlow中所有数据的表现形式。我们可以简单的将Tensor理解为&lt;strong&gt;多维数组&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0阶的话就是一个标量（Scalar），可以是一个数也可以是一个字符串&lt;/li&gt;
&lt;li&gt;一阶的话是向量（Vector）&lt;/li&gt;
&lt;li&gt;n阶的话就是n维数组&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tensor在TensorFlow中并不是直接采用数组的形式，而是&lt;strong&gt;对TF中计算结果的引用&lt;/strong&gt;，保存的是如何得到这些数字的过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;举个例子&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;import tensorflow as tf
a = tf.constant([1.0, 2.0], name=&amp;quot;a&amp;quot;)
b = tf.constant([2.0, 3.0], name=&amp;quot;b&amp;quot;)
result = tf.add(a,b,name=&amp;quot;add&amp;quot;)
print result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Tensor(&amp;quot;add:0&amp;quot;, shape=(2,), dtype=float32)
[ 3.  5.]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子只是简单的做了个加法，下面结合上面的例子来讲解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tensor的3个属性&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;名字（Name）&lt;/strong&gt;：Tensor的唯一标识符，如例子中的a, b, result，这是我们手动指定的，实际上Tensor是与计算图上的每个节点一一对应的，tensor的命名可以通过&lt;code&gt;node:src_output&lt;/code&gt;的形式给出，如例子输出中的计算结果名字为&lt;strong&gt;add:0&lt;/strong&gt;，0表示的是计算节点&lt;strong&gt;add&lt;/strong&gt;输出的第一个结果。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;维度（Shape）&lt;/strong&gt;：如上面例子结果输出中的&lt;strong&gt;shape=(2,)&lt;/strong&gt;，表示这个张量是一维数组，数组的长度是2。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型（Type）&lt;/strong&gt;：所有参与运算的张量的类型必须是相同的，比如不能float和int之间运算。TensorFlow会自动检查张量的类型，可以通过&lt;strong&gt;dtype=df.float32&lt;/strong&gt;这样的声明来指定类型，如果不指定的话，TF会根据值确定默认类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Tensor的用途&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;作为对计算中间结果的引用，比如上面例子中的a和b，在复杂计算中使用tensor能够增加代码的可阅读性。&lt;/li&gt;
&lt;li&gt;用来获取计算结果。张量本身没有存储具体的数字，但是可以使用&lt;strong&gt;会话&lt;/strong&gt;的tf.Session().run(result)来获取计算结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-3-tensorflow的运行模型-会话&#34;&gt;3.3 TensorFlow的运行模型——会话&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;会话（Session）拥有和管理TensorFlow中所有的运算，可以执行定义好的运算。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建和关闭会话&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 创建一个会话。
sess = tf.Session()

# 使用会话得到之前计算的结果。
print(sess.run(result))

# 关闭会话使得本次运行中使用到的资源可以被释放。
sess.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议使用Python的&lt;strong&gt;上下文管理器&lt;/strong&gt;，即通过&lt;strong&gt;with&lt;/strong&gt;语法来创建会话，能够避免资源泄漏。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;with tf.Session() as sess:
    print(sess.run(result))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在交互式环境下（比如Jupyter）直接使用&lt;strong&gt;tf.InteractiveSession&lt;/strong&gt;函数创建&lt;strong&gt;交互式会话&lt;/strong&gt;，将产生的会话直接注册为默认会话。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sess = tf.InteractiveSession ()
print(result.eval())
sess.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不论使用哪种会话都可以通过&lt;strong&gt;ConfigProto&lt;/strong&gt;来配置&lt;code&gt;并行线程数&lt;/code&gt;、&lt;code&gt;GPU分配策略&lt;/code&gt;、&lt;code&gt;运算超时时间&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;常用的两个配置有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;allow_soft_placement&lt;/strong&gt;：布尔值，默认false，以下任何一个条件满足时则为true，允许将GPU上的运算放到CPU上进行。

&lt;ul&gt;
&lt;li&gt;运算无法在GPU上运行&lt;/li&gt;
&lt;li&gt;GPU资源不足（没有GPU或者指定的GPU个数不够）&lt;/li&gt;
&lt;li&gt;运算输入包括对CPU计算结果的引用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;log_device_placement&lt;/strong&gt;：布尔值，默认值是？如果为true的话，日志中将会记录每个节点被安排在哪个设备上，这方便调试。生产环境中一般设置为false，能够减少日志量。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-4-tensorflow实现神经网络&#34;&gt;3.4 TensorFlow实现神经网络&lt;/h2&gt;

&lt;p&gt;To be continued…&lt;/p&gt;

&lt;p&gt;10:39 p.m Thu Mar 30,2017&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在CentOS上安装kubernetes详细指南</title>
      <link>http://rootsongjc.github.io/blogs/kubernetes-installation-on-centos/</link>
      <pubDate>Thu, 30 Mar 2017 20:44:20 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/kubernetes-installation-on-centos/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2014082501.jpg&#34; alt=&#34;圆明园&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：北京圆明园 Aug 25,2014）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;作者：&lt;a href=&#34;rootsongjc.github.io/about&#34;&gt;Jimmy Song&lt;/a&gt;，&lt;a href=&#34;https://godliness.github.io/&#34;&gt;Peter Ma&lt;/a&gt;，2017年3月30日&lt;/p&gt;

&lt;p&gt;最近决定从Docker Swarm Mode投入到Kubernetes的怀抱，对Docker的战略和企业化发展前景比较堪忧，而Kubernetes是&lt;a href=&#34;https://www.cncf.io/&#34;&gt;CNCF&lt;/a&gt;的成员之一。&lt;/p&gt;

&lt;p&gt;这篇是根据&lt;a href=&#34;https://kubernetes.io/docs/getting-started-guides/centos/centos_manual_config/#prerequisites&#34;&gt;官方安装文档&lt;/a&gt;实践整理的，操作系统是纯净的CentOS7.2。&lt;/p&gt;

&lt;p&gt;另外还有一个Peter Ma写的&lt;a href=&#34;https://godliness.github.io/2017/03/29/%E5%9C%A8CentOS7%E4%B8%8A%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Kubernetes/&#34;&gt;在CentOS上手动安装kubernetes的文档&lt;/a&gt;可以参考。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;角色分配&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面以在三台主机上安装Kubernetes为例。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;172.20.0.113 master/node kube-apiserver kube-controller-manager kube-scheduler kubelet kube-proxy etcd flannel
172.20.0.114 node kubectl kube-proxy flannel
172.20.0.115 node kubectl kube-proxy flannel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一台主机既作为master也作为node。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;系统环境&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Centos 7.2.1511&lt;/li&gt;
&lt;li&gt;docker 1.12.6&lt;/li&gt;
&lt;li&gt;etcd 3.1.5&lt;/li&gt;
&lt;li&gt;kubernetes 1.6.0&lt;/li&gt;
&lt;li&gt;flannel 0.7.0-1&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;p&gt;下面给出两种安装方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;配置yum源后，使用yum安装，好处是简单，坏处也很明显，需要google更新yum源才能获得最新版本的软件，而所有软件的依赖又不能自己指定，尤其是你的操作系统版本如果低的话，使用yum源安装的kubernetes的版本也会受到限制。&lt;/li&gt;
&lt;li&gt;使用二进制文件安装，好处是可以安装任意版本的kubernetes，坏处是配置比较复杂。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们最终选择使用第二种方式安装。&lt;/p&gt;

&lt;p&gt;本文的很多安装步骤和命令是参考的Kubernetes官网&lt;a href=&#34;https://kubernetes.io/docs/getting-started-guides/centos/centos_manual_config/&#34;&gt;CentOS Manual Config&lt;/a&gt;文档。&lt;/p&gt;

&lt;h2 id=&#34;第一种方式-centos系统中直接使用yum安装&#34;&gt;第一种方式：CentOS系统中直接使用yum安装&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;给yum源增加一个Repo&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[virt7-docker-common-release]
name=virt7-docker-common-release
baseurl=http://cbs.centos.org/repos/virt7-docker-common-release/x86_64/os/
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;安装docker、kubernetes、etcd、flannel一步到位&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install --enablerepo=virt7-docker-common-release kubernetes etcd flannel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装好了之后需要修改一系列配置文件。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这个repo在CentOS7.3下是毫无意义的，因为CentOS官方源的extras中已经包含了Kubernetes1.5.2，如果你使用的是CentOS7.3的话，会自动下载安装Kubernetes1.5.2（Till March 30,2017）。如果你使用的是CentOS7.2的化，这个源就有用了，但是不幸的是，它会自动下载安装Kubernentes1.1。我们现在要安装目前的最新版本Kubernetes1.6，而使用的又是CentOS7.2，所以我们不使用yum安装（当前yum源支持的最高版本的kuberentes是1.5.2）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;第二种方式-使用二进制文件安装&#34;&gt;第二种方式：使用二进制文件安装&lt;/h2&gt;

&lt;p&gt;这种方式安装的话，需要自己一个一个组件的安装。&lt;/p&gt;

&lt;h3 id=&#34;安装docker&#34;&gt;安装Docker&lt;/h3&gt;

&lt;p&gt;yum localinstall ./docker-engine*&lt;/p&gt;

&lt;p&gt;将使用CentOS的&lt;strong&gt;extras&lt;/strong&gt; repo下载。&lt;/p&gt;

&lt;h3 id=&#34;关闭防火墙和selinux&#34;&gt;关闭防火墙和SELinux&lt;/h3&gt;

&lt;p&gt;这是官网上建议的，我是直接将iptables-services和firewlld卸载掉了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;setenforce 0
systemctl disable iptables-services firewalld
systemctl stop iptables-services firewalld
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;安装etcd&#34;&gt;安装etcd&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;下载二进制文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;DOWNLOAD_URL=https://storage.googleapis.com/etcd  #etcd存储地址
ETCD_VER=v3.1.5  #设置etcd版本号
wget ${DOWNLOAD_URL}/${ETCD_VER}/etcd-${ETCD_VER}-linux-amd64.tar.gz
tar xvf etcd-${ETCD_VER}-linux-amd64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;部署文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将如下内容写入文件 /etc/etcd/etcd.conf 中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;# [member]
ETCD_NAME=default
ETCD_DATA_DIR=&amp;quot;/var/lib/etcd/default.etcd&amp;quot;
# ETCD_WAL_DIR=&amp;quot;&amp;quot;
# ETCD_SNAPSHOT_COUNT=&amp;quot;10000&amp;quot;
# ETCD_HEARTBEAT_INTERVAL=&amp;quot;100&amp;quot;
# ETCD_ELECTION_TIMEOUT=&amp;quot;1000&amp;quot;
# ETCD_LISTEN_PEER_URLS=&amp;quot;http://localhost:2380&amp;quot;
ETCD_LISTEN_CLIENT_URLS=&amp;quot;http://0.0.0.0:2379&amp;quot;
# ETCD_MAX_SNAPSHOTS=&amp;quot;5&amp;quot;
# ETCD_MAX_WALS=&amp;quot;5&amp;quot;
# ETCD_CORS=&amp;quot;&amp;quot;
#
# [cluster]
# ETCD_INITIAL_ADVERTISE_PEER_URLS=&amp;quot;http://localhost:2380&amp;quot;
# if you use different ETCD_NAME (e.g. test), set ETCD_INITIAL_CLUSTER value for this name, i.e. &amp;quot;test=http://...&amp;quot;
# ETCD_INITIAL_CLUSTER=&amp;quot;default=http://localhost:2380&amp;quot;
# ETCD_INITIAL_CLUSTER_STATE=&amp;quot;new&amp;quot;
# ETCD_INITIAL_CLUSTER_TOKEN=&amp;quot;etcd-cluster&amp;quot;
ETCD_ADVERTISE_CLIENT_URLS=&amp;quot;http://0.0.0.0:2379&amp;quot;
# ETCD_DISCOVERY=&amp;quot;&amp;quot;
# ETCD_DISCOVERY_SRV=&amp;quot;&amp;quot;
# ETCD_DISCOVERY_FALLBACK=&amp;quot;proxy&amp;quot;
# ETCD_DISCOVERY_PROXY=&amp;quot;&amp;quot;
#
# [proxy]
# ETCD_PROXY=&amp;quot;off&amp;quot;
# ETCD_PROXY_FAILURE_WAIT=&amp;quot;5000&amp;quot;
# ETCD_PROXY_REFRESH_INTERVAL=&amp;quot;30000&amp;quot;
# ETCD_PROXY_DIAL_TIMEOUT=&amp;quot;1000&amp;quot;
# ETCD_PROXY_WRITE_TIMEOUT=&amp;quot;5000&amp;quot;
# ETCD_PROXY_READ_TIMEOUT=&amp;quot;0&amp;quot;
#
# [security]
# ETCD_CERT_FILE=&amp;quot;&amp;quot;
# ETCD_KEY_FILE=&amp;quot;&amp;quot;
# ETCD_CLIENT_CERT_AUTH=&amp;quot;false&amp;quot;
# ETCD_TRUSTED_CA_FILE=&amp;quot;&amp;quot;
# ETCD_PEER_CERT_FILE=&amp;quot;&amp;quot;
# ETCD_PEER_KEY_FILE=&amp;quot;&amp;quot;
# ETCD_PEER_CLIENT_CERT_AUTH=&amp;quot;false&amp;quot;
# ETCD_PEER_TRUSTED_CA_FILE=&amp;quot;&amp;quot;
# [logging]
# ETCD_DEBUG=&amp;quot;false&amp;quot;
# examples for -log-package-levels etcdserver=WARNING,security=DEBUG
# ETCD_LOG_PACKAGE_LEVELS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将 etcd, etcdctl放入 /usr/bin/下，并将如下内容写进/usr/lib/systemd/system/etcd.service文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ini&#34;&gt;[Unit]
Description=Etcd Server
After=network.target
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
WorkingDirectory=/var/lib/etcd/
EnvironmentFile=-/etc/etcd/etcd.conf
User=etcd
# set GOMAXPROCS to number of processors
ExecStart=/bin/bash -c &amp;quot;GOMAXPROCS=$(nproc) /usr/bin/etcd --name=\&amp;quot;${ETCD_NAME}\&amp;quot; --data-dir=\&amp;quot;${ETCD_DATA_DIR}\&amp;quot; --listen-client-urls=\&amp;quot;${ETCD_LISTEN_CLIENT_URLS}\&amp;quot;&amp;quot;
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;启动并校验&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;systemctl start etcd
systemctl enable etcd
systemctl status etcd
etcdctl ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;集群&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;若要部署多节点集群也比较简单，只要更改etcd.conf文件以及etcd.service添加相应配置即可&lt;/p&gt;

&lt;p&gt;可以参考链接：&lt;a href=&#34;https://github.com/coreos/etcd/blob/master/Documentation/op-guide/clustering.md&#34;&gt;https://github.com/coreos/etcd/blob/master/Documentation/op-guide/clustering.md&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;安装flannel&#34;&gt;安装flannel&lt;/h3&gt;

&lt;p&gt;可以直接使用&lt;code&gt;yum install flannel&lt;/code&gt;安装。&lt;/p&gt;

&lt;p&gt;因为网络这块的配置比较复杂，我将在后续文章中说明。&lt;/p&gt;

&lt;h3 id=&#34;安装kubernetes&#34;&gt;安装Kubernetes&lt;/h3&gt;

&lt;p&gt;根据《Kubernetes权威指南（第二版）》中的介绍，直接使用GitHub上的release里的二进制文件安装。&lt;/p&gt;

&lt;p&gt;执行下面的命令安装。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://github.com/kubernetes/kubernetes/releases/download/v1.6.0/kubernetes.tar.gz
tar kubernetes.tar.gz
cd kubernetes
./cluster/get-kube-binaries.sh
cd server
tar xvf kubernetes-server-linux-amd64.tar.gz
rm -f *_tag *.tar
chmod 755 *
mv * /usr/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际下载kubernetes-server-linux-amd64.tar.gz from &lt;a href=&#34;https://storage.googleapis.com/kubernetes-release/release/v1.6.0&#34;&gt;https://storage.googleapis.com/kubernetes-release/release/v1.6.0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解压完后获得的二进制文件有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cloud-controller-manager
hyperkube
kubeadm
kube-aggregator
kube-apiserver
kube-controller-manager
kubectl
kubefed
kubelet
kube-proxy
kube-scheduler
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;cluster/juju/layers/kubernetes-master/templates&lt;/code&gt;目录下有service和环境变量配置文件的模板，这个模板本来是为了使用&lt;a href=&#34;https://jujucharms.com/&#34;&gt;juju&lt;/a&gt;安装写的。&lt;/p&gt;

&lt;h4 id=&#34;master节点的配置&#34;&gt;Master节点的配置&lt;/h4&gt;

&lt;p&gt;Master节点需要配置的kubernetes的组件有：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kube-apiserver&lt;/li&gt;
&lt;li&gt;kube-controller-manager&lt;/li&gt;
&lt;li&gt;kube-scheduler&lt;/li&gt;
&lt;li&gt;kube-proxy&lt;/li&gt;
&lt;li&gt;kubectl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;配置kube-apiserver&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编写&lt;code&gt;/usr/lib/systemd/system/kube-apiserver.service&lt;/code&gt;文件。&lt;a href=&#34;http://blog.csdn.net/yuesichiu/article/details/51485147&#34;&gt;CentOS中的service配置文件参考&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes API Service
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=network.target
After=etcd.service

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/apiserver
ExecStart=/usr/bin/kube-apiserver \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_ETCD_SERVERS \
	    $KUBE_API_ADDRESS \
	    $KUBE_API_PORT \
	    $KUBELET_PORT \
	    $KUBE_ALLOW_PRIV \
	    $KUBE_SERVICE_ADDRESSES \
	    $KUBE_ADMISSION_CONTROL \
	    $KUBE_API_ARGS
Restart=on-failure
Type=notify
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建kubernetes的配置文件目录&lt;code&gt;/etc/kubernetes&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;添加&lt;code&gt;config&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
# kubernetes system config
#
# The following values are used to configure various aspects of all
# kubernetes services, including
#
#   kube-apiserver.service
#   kube-controller-manager.service
#   kube-scheduler.service
#   kubelet.service
#   kube-proxy.service
# logging to stderr means we get it in the systemd journal
KUBE_LOGTOSTDERR=&amp;quot;--logtostderr=true&amp;quot;

# journal message level, 0 is debug
KUBE_LOG_LEVEL=&amp;quot;--v=0&amp;quot;

# Should this cluster be allowed to run privileged docker containers
KUBE_ALLOW_PRIV=&amp;quot;--allow-privileged=false&amp;quot;

# How the controller-manager, scheduler, and proxy find the apiserver
KUBE_MASTER=&amp;quot;--master=http://sz-pg-oam-docker-test-001.tendcloud.com:8080&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加&lt;code&gt;apiserver&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
## kubernetes system config
##
## The following values are used to configure the kube-apiserver
##
#
## The address on the local server to listen to.
KUBE_API_ADDRESS=&amp;quot;--address=sz-pg-oam-docker-test-001.tendcloud.com&amp;quot;
#
## The port on the local server to listen on.
KUBE_API_PORT=&amp;quot;--port=8080&amp;quot;
#
## Port minions listen on
KUBELET_PORT=&amp;quot;--kubelet-port=10250&amp;quot;
#
## Comma separated list of nodes in the etcd cluster
KUBE_ETCD_SERVERS=&amp;quot;--etcd-servers=http://127.0.0.1:2379&amp;quot;
#
## Address range to use for services
KUBE_SERVICE_ADDREKUBELET_POD_INFRA_CONTAINERSSES=&amp;quot;--service-cluster-ip-range=10.254.0.0/16&amp;quot;
#
## default admission control policies
KUBE_ADMISSION_CONTROL=&amp;quot;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ResourceQuota&amp;quot;
#
## Add your own!
#KUBE_API_ARGS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置kube-controller-manager&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编写&lt;code&gt;/usr/lib/systemd/system/kube-controller.service&lt;/code&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Ini&#34;&gt;Description=Kubernetes Controller Manager
Documentation=https://github.com/GoogleCloudPlatform/kubernetes

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/controller-manager
ExecStart=/usr/bin/kube-controller-manager \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_MASTER \
	    $KUBE_CONTROLLER_MANAGER_ARGS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;/etc/kubernetes&lt;/code&gt;目录下添加&lt;code&gt;controller-manager&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
# The following values are used to configure the kubernetes controller-manager

# defaults from config and apiserver should be adequate

# Add your own!
KUBE_CONTROLLER_MANAGER_ARGS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置kube-scheduler&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编写&lt;code&gt;/usr/lib/systemd/system/kube-scheduler.service&lt;/code&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes Scheduler Plugin
Documentation=https://github.com/GoogleCloudPlatform/kubernetes

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/scheduler
ExecStart=/usr/bin/kube-scheduler \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_MASTER \
	    $KUBE_SCHEDULER_ARGS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;/etc/kubernetes&lt;/code&gt;目录下添加&lt;code&gt;scheduler&lt;/code&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
# kubernetes scheduler config

# default config should be adequate

# Add your own!
KUBE_SCHEDULER_ARGS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置kube-proxy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编写&lt;code&gt;/usr/lib/systemd/system/kube-proxy.service&lt;/code&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes Kube-Proxy Server
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=network.target

[Service]
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/proxy
ExecStart=/usr/bin/kube-proxy \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBE_MASTER \
	    $KUBE_PROXY_ARGS
Restart=on-failure
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;/etc/kubernetes&lt;/code&gt;目录下添加&lt;code&gt;proxy&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
# kubernetes proxy config

# default config should be adequate

# Add your own!
KUBE_PROXY_ARGS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置kubelet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编写&lt;code&gt;/usr/lib/systemd/system/kubelet.service&lt;/code&gt;文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Kubernetes Kubelet Server
Documentation=https://github.com/GoogleCloudPlatform/kubernetes
After=docker.service
Requires=docker.service

[Service]
WorkingDirectory=/var/lib/kubelet
EnvironmentFile=-/etc/kubernetes/config
EnvironmentFile=-/etc/kubernetes/kubelet
ExecStart=/usr/bin/kubelet \
	    $KUBE_LOGTOSTDERR \
	    $KUBE_LOG_LEVEL \
	    $KUBELET_API_SERVER \
	    $KUBELET_ADDRESS \
	    $KUBELET_PORT \
	    $KUBELET_HOSTNAME \
	    $KUBE_ALLOW_PRIV \
	    $KUBELET_POD_INFRA_CONTAINER \
	    $KUBELET_ARGS
Restart=on-failure

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;/etc/kubernetes&lt;/code&gt;目录下添加&lt;code&gt;kubelet&lt;/code&gt;配置文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;###
## kubernetes kubelet (minion) config
#
## The address for the info server to serve on (set to 0.0.0.0 or &amp;quot;&amp;quot; for all interfaces)
KUBELET_ADDRESS=&amp;quot;--address=0.0.0.0&amp;quot;
#
## The port for the info server to serve on
KUBELET_PORT=&amp;quot;--port=10250&amp;quot;
#
## You may leave this blank to use the actual hostname
KUBELET_HOSTNAME=&amp;quot;--hostname-override=sz-pg-oam-docker-test-001.tendcloud.com&amp;quot;
#
## location of the api-server
KUBELET_API_SERVER=&amp;quot;--api-servers=http://sz-pg-oam-docker-test-001.tendcloud.com:8080&amp;quot;
#
## pod infrastructure container
KUBELET_POD_INFRA_CONTAINER=&amp;quot;--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest&amp;quot;
#
## Add your own!
KUBELET_ARGS=&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⚠️&lt;code&gt;KUBELET_POD_INFRA_CONTAINER&lt;/code&gt;在生产环境中配置成自己私有仓库里的image。&lt;/p&gt;

&lt;h4 id=&#34;node节点配置&#34;&gt;Node节点配置&lt;/h4&gt;

&lt;p&gt;Node节点需要配置：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;kube-proxy&lt;/li&gt;
&lt;li&gt;kubectl&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;kube-proxy&lt;/code&gt;的配置与master节点的kube-proxy配置相同。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kubectl&lt;/code&gt;的配置需要修改&lt;code&gt;KUBELET_HOST&lt;/code&gt;为本机的hostname，其它配置相同。&lt;/p&gt;

&lt;h1 id=&#34;启动&#34;&gt;启动&lt;/h1&gt;

&lt;p&gt;在&lt;strong&gt;Master&lt;/strong&gt;节点上执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;for SERVICES in etcd kube-apiserver kube-controller-manager kube-scheduler kube-proxy kubelet flanneld; do
    systemctl restart $SERVICES
    systemctl enable $SERVICES
    systemctl status $SERVICES
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在另外两台Node节点上执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;for SERVICES in kube-proxy kubelet flanneld; do
    systemctl restart $SERVICES
    systemctl enable $SERVICES
    systemctl status $SERVICES
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;验证&#34;&gt;验证&lt;/h1&gt;

&lt;p&gt;在Master节点上运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$kubectl get all
NAME             CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
svc/kubernetes   10.254.0.1   &amp;lt;none&amp;gt;        443/TCP   1h
$kubectl get nodes
NAME                                      STATUS    AGE       VERSION
sz-pg-oam-docker-test-001.tendcloud.com   Ready     7m        v1.6.0
sz-pg-oam-docker-test-002.tendcloud.com   Ready     4m        v1.6.0
sz-pg-oam-docker-test-003.tendcloud.com   Ready     10s       v1.6.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以正常使用啦。&lt;/p&gt;

&lt;h3 id=&#34;后记&#34;&gt;后记&lt;/h3&gt;

&lt;p&gt;另外Kuberntes还提供第三中安装方式，请看Tony Bai写的&lt;a href=&#34;http://tonybai.com/2017/01/24/explore-kubernetes-cluster-installed-by-kubeadm/&#34;&gt;使用Kubeadm方式安装Kubernetes集群的探索&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;时隔一年重新捡起kubernetes，正好现在KubeCon正在德国柏林举行，IDC 发布的报告显示，2017年大数据全球市场规模将达324亿美元，年复合增长率为27%，其中市场增长最快的领域是数据存储领域（53.4%）&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go语言中的并发编程总结</title>
      <link>http://rootsongjc.github.io/projects/golang-concurrency-summary/</link>
      <pubDate>Fri, 24 Mar 2017 08:36:29 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/projects/golang-concurrency-summary/</guid>
      <description>

&lt;h1 id=&#34;go语言并发编程总结&#34;&gt;Go语言并发编程总结&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Golang :不要通过共享内存来通信，而应该通过通信来共享内存。这句风靡在Go社区的话,说的就是 goroutine中的 channel。他在go并发编程中充当着类型安全的管道作用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;1-通过golang中的-goroutine-与sync-mutex进行并发同步&#34;&gt;1、通过golang中的 goroutine 与sync.Mutex进行并发同步&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import( 

    &amp;quot;fmt&amp;quot;

    &amp;quot;sync&amp;quot;

    &amp;quot;runtime&amp;quot;

)

var count int =0;

func counter(lock * sync.Mutex){

      lock.Lock()

      count++

      fmt.Println(count)

      lock.Unlock()

}

func main(){

   lock:=&amp;amp;sync.Mutex{}

   for i:=0;i&amp;lt;10;i++{

      //传递指针是为了防止 函数内的锁和 调用锁不一致

      go counter(lock)  

     }

   for{

      lock.Lock()

      c:=count

      lock.Unlock()

      ///把时间片给别的goroutine  未来某个时刻运行该routine

      runtime.Gosched()

      if c&amp;gt;=10{

        fmt.Println(&amp;quot;goroutine end&amp;quot;)

        break

        }

   }    

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-goroutine之间通过-channel进行通信&#34;&gt;2、goroutine之间通过 channel进行通信&lt;/h2&gt;

&lt;p&gt;channel是和类型相关的 可以理解为  是一种类型安全的管道。&lt;/p&gt;

&lt;p&gt;简单的channel 使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
package main  

import &amp;quot;fmt&amp;quot;

func Count(ch chan int) {

    ch &amp;lt;- 1  

    fmt.Println(&amp;quot;Counting&amp;quot;)

}

func main() {

    chs := make([]chan int, 10)

for i := 0; i &amp;lt; 10; i++ {

        chs[i] = make(chan int)

  go Count(chs[i])

  fmt.Println(&amp;quot;Count&amp;quot;,i)

    }

for i, ch := range chs {

  &amp;lt;-ch

  fmt.Println(&amp;quot;Counting&amp;quot;,i)

    }  

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-go语言中的select是语言级内置-非堵塞&#34;&gt;3、Go语言中的select是语言级内置  非堵塞&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;select {

case &amp;lt;-chan1: // 如果chan1成功读到数据，则进行该case处理语句  

case chan2 &amp;lt;- 1: // 如果成功向chan2写入数据，则进行该case处理语句  

default: // 如果上面都没有成功，则进入default处理流程  

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，select不像switch，后面并不带判断条件，而是直接去查看case语句。每个&lt;/p&gt;

&lt;p&gt;case语句都必须是一个面向channel的操作。比如上面的例子中，第一个case试图从chan1读取&lt;/p&gt;

&lt;p&gt;一个数据并直接忽略读到的数据，而第二个case则是试图向chan2中写入一个整型数1，如果这&lt;/p&gt;

&lt;p&gt;两者都没有成功，则到达default语句。&lt;/p&gt;

&lt;h2 id=&#34;4-channel-的带缓冲读取写入&#34;&gt;4、channel 的带缓冲读取写入&lt;/h2&gt;

&lt;p&gt;之前我们示范创建的都是不带缓冲的channel，这种做法对于传递单个数据的场景可以接受，&lt;/p&gt;

&lt;p&gt;但对于需要持续传输大量数据的场景就有些不合适了。接下来我们介绍如何给channel带上缓冲，&lt;/p&gt;

&lt;p&gt;从而达到消息队列的效果。&lt;/p&gt;

&lt;p&gt;要创建一个带缓冲的channel，其实也非常容易：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;c := make(chan int, 1024)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在调用make()时将缓冲区大小作为第二个参数传入即可，比如上面这个例子就创建了一个大小&lt;/p&gt;

&lt;p&gt;为1024的int类型channel，即使没有读取方，写入方也可以一直往channel里写入，在缓冲区被&lt;/p&gt;

&lt;p&gt;填完之前都不会阻塞。&lt;/p&gt;

&lt;p&gt;从带缓冲的channel中读取数据可以使用与常规非缓冲channel完全一致的方法，但我们也可&lt;/p&gt;

&lt;p&gt;以使用range关键来实现更为简便的循环读取：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i := range c {

    fmt.Println(&amp;quot;Received:&amp;quot;, i)

} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-用goroutine模拟生产消费者&#34;&gt;5、用goroutine模拟生产消费者&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

import &amp;quot;time&amp;quot;

func Producer (queue chan&amp;lt;- int){

        for i:= 0; i &amp;lt; 10; i++ {

                queue &amp;lt;- i  

                }

}

func Consumer( queue &amp;lt;-chan int){

        for i :=0; i &amp;lt; 10; i++{

                v := &amp;lt;- queue

                fmt.Println(&amp;quot;receive:&amp;quot;, v)

        }

}

func main(){

        queue := make(chan int, 1)

        go Producer(queue)

        go Consumer(queue)

        time.Sleep(1e9) //让Producer与Consumer完成

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-通过make-创建通道&#34;&gt;6、 通过make 创建通道&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;make(c1 chan int)   创建的是 同步channel ...读写完全对应

make(c1 chan int ,10) 闯进带缓冲的通道 上来可以写10次
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;7-随机向通道中写入0或者1&#34;&gt;7、随机向通道中写入0或者1&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

import &amp;quot;time&amp;quot;

func main(){

       ch := make(chan int, 1)

 for {

   ///不停向channel中写入 0 或者1

  select {

   case ch &amp;lt;- 0:

   case ch &amp;lt;- 1:

  }

    //从通道中取出数据

    i := &amp;lt;-ch

    fmt.Println(&amp;quot;Value received:&amp;quot;,i)

    time.Sleep(1e8)

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;8-带缓冲的channel&#34;&gt;8、带缓冲的channel&lt;/h2&gt;

&lt;p&gt;之前创建的都是不带缓冲的channel，这种做法对于传递单个数据的场景可以接受，&lt;/p&gt;

&lt;p&gt;但对于需要持续传输大量数据的场景就有些不合适了。接下来我们介绍如何给channel带上缓冲，&lt;/p&gt;

&lt;p&gt;从而达到消息队列的效果。&lt;/p&gt;

&lt;p&gt;要创建一个带缓冲的channel，其实也非常容易：&lt;/p&gt;

&lt;p&gt;c := make(chan int, 1024)&lt;/p&gt;

&lt;p&gt;在调用make()时将缓冲区大小作为第二个参数传入即可，比如上面这个例子就创建了一个大小&lt;/p&gt;

&lt;p&gt;为1024的int类型channel，即使没有读取方，写入方也可以一直往channel里写入，在缓冲区被&lt;/p&gt;

&lt;p&gt;填完之前都不会阻塞。&lt;/p&gt;

&lt;p&gt;从带缓冲的channel中读取数据可以使用与常规非缓冲channel完全一致的方法，但我们也可&lt;/p&gt;

&lt;p&gt;以使用range关键来实现更为简便的循环读取：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i := range c {

    fmt.Println(&amp;quot;Received:&amp;quot;, i)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;下面是测试代码&lt;/strong&gt;&amp;lsquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

import &amp;quot;time&amp;quot;

func A(c chan int){

 for i:=0;i&amp;lt;10;i++{

        c&amp;lt;- i

    }

}

func B(c chan int){

 for val:=range c {

      fmt.Println(&amp;quot;Value:&amp;quot;,val)  

    }

}

func main(){

    chs:=make(chan int,10)

    //只要有通道操作一定要放到goroutine中否则 会堵塞当前的主线程 并且导致程序退出

    //对于同步通道 或者带缓冲的通道 一定要封装成函数 使用 goroutine 包装

    go A(chs)

    go B(chs)

    time.Sleep(1e9)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;9-关于创建多个goroutine具体到go语言会创建多少个线程&#34;&gt;9、关于创建多个goroutine具体到go语言会创建多少个线程&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;os&amp;quot;

func main() {

    for i:=0; i&amp;lt;20; i++ {

        go func() {

            for {

                b:=make([]byte, 10)

                os.Stdin.Read(b) // will block

            }

        }()

    }

    select{}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会产生21个线程：&lt;/p&gt;

&lt;p&gt;runtime scheduler(src/pkg/runtime/proc.c)会维护一个线程池，当某个goroutine被block后，scheduler会创建一个新线程给其他ready的goroutine&lt;/p&gt;

&lt;p&gt;GOMAXPROCS控制的是未被阻塞的所有goroutine被multiplex到多少个线程上运行&lt;/p&gt;

&lt;h2 id=&#34;10-在channel中也是可以传递channel的-go语言的channel和map-slice等一样都是原生类型&#34;&gt;10、在channel中也是可以传递channel的,Go语言的channel和map、slice等一样都是原生类型&lt;/h2&gt;

&lt;p&gt;需要注意的是，在Go语言中channel本身也是一个原生类型，与map之类的类型地位一样，因&lt;/p&gt;

&lt;p&gt;此channel本身在定义后也可以通过channel来传递。&lt;/p&gt;

&lt;p&gt;我们可以使用这个特性来实现*nix上非常常见的管道（pipe）特性。管道也是使用非常广泛&lt;/p&gt;

&lt;p&gt;的一种设计模式，比如在处理数据时，我们可以采用管道设计，这样可以比较容易以插件的方式&lt;/p&gt;

&lt;p&gt;增加数据的处理流程。&lt;/p&gt;

&lt;p&gt;下面我们利用channel可被传递的特性来实现我们的管道。 为了简化表达， 我们假设在管道中&lt;/p&gt;

&lt;p&gt;传递的数据只是一个整型数，在实际的应用场景中这通常会是一个数据块。&lt;/p&gt;

&lt;p&gt;首先限定基本的数据结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type PipeData struct {

    value int

    handler func(int) int

    next chan int

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后我们写一个常规的处理函数。我们只要定义一系列PipeData的数据结构并一起传递给&lt;/p&gt;

&lt;p&gt;这个函数，就可以达到流式处理数据的目的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func handle(queue chan *PipeData) {

for data := range queue {

        data.next &amp;lt;- data.handler(data.value)

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;11-我们默认创建的是双向通道-单向通道没有意义-但是我们却可以通过强制转换-将双向通道-转换成为单向通道&#34;&gt;11、我们默认创建的是双向通道,单向通道没有意义,但是我们却可以通过强制转换 将双向通道 转换成为单向通道 。&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var ch1 chan int  // ch1是一个正常的channel，不是单向的  

var ch2 chan&amp;lt;- float64// ch2是单向channel，只用于写float64数据

var ch3 &amp;lt;-chan int // ch3是单向channel，只用于读取int数据 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;channel是一个原生类型，因此不仅 支持被传递，还支持类型转换。只有在介绍了单向channel的概念后，读者才会明白类型转换对于&lt;/p&gt;

&lt;p&gt;channel的意义：就是在单向channel和双向channel之间进行转换。&lt;/p&gt;

&lt;p&gt;示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch4 := make(chan int)

ch5 := &amp;lt;-chan int(ch4) // ch5就是一个单向的读取channel

ch6 := chan&amp;lt;- int(ch4) // ch6 是一个单向的写入channel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基于ch4，我们通过类型转换初始化了两个单向channel：单向读的ch5和单向写的ch6。&lt;/p&gt;

&lt;p&gt;从设计的角度考虑，所有的代码应该都遵循“最小权限原则” ，&lt;/p&gt;

&lt;p&gt;从而避免没必要地使用泛滥问题， 进而导致程序失控。 写过C++程序的读者肯定就会联想起const 指针的用法。非const指针具备const指针的所有功能，将一个指针设定为const就是明确告诉&lt;/p&gt;

&lt;p&gt;函数实现者不要试图对该指针进行修改。单向channel也是起到这样的一种契约作用。&lt;/p&gt;

&lt;p&gt;下面我们来看一下单向channel的用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Parse(ch &amp;lt;-chan int) {

for value := range ch {

        fmt.Println(&amp;quot;Parsing value&amp;quot;, value)  

    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除非这个函数的实现者无耻地使用了类型转换，否则这个函数就不会因为各种原因而对ch 进行写，避免在ch中出现非期望的数据，从而很好地实践最小权限原则。&lt;/p&gt;

&lt;h2 id=&#34;12-只读只写单向-channel-代码例子-遵循权限最小化的原则&#34;&gt;12、只读只写单向 channel 代码例子，遵循权限最小化的原则&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

import &amp;quot;time&amp;quot;

//接受一个参数 是只允许读取通道  除非直接强制转换 要么你只能从channel中读取数据

func sCh(ch &amp;lt;-chan int){

   for val:= range ch {

     fmt.Println(val)

   }

}

func main(){

    //创建一个带100缓冲的通道 可以直接写入 而不会导致 主线程堵塞

    dch:=make(chan int,100)

    for i:=0;i&amp;lt;100;i++{

      dch&amp;lt;- i  

    }

    //传递进去 只读通道

    go sCh(dch)

    time.Sleep(1e9)

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;13-channel的关闭-以及判断channel的关闭&#34;&gt;13、channel的关闭,以及判断channel的关闭&lt;/h2&gt;

&lt;p&gt;关闭channel非常简单，直接使用Go语言内置的close()函数即可：&lt;/p&gt;

&lt;p&gt;close(ch)&lt;/p&gt;

&lt;p&gt;在介绍了如何关闭channel之后，我们就多了一个问题：如何判断一个channel是否已经被关&lt;/p&gt;

&lt;p&gt;闭？我们可以在读取的时候使用多重返回值的方式：&lt;/p&gt;

&lt;p&gt;x, ok := &amp;lt;-ch&lt;/p&gt;

&lt;p&gt;这个用法与map中的按键获取value的过程比较类似，只需要看第二个bool返回值即可，如&lt;/p&gt;

&lt;p&gt;果返回值是false则表示ch已经被关闭。&lt;/p&gt;

&lt;h2 id=&#34;14-go的多核并行化编程&#34;&gt;14、Go的多核并行化编程&lt;/h2&gt;

&lt;p&gt;高性能并发编程 必须设置GOMAXPROCS 为最大核数目,这个值由runtime.NumCPU()获取&lt;/p&gt;

&lt;p&gt;在执行一些昂贵的计算任务时， 我们希望能够尽量利用现代服务器普遍具备的多核特性来尽&lt;/p&gt;

&lt;p&gt;量将任务并行化，从而达到降低总计算时间的目的。此时我们需要了解CPU核心的数量，并针对&lt;/p&gt;

&lt;p&gt;性地分解计算任务到多个goroutine中去并行运行。&lt;/p&gt;

&lt;p&gt;下面我们来模拟一个完全可以并行的计算任务：计算N个整型数的总和。我们可以将所有整&lt;/p&gt;

&lt;p&gt;型数分成M份，M即CPU的个数。让每个CPU开始计算分给它的那份计算任务，最后将每个CPU&lt;/p&gt;

&lt;p&gt;的计算结果再做一次累加，这样就可以得到所有N个整型数的总和：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Vector []float64

// 分配给每个CPU的计算任务

func (v Vector) DoSome(i, n int, u Vector, c chan int) {

for ; i &amp;lt; n; i++ {

         v[i] += u.Op(v[i])

     }

     c &amp;lt;- 1       

// 发信号告诉任务管理者我已经计算完成了

}

const NCPU = 16     

// 假设总共有16核   

func (v Vector) DoAll(u Vector) {   

    c := make(chan int, NCPU)  // 用于接收每个CPU的任务完成信号   

for i := 0; i &amp;lt; NCPU; i++ {   

go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)

    } 

// 等待所有CPU的任务完成

for i := 0; i &amp;lt; NCPU; i++ {   

&amp;lt;-c    // 获取到一个数据，表示一个CPU计算完成了

    }

// 到这里表示所有计算已经结束

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个函数看起来设计非常合理。DoAll()会根据CPU核心的数目对任务进行分割，然后开&lt;/p&gt;

&lt;p&gt;辟多个goroutine来并行执行这些计算任务。&lt;/p&gt;

&lt;p&gt;是否可以将总的计算时间降到接近原来的1/N呢？答案是不一定。如果掐秒表（正常点的话，&lt;/p&gt;

&lt;p&gt;应该用7.8节中介绍的Benchmark方法） ，会发现总的执行时间没有明显缩短。再去观察CPU运行&lt;/p&gt;

&lt;p&gt;状态， 你会发现尽管我们有16个CPU核心， 但在计算过程中其实只有一个CPU核心处于繁忙状态，&lt;/p&gt;

&lt;p&gt;这是会让很多Go语言初学者迷惑的问题。&lt;/p&gt;

&lt;p&gt;官方的答案是，这是当前版本的Go编译器还不能很智能地去发现和利用多核的优势。虽然&lt;/p&gt;

&lt;p&gt;我们确实创建了多个goroutine，并且从运行状态看这些goroutine也都在并行运行，但实际上所有&lt;/p&gt;

&lt;p&gt;这些goroutine都运行在同一个CPU核心上， 在一个goroutine得到时间片执行的时候， 其他goroutine&lt;/p&gt;

&lt;p&gt;都会处于等待状态。从这一点可以看出，虽然goroutine简化了我们写并行代码的过程，但实际上&lt;/p&gt;

&lt;p&gt;整体运行效率并不真正高于单线程程序。&lt;/p&gt;

&lt;p&gt;在Go语言升级到默认支持多CPU的某个版本之前，我们可以先通过设置环境变量&lt;/p&gt;

&lt;p&gt;GOMAXPROCS的值来控制使用多少个CPU核心。具体操作方法是通过直接设置环境变量&lt;/p&gt;

&lt;p&gt;GOMAXPROCS的值，或者在代码中启动goroutine之前先调用以下这个语句以设置使用16个CPU&lt;/p&gt;

&lt;p&gt;核心：&lt;/p&gt;

&lt;p&gt;runtime.GOMAXPROCS(16)&lt;/p&gt;

&lt;p&gt;到底应该设置多少个CPU核心呢，其实runtime包中还提供了另外一个函数NumCPU()来获&lt;/p&gt;

&lt;p&gt;取核心数。可以看到，Go语言其实已经感知到所有的环境信息，下一版本中完全可以利用这些&lt;/p&gt;

&lt;p&gt;信息将goroutine调度到所有CPU核心上，从而最大化地利用服务器的多核计算能力。抛弃&lt;/p&gt;

&lt;p&gt;GOMAXPROCS只是个时间问题。&lt;/p&gt;

&lt;h2 id=&#34;15-主动出让时间片给其他-goroutine-在未来的某一时刻再来执行当前goroutine&#34;&gt;15、主动出让时间片给其他 goroutine 在未来的某一时刻再来执行当前goroutine&lt;/h2&gt;

&lt;p&gt;我们可以在每个goroutine中控制何时主动出让时间片给其他goroutine，这可以使用runtime&lt;/p&gt;

&lt;p&gt;包中的Gosched()函数实现。&lt;/p&gt;

&lt;p&gt;实际上，如果要比较精细地控制goroutine的行为，就必须比较深入地了解Go语言开发包中&lt;/p&gt;

&lt;p&gt;runtime包所提供的具体功能。&lt;/p&gt;

&lt;h2 id=&#34;16-go中的同步&#34;&gt;16、Go中的同步&lt;/h2&gt;

&lt;p&gt;倡导用通信来共享数据，而不是通过共享数据来进行通信，但考虑&lt;/p&gt;

&lt;p&gt;到即使成功地用channel来作为通信手段，还是避免不了多个goroutine之间共享数据的问题，Go&lt;/p&gt;

&lt;p&gt;语言的设计者虽然对channel有极高的期望，但也提供了妥善的资源锁方案。&lt;/p&gt;

&lt;h2 id=&#34;17-go中的同步锁&#34;&gt;17、Go中的同步锁&lt;/h2&gt;

&lt;p&gt;倡导用通信来共享数据，而不是通过共享数据来进行通信，但考虑&lt;/p&gt;

&lt;p&gt;到即使成功地用channel来作为通信手段，还是避免不了多个goroutine之间共享数据的问题，Go&lt;/p&gt;

&lt;p&gt;语言的设计者虽然对channel有极高的期望，但也提供了妥善的资源锁方案。&lt;/p&gt;

&lt;p&gt;对于这两种锁类型， 任何一个Lock()或RLock()均需要保证对应有Unlock()或RUnlock()&lt;/p&gt;

&lt;p&gt;调用与之对应，否则可能导致等待该锁的所有goroutine处于饥饿状态，甚至可能导致死锁。锁的&lt;/p&gt;

&lt;p&gt;典型使用模式如下：&lt;/p&gt;

&lt;p&gt;var l sync.Mutex&lt;/p&gt;

&lt;p&gt;func foo() {&lt;/p&gt;

&lt;p&gt;l.Lock()&lt;/p&gt;

&lt;p&gt;//延迟调用 在函数退出 并且局部资源被释放的时候 调用&lt;/p&gt;

&lt;p&gt;defer l.Unlock()&lt;/p&gt;

&lt;p&gt;//&amp;hellip;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;这里我们再一次见证了Go语言defer关键字带来的优雅&lt;/p&gt;

&lt;h2 id=&#34;18-全局唯一操作-sync-once-do-sync-atomic原子操作子包&#34;&gt;18、全局唯一操作 sync.Once.Do()     sync.atomic原子操作子包&lt;/h2&gt;

&lt;p&gt;对于从全局的角度只需要运行一次的代码，比如全局初始化操作，Go语言提供了一个Once&lt;/p&gt;

&lt;p&gt;类型来保证全局的唯一性操作，具体代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var a string

var once sync.Once  

func setup() {

a = &amp;quot;hello, world&amp;quot;

}  

func doprint() {

once.Do(setup)

print(a)  

}  

func twoprint() {

go doprint()

go doprint()  

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果这段代码没有引入Once， setup()将会被每一个goroutine先调用一次， 这至少对于这个&lt;/p&gt;

&lt;p&gt;例子是多余的。在现实中，我们也经常会遇到这样的情况。Go语言标准库为我们引入了Once类&lt;/p&gt;

&lt;p&gt;型以解决这个问题。once的Do()方法可以保证在全局范围内只调用指定的函数一次（这里指&lt;/p&gt;

&lt;p&gt;setup()函数） ，而且所有其他goroutine在调用到此语句时，将会先被阻塞，直至全局唯一的&lt;/p&gt;

&lt;p&gt;once.Do()调用结束后才继续。&lt;/p&gt;

&lt;p&gt;这个机制比较轻巧地解决了使用其他语言时开发者不得不自行设计和实现这种Once效果的&lt;/p&gt;

&lt;p&gt;难题，也是Go语言为并发性编程做了尽量多考虑的一种体现。&lt;/p&gt;

&lt;p&gt;如果没有once.Do()，我们很可能只能添加一个全局的bool变量，在函数setup()的最后&lt;/p&gt;

&lt;p&gt;一行将该bool变量设置为true。在对setup()的所有调用之前，需要先判断该bool变量是否已&lt;/p&gt;

&lt;p&gt;经被设置为true，如果该值仍然是false，则调用一次setup()，否则应跳过该语句。实现代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var done bool = false

func setup() {

a = &amp;quot;hello, world&amp;quot; 

done = true

}     

func doprint() { 

if !done {

        setup()

    }   

print(a)  

}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码初看起来比较合理， 但是细看还是会有问题， 因为setup()并不是一个原子性操作，&lt;/p&gt;

&lt;p&gt;这种写法可能导致setup()函数被多次调用，从而无法达到全局只执行一次的目标。这个问题的&lt;/p&gt;

&lt;p&gt;复杂性也更加体现了Once类型的价值。&lt;/p&gt;

&lt;p&gt;为了更好地控制并行中的原子性操作，sync包中还包含一个atomic子包，它提供了对于一&lt;/p&gt;

&lt;p&gt;些基础数据类型的原子操作函数，比如下面这个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func CompareAndSwapUint64(val *uint64, old, new uint64) (swapped bool)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就提供了比较和交换两个uint64类型数据的操作。这让开发者无需再为这样的操作专门添加Lock操作。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://lib.csdn.net/article/53/36140?knId=1441&#34;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pivotal Cloud foundry快速开始指南</title>
      <link>http://rootsongjc.github.io/blogs/cloud-foundry-tryout/</link>
      <pubDate>Thu, 23 Mar 2017 22:54:18 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/cloud-foundry-tryout/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2013100302.jpg&#34; alt=&#34;黄山日出&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：黄山日出后的云海 Oct 3,2013）&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近研究了下&lt;strong&gt;Pivotal&lt;/strong&gt;的&lt;strong&gt;Cloud foundry&lt;/strong&gt;，CF本身是一款开源软件，很多PAAS厂商都加入了CF，我们用的是的&lt;strong&gt;PCF Dev&lt;/strong&gt;（PCF Dev是一款可以在工作站上运行的轻量级PCF安装）来试用的，因为它可以部署在自己的环境里，而&lt;strong&gt;Pivotal Web Services&lt;/strong&gt;只免费两个月，之后就要收费。&lt;a href=&#34;https://pivotal.io/cn/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry-dev/introduction&#34;&gt;这里&lt;/a&gt;有官方的详细教程。&lt;/p&gt;

&lt;h2 id=&#34;开始&#34;&gt;开始&lt;/h2&gt;

&lt;p&gt;根据官网的示例，我们将运行一个Java程序示例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装命令行终端&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pivotal.io/cn/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry-dev/install-the-cf-cli&#34;&gt;下载&lt;/a&gt;后双击安装即可，然后执行&lt;code&gt;cf help&lt;/code&gt;能够看到帮助。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装PCF Dev&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先&lt;a href=&#34;https://network.pivotal.io/products/pcfdev&#34;&gt;下载&lt;/a&gt;，如果你没有Pivotal network账号的话，还需要注册个用户，然后用以下命令安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;
$./pcfdev-VERSION-osx &amp;amp;&amp;amp; \
cf dev start
Less than 4096 MB of free memory detected, continue (y/N): &amp;gt; y
Please sign in with your Pivotal Network account.
Need an account? Join Pivotal Network: https://network.pivotal.io

Email&amp;gt; 849122844@qq.com

Password&amp;gt; 
Downloading VM...
Progress: |+++++++++++++=======&amp;gt;| 100% 
VM downloaded.
Allocating 4096 MB out of 16384 MB total system memory (3514 MB free).
Importing VM...
Starting VM...
Provisioning VM...
Waiting for services to start...
8 out of 57 running
8 out of 57 running
8 out of 57 running
46 out of 57 running
57 out of 57 running
 _______  _______  _______    ______   _______  __   __
|       ||       ||       |  |      | |       ||  | |  |
|    _  ||       ||    ___|  |  _    ||    ___||  |_|  |
|   |_| ||       ||   |___   | | |   ||   |___ |       |
|    ___||      _||    ___|  | |_|   ||    ___||       |
|   |    |     |_ |   |      |       ||   |___  |     |
|___|    |_______||___|      |______| |_______|  |___|
is now running.
To begin using PCF Dev, please run:
   cf login -a https://api.local.pcfdev.io --skip-ssl-validation
Apps Manager URL: https://local.pcfdev.io
Admin user =&amp;gt; Email: admin / Password: admin
Regular user =&amp;gt; Email: user / Password: pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动过程中还需要&lt;strong&gt;Sign In&lt;/strong&gt;，所以注册完后要记住用户名（邮箱地址）和密码（必须超过8位要有特殊字符和大写字母）。这个过程中还要下载VM，对内存要求至少4G。而且下载速度比较慢，我下载的了大概3个多小时吧。&lt;/p&gt;

&lt;p&gt;下面部署一个应用到PCF Dev上试一试。&lt;/p&gt;

&lt;h2 id=&#34;部署应用&#34;&gt;部署应用&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;下载代码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$git clone https://github.com/cloudfoundry-samples/spring-music
$cd ./spring-music
$cf login -a api.local.pcfdev.io --skip-ssl-validation
API endpoint: api.local.pcfdev.io

Email&amp;gt; user

Password&amp;gt; pass
Authenticating...
OK

Targeted org pcfdev-org

Targeted space pcfdev-space


                
API endpoint:   https://api.local.pcfdev.io (API version: 2.65.0)
User:           user
Org:            pcfdev-org
Space:          pcfdev-space
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;编译应用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用gradle来编译。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$./gradlew assemble
:compileJava UP-TO-DATE
:processResources UP-TO-DATE
:classes UP-TO-DATE
:findMainClass
:jar
:bootRepackage
Download https://repo1.maven.org/maven2/com/sun/jersey/jersey-client/1.13/jersey-client-1.13.jar
Download https://repo1.maven.org/maven2/com/sun/jersey/jersey-json/1.13/jersey-json-1.13.jar
Download https://repo1.maven.org/maven2/org/apache/httpcomponents/httpcore/4.4.5/httpcore-4.4.5.jar
Download https://repo1.maven.org/maven2/com/nimbusds/oauth2-oidc-sdk/4.5/oauth2-oidc-sdk-4.5.jar
Download https://repo1.maven.org/maven2/com/google/code/gson/gson/2.3.1/gson-2.3.1.jar
Download https://repo1.maven.org/maven2/com/sun/jersey/jersey-core/1.13/jersey-core-1.13.jar
Download https://repo1.maven.org/maven2/org/codehaus/jackson/jackson-core-asl/1.9.2/jackson-core-asl-1.9.2.jar
Download https://repo1.maven.org/maven2/org/codehaus/jackson/jackson-mapper-asl/1.9.2/jackson-mapper-asl-1.9.2.jar
Download https://repo1.maven.org/maven2/org/codehaus/jackson/jackson-jaxrs/1.9.2/jackson-jaxrs-1.9.2.jar
Download https://repo1.maven.org/maven2/org/codehaus/jackson/jackson-xc/1.9.2/jackson-xc-1.9.2.jar
Download https://repo1.maven.org/maven2/net/jcip/jcip-annotations/1.0/jcip-annotations-1.0.jar
Download https://repo1.maven.org/maven2/org/apache/commons/commons-lang3/3.3.1/commons-lang3-3.3.1.jar
Download https://repo1.maven.org/maven2/net/minidev/json-smart/1.1.1/json-smart-1.1.1.jar
Download https://repo1.maven.org/maven2/com/nimbusds/lang-tag/1.4/lang-tag-1.4.jar
Download https://repo1.maven.org/maven2/com/nimbusds/nimbus-jose-jwt/3.1.2/nimbus-jose-jwt-3.1.2.jar
Download https://repo1.maven.org/maven2/stax/stax-api/1.0.1/stax-api-1.0.1.jar
Download https://repo1.maven.org/maven2/org/bouncycastle/bcprov-jdk15on/1.51/bcprov-jdk15on-1.51.jar
Download https://repo1.maven.org/maven2/javax/mail/mail/1.4.7/mail-1.4.7.jar
:assemble

BUILD SUCCESSFUL

Total time: 1 mins 25.649 secs

This build could be faster, please consider using the Gradle Daemon: https://docs.gradle.org/2.14/userguide/gradle_daemon.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;上传应用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置应用的主机名为spring-music。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf push --hostname spring-music
Using manifest file /Users/jimmy/Workspace/github/cloudfoundry-samples/spring-music/manifest.yml

Creating app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

Creating route spring-music.local.pcfdev.io...
OK

Binding spring-music.local.pcfdev.io to spring-music...
OK

Uploading spring-music...
Uploading app files from: /var/folders/61/f7mqkyjn1nz5mfmfvdztgzjw0000gn/T/unzipped-app139680305
Uploading 38.9M, 234 files
Done uploading               
OK

Starting app spring-music in org pcfdev-org / space pcfdev-space as user...
Downloading dotnet-core_buildpack...
Downloading go_buildpack...
Downloading python_buildpack...
Downloading php_buildpack...
Downloading staticfile_buildpack...
Downloaded staticfile_buildpack
Downloading binary_buildpack...
Downloaded binary_buildpack (9.3K)
Downloading java_buildpack...
Downloaded java_buildpack (249.1M)
Downloaded dotnet-core_buildpack (169.3M)
Downloading ruby_buildpack...
Downloading nodejs_buildpack...
Downloaded python_buildpack (255.3M)
Downloaded nodejs_buildpack (109.4M)
Downloaded go_buildpack (392M)
Downloaded php_buildpack (310.4M)
Downloaded ruby_buildpack (260.8M)
Creating container
Successfully created container
Downloading app package...
Downloaded app package (38.8M)
Staging...
-----&amp;gt; Java Buildpack Version: v3.10 (offline) | https://github.com/cloudfoundry/java-buildpack.git#193d6b7
-----&amp;gt; Downloading Open Jdk JRE 1.8.0_111 from https://java-buildpack.cloudfoundry.org/openjdk/trusty/x86_64/openjdk-1.8.0_111.tar.gz (found in cache)
       Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.4s)
-----&amp;gt; Downloading Open JDK Like Memory Calculator 2.0.2_RELEASE from https://java-buildpack.cloudfoundry.org/memory-calculator/trusty/x86_64/memory-calculator-2.0.2_RELEASE.tar.gz (found in cache)
       Memory Settings: -Xss349K -Xmx681574K -XX:MaxMetaspaceSize=104857K -Xms681574K -XX:MetaspaceSize=104857K
-----&amp;gt; Downloading Spring Auto Reconfiguration 1.10.0_RELEASE from https://java-buildpack.cloudfoundry.org/auto-reconfiguration/auto-reconfiguration-1.10.0_RELEASE.jar (found in cache)
Exit status 0
Staging complete
Uploading droplet, build artifacts cache...
Uploading build artifacts cache...
Uploading droplet...
Uploaded build artifacts cache (108B)
Uploaded droplet (83.9M)
Uploading complete
Destroying container
Successfully destroyed container

0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
1 of 1 instances running

App started


OK

App spring-music was started using this command `CALCULATED_MEMORY=$($PWD/.java-buildpack/open_jdk_jre/bin/java-buildpack-memory-calculator-2.0.2_RELEASE -memorySizes=metaspace:64m..,stack:228k.. -memoryWeights=heap:65,metaspace:10,native:15,stack:10 -memoryInitials=heap:100%,metaspace:100% -stackThreads=300 -totMemory=$MEMORY_LIMIT) &amp;amp;&amp;amp; JAVA_OPTS=&amp;quot;-Djava.io.tmpdir=$TMPDIR -XX:OnOutOfMemoryError=$PWD/.java-buildpack/open_jdk_jre/bin/killjava.sh $CALCULATED_MEMORY&amp;quot; &amp;amp;&amp;amp; SERVER_PORT=$PORT eval exec $PWD/.java-buildpack/open_jdk_jre/bin/java $JAVA_OPTS -cp $PWD/. org.springframework.boot.loader.JarLauncher`

Showing health and status for app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

requested state: started
instances: 1/1
usage: 1G x 1 instances
urls: spring-music.local.pcfdev.io
last uploaded: Thu Mar 23 14:29:46 UTC 2017
stack: cflinuxfs2
buildpack: java-buildpack=v3.10-offline-https://github.com/cloudfoundry/java-buildpack.git#193d6b7 java-main open-jdk-like-jre=1.8.0_111 open-jdk-like-memory-calculator=2.0.2_RELEASE spring-auto-reconfiguration=1.10.0_RELEASE

     state     since                    cpu      memory       disk             details
#0   running   2017-03-23 10:31:36 PM   160.7%   442M of 1G   165.6M of 512M
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;在浏览器中访问app&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;spring-music.local.pcfdev.io&#34;&gt;spring-music.local.pcfdev.io&lt;/a&gt;页面如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/pivotal-cloudfoundry-spring-music.jpg&#34; alt=&#34;spring-music&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;requested state: started
instances: 1/1
usage: 512M x 1 instances
urls: spring-music.local.pcfdev.io
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;查看日志&#34;&gt;查看日志&lt;/h2&gt;

&lt;p&gt;PCF提供应用的日志聚合功能，你可以查看HTTP请求、对应用操作时候的output，如扩容、重启等。&lt;/p&gt;

&lt;p&gt;每行日志中都包括如下信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Timestamp&lt;/li&gt;
&lt;li&gt;Log type&lt;/li&gt;
&lt;li&gt;Channel&lt;/li&gt;
&lt;li&gt;Message&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查看刚才那个应用的日志信息：&lt;/p&gt;

&lt;p&gt;查看最近输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf logs spring-music --recent
2017-03-23T22:34:05.17+0800 [RTR/0]      OUT spring-music.local.pcfdev.io - [23/03/2017:14:34:05.163 +0000] &amp;quot;GET /templates/albumForm.html HTTP/1.1&amp;quot; 200 0 2518 &amp;quot;http://spring-music.local.pcfdev.io/&amp;quot; &amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36&amp;quot; 192.168.11.1:52097 10.0.2.15:60012 x_forwarded_for:&amp;quot;-&amp;quot; x_forwarded_proto:&amp;quot;http&amp;quot; vcap_request_id:c6b5f34d-bc5a-4c66-77aa-cb768b273f21 response_time:0.007390127 app_id:fdc7a43e-61b8-40e9-b1dc-38b858037da9 app_index:0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看实时输出流：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf logs spring-music
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;连接数据库&#34;&gt;连接数据库&lt;/h2&gt;

&lt;p&gt;在上面的那个例子中用的是内存数据库。我们可以改用mysql数据库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看可用的数据&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf marketplace -s p-mysql
Getting service plan information for service p-mysql as user...
OK

service plan   description            free or paid
512mb          PCF Dev MySQL Server   free
1gb            PCF Dev MySQL Server   free
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;创建数据库&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf create-service p-mysql 512mb my-spring-db
Creating service instance my-spring-db in org pcfdev-org / space pcfdev-space as user...
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将它与我们上面的示例应用程序绑定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf bind-service spring-music my-spring-db
Binding service my-spring-db to app spring-music in org pcfdev-org / space pcfdev-space as user...
OK
TIP: Use &#39;cf restage spring-music&#39; to ensure your env variable changes take effect
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启app&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf restart spring-music
Stopping app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

Starting app spring-music in org pcfdev-org / space pcfdev-space as user...

0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
1 of 1 instances running

App started


OK

App spring-music was started using this command `CALCULATED_MEMORY=$($PWD/.java-buildpack/open_jdk_jre/bin/java-buildpack-memory-calculator-2.0.2_RELEASE -memorySizes=metaspace:64m..,stack:228k.. -memoryWeights=heap:65,metaspace:10,native:15,stack:10 -memoryInitials=heap:100%,metaspace:100% -stackThreads=300 -totMemory=$MEMORY_LIMIT) &amp;amp;&amp;amp; JAVA_OPTS=&amp;quot;-Djava.io.tmpdir=$TMPDIR -XX:OnOutOfMemoryError=$PWD/.java-buildpack/open_jdk_jre/bin/killjava.sh $CALCULATED_MEMORY&amp;quot; &amp;amp;&amp;amp; SERVER_PORT=$PORT eval exec $PWD/.java-buildpack/open_jdk_jre/bin/java $JAVA_OPTS -cp $PWD/. org.springframework.boot.loader.JarLauncher`

Showing health and status for app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

requested state: started
instances: 1/1
usage: 1G x 1 instances
urls: spring-music.local.pcfdev.io
last uploaded: Thu Mar 23 14:29:46 UTC 2017
stack: cflinuxfs2
buildpack: java-buildpack=v3.10-offline-https://github.com/cloudfoundry/java-buildpack.git#193d6b7 java-main open-jdk-like-jre=1.8.0_111 open-jdk-like-memory-calculator=2.0.2_RELEASE spring-auto-reconfiguration=1.10.0_RELEASE

     state     since                    cpu      memory         disk             details
#0   running   2017-03-23 10:44:18 PM   150.4%   461.6M of 1G   165.6M of 512M
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们再查看下自己的service。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf services
Getting services in org pcfdev-org / space pcfdev-space as user...
OK

name           service   plan    bound apps     last operation
my-spring-db   p-mysql   512mb   spring-music   create succeeded
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;应用扩容&#34;&gt;应用扩容&lt;/h2&gt;

&lt;p&gt;扩展应用的示例数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf scale spring-music -i 2
Scaling app spring-music in org pcfdev-org / space pcfdev-space as user...
OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再查看下&lt;code&gt;spring-music&lt;/code&gt;应用的信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf app spring-music
Showing health and status for app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

requested state: started
instances: 2/2
usage: 1G x 2 instances
urls: spring-music.local.pcfdev.io
last uploaded: Thu Mar 23 14:29:46 UTC 2017
stack: cflinuxfs2
buildpack: java-buildpack=v3.10-offline-https://github.com/cloudfoundry/java-buildpack.git#193d6b7 java-main open-jdk-like-jre=1.8.0_111 open-jdk-like-memory-calculator=2.0.2_RELEASE spring-auto-reconfiguration=1.10.0_RELEASE

     state      since                    cpu    memory         disk             details
#0   running    2017-03-23 10:44:18 PM   0.5%   451.4M of 1G   165.6M of 512M
#1   starting   2017-03-23 10:46:19 PM   0.0%   348.3M of 1G   165.6M of 512M

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以对内存进行扩容。这个操作会重启应用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf scale spring-music -m 1G
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
1 of 2 instances running, 1 down

App started


OK

App spring-music was started using this command `CALCULATED_MEMORY=$($PWD/.java-buildpack/open_jdk_jre/bin/java-buildpack-memory-calculator-2.0.2_RELEASE -memorySizes=metaspace:64m..,stack:228k.. -memoryWeights=heap:65,metaspace:10,native:15,stack:10 -memoryInitials=heap:100%,metaspace:100% -stackThreads=300 -totMemory=$MEMORY_LIMIT) &amp;amp;&amp;amp; JAVA_OPTS=&amp;quot;-Djava.io.tmpdir=$TMPDIR -XX:OnOutOfMemoryError=$PWD/.java-buildpack/open_jdk_jre/bin/killjava.sh $CALCULATED_MEMORY&amp;quot; &amp;amp;&amp;amp; SERVER_PORT=$PORT eval exec $PWD/.java-buildpack/open_jdk_jre/bin/java $JAVA_OPTS -cp $PWD/. org.springframework.boot.loader.JarLauncher`

Showing health and status for app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

requested state: started
instances: 1/2
usage: 1G x 2 instances
urls: spring-music.local.pcfdev.io
last uploaded: Thu Mar 23 14:29:46 UTC 2017
stack: cflinuxfs2
buildpack: java-buildpack=v3.10-offline-https://github.com/cloudfoundry/java-buildpack.git#193d6b7 java-main open-jdk-like-jre=1.8.0_111 open-jdk-like-memory-calculator=2.0.2_RELEASE spring-auto-reconfiguration=1.10.0_RELEASE

     state     since                    cpu      memory         disk             details
#0   running   2017-03-23 10:48:43 PM   145.1%   412.2M of 1G   165.6M of 512M
#1   down      2017-03-23 10:48:14 PM   0.7%     436.2M of 1G   165.6M of 512M   insufficient resources: memory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以增加应用的磁盘大小。这个操作也会重启应用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$cf scale spring-music -k 512M
This will cause the app to restart. Are you sure you want to scale spring-music?&amp;gt; y

Scaling app spring-music in org pcfdev-org / space pcfdev-space as user...
OK
Stopping app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

Starting app spring-music in org pcfdev-org / space pcfdev-space as user...

0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
0 of 2 instances running, 1 starting, 1 down
1 of 2 instances running, 1 down

App started


OK

App spring-music was started using this command `CALCULATED_MEMORY=$($PWD/.java-buildpack/open_jdk_jre/bin/java-buildpack-memory-calculator-2.0.2_RELEASE -memorySizes=metaspace:64m..,stack:228k.. -memoryWeights=heap:65,metaspace:10,native:15,stack:10 -memoryInitials=heap:100%,metaspace:100% -stackThreads=300 -totMemory=$MEMORY_LIMIT) &amp;amp;&amp;amp; JAVA_OPTS=&amp;quot;-Djava.io.tmpdir=$TMPDIR -XX:OnOutOfMemoryError=$PWD/.java-buildpack/open_jdk_jre/bin/killjava.sh $CALCULATED_MEMORY&amp;quot; &amp;amp;&amp;amp; SERVER_PORT=$PORT eval exec $PWD/.java-buildpack/open_jdk_jre/bin/java $JAVA_OPTS -cp $PWD/. org.springframework.boot.loader.JarLauncher`

Showing health and status for app spring-music in org pcfdev-org / space pcfdev-space as user...
OK

requested state: started
instances: 1/2
usage: 1G x 2 instances
urls: spring-music.local.pcfdev.io
last uploaded: Thu Mar 23 14:29:46 UTC 2017
stack: cflinuxfs2
buildpack: java-buildpack=v3.10-offline-https://github.com/cloudfoundry/java-buildpack.git#193d6b7 java-main open-jdk-like-jre=1.8.0_111 open-jdk-like-memory-calculator=2.0.2_RELEASE spring-auto-reconfiguration=1.10.0_RELEASE

     state     since                    cpu      memory         disk             details
#0   running   2017-03-23 10:50:57 PM   130.8%   376.2M of 1G   165.6M of 512M
#1   down      2017-03-23 10:50:32 PM   0.6%     438.5M of 1G   165.6M of 512M   insufficient resources: memory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的操作中可以看到，连续性特别强，所有的操作都可以在几秒钟内完成，特别适合&lt;strong&gt;微服务&lt;/strong&gt;的部署和&lt;strong&gt;Cloud Native&lt;/strong&gt; APP。&lt;/p&gt;

&lt;p&gt;关于&lt;strong&gt;Pivotal Cloud Foundry&lt;/strong&gt;的更多文档可以访问：&lt;a href=&#34;https://pivotal.io/cn/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry-dev/next-steps&#34;&gt;https://pivotal.io/cn/platform/pcf-tutorials/getting-started-with-pivotal-cloud-foundry-dev/next-steps&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TensorFlow实战（才云郑泽宇著）读书笔记——第二章TensorFlow环境搭建</title>
      <link>http://rootsongjc.github.io/blogs/tensorflow-practice-02/</link>
      <pubDate>Thu, 23 Mar 2017 19:34:33 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/tensorflow-practice-02/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20140810002.jpg&#34; alt=&#34;广州海珠桥&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：广州海珠桥 Aug 10,2014）&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这是我阅读&lt;a href=&#34;caicloud.io&#34;&gt;才云科技&lt;/a&gt;郑泽宇的《TensorFlow实战Google深度学习框架》的读书笔记系列文章，按照文章的章节顺序来写的。整本书的笔记归档在&lt;a href=&#34;http://rootsongjc.github.io/tags/tensorflow-practice-reading-notes/&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;P.S 本书的&lt;strong&gt;官方读者交流微信群（作者也在群里）&lt;/strong&gt;已经超过100人，您可以先加我微信后我拉您进去，我的二维码在&lt;a href=&#34;rootsongjc.github.io/about&#34;&gt;这里&lt;/a&gt;，或者直接搜索我的微信号jimmysong。&lt;/p&gt;

&lt;p&gt;睇完这一章后应该就可以自己搭建出一个TensorFlow的环境，我之前在docker里玩过，镜像比较大，下载慢一点，不过用起来很方便，如果你仅仅是想试用一下TensorFlow，看看它能干什么的话，可以直接在docker里试用一下。在Mac上安装的详细步骤，&lt;a href=&#34;https://www.tensorflow.org/install/install_mac&#34;&gt;官方安装说明文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;2-1-tensorflow的主要依赖包&#34;&gt;2.1 TensorFlow的主要依赖包&lt;/h2&gt;

&lt;p&gt;TensorFlow主要用到以下两个依赖：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developers.google.com/protocol-buffers/&#34;&gt;Protocol buffer&lt;/a&gt;：数据结构化工具。Google开源的结构化数据格式，用于网络传输数据时候的序列化和反序列化，使用的时候需要先定义schema，github地址&lt;a href=&#34;https://github.com/google/protobuf。分布式TensorFlow使用到额gRPC也是使用Protocol&#34;&gt;https://github.com/google/protobuf。分布式TensorFlow使用到额gRPC也是使用Protocol&lt;/a&gt; Buffer来组织的，&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://bazel.build/&#34;&gt;Bazel&lt;/a&gt;:自动化编译构建工具。Google开源的，github地址&lt;a href=&#34;https://github.com/bazelbuild/bazel，它支持多语言、多平台、可重复编译和可伸缩，构建大型软件速度也是很快的。Bazel使用**项目空间**的形式管理编译的，每个项目空间需要包含[BUILD文件](https://github.com/tensorflow/tensorflow/blob/master/bower.BUILD)（定义编译目标）和[WORKSPACE](https://github.com/tensorflow/tensorflow/blob/master/WORKSPACE)文件（定义编译的依赖环境）。这两个文件都有点类似python语法。&#34;&gt;https://github.com/bazelbuild/bazel，它支持多语言、多平台、可重复编译和可伸缩，构建大型软件速度也是很快的。Bazel使用**项目空间**的形式管理编译的，每个项目空间需要包含[BUILD文件](https://github.com/tensorflow/tensorflow/blob/master/bower.BUILD)（定义编译目标）和[WORKSPACE](https://github.com/tensorflow/tensorflow/blob/master/WORKSPACE)文件（定义编译的依赖环境）。这两个文件都有点类似python语法。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-2-tensorflow安装&#34;&gt;2.2 TensorFlow安装&lt;/h2&gt;

&lt;p&gt;TensorFlow的安装方式包括docker镜像、pip安装、源码编译安装。&lt;/p&gt;

&lt;p&gt;&lt;u&gt;我选择最方便的docker镜像方式&lt;/u&gt;，其他方式对本地环境做很多配置，折腾起来比较麻烦。&lt;/p&gt;

&lt;p&gt;我早就在docker中安装过TensorFlow0.9小试过牛刀。现在&lt;a href=&#34;https://github.com/tensorflow/tensorflow/releases&#34;&gt;1.0.1版本&lt;/a&gt;已经released了。TensorFlow的所有版本都有对应的docker镜像发布在&lt;a href=&#34;https://hub.docker.com/r/tensorflow/tensorflow/tags/&#34;&gt;docker hub&lt;/a&gt;，可以直接&lt;code&gt;docker pull&lt;/code&gt;安装。&lt;/p&gt;

&lt;p&gt;为了和书中所用的镜像保持统一，我将使用caicloud提供的镜像，基于TensorFlow0.12.0（这个版本是2016年12月20日发布的），他们增加了一些其他机器学习工具包和TensorFlow可视化工具TensorBoard。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker镜像方式安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先下载镜像，这个image比较大，下载下来比较费时间，我用了差不多15分钟吧。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker pull cargo.caicloud.io/tensorflow/tensorflow:0.12.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载下来后我们再check下这个大小为&lt;strong&gt;1.41GB&lt;/strong&gt;镜像的layers。&lt;/p&gt;

&lt;p&gt;另外还有个&lt;a href=&#34;https://github.com/NVIDIA/nvidia-docker&#34;&gt;&lt;strong&gt;nvidia&lt;/strong&gt;版本的docker&lt;/a&gt;，可以将你电脑的&lt;strong&gt;GPU&lt;/strong&gt;派山用场，我暂时没用到GPU，我电脑装的是&lt;code&gt;docker17.03-ce&lt;/code&gt;，就不折腾GPU版本的TensorFlow了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
c8a8409297f2        5 weeks ago         /bin/sh -c #(nop)  CMD [&amp;quot;/run_tf.sh&amp;quot;]           0 B                 
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c #(nop) COPY file:78332d36244852...   122 B               
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c #(nop) COPY dir:8b6ab7d235e3975...   21 MB               
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c #(nop) COPY dir:fca915671040399...   360 MB              
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c #(nop) COPY dir:69314aa937be649...   89.9 kB             
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c rm -rf /notebooks/*                  0 B                 
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c pip install caicloud.tensorflow      21.4 MB             
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c pip install -U scikit-learn          39.9 kB             
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c apt-get update &amp;amp;&amp;amp; apt-get insta...   23.9 MB             
&amp;lt;missing&amp;gt;           5 weeks ago         /bin/sh -c #(nop)  ENV LANG=C.UTF-8             0 B                 
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop)  CMD [&amp;quot;/run_jupyter.sh&amp;quot;]      0 B                 
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop)  WORKDIR /notebooks           0 B                 
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop)  EXPOSE 8888/tcp              0 B                 
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop)  EXPOSE 6006/tcp              0 B                 
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop) COPY file:5485384c641ba7...   733 B               
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop) COPY dir:388d24701b3b5bc...   400 kB              
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop) COPY file:822af972b63c44...   1.06 kB             
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c pip --no-cache-dir install http...   191 MB              
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c pip --no-cache-dir install     ...   379 MB              
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c curl -O https://bootstrap.pypa....   11.4 MB             
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c apt-get update &amp;amp;&amp;amp; apt-get insta...   212 MB              
&amp;lt;missing&amp;gt;           3 months ago        /bin/sh -c #(nop)  MAINTAINER Craig Citro ...   0 B                 
&amp;lt;missing&amp;gt;           9 months ago        /bin/sh -c #(nop) CMD [&amp;quot;/bin/bash&amp;quot;]             0 B                 
&amp;lt;missing&amp;gt;           9 months ago        /bin/sh -c sed -i &#39;s/^#\s*\(deb.*universe\...   1.9 kB              
&amp;lt;missing&amp;gt;           9 months ago        /bin/sh -c rm -rf /var/lib/apt/lists/*          0 B                 
&amp;lt;missing&amp;gt;           9 months ago        /bin/sh -c set -xe   &amp;amp;&amp;amp; echo &#39;#!/bin/sh&#39; &amp;gt;...   195 kB              
&amp;lt;missing&amp;gt;           9 months ago        /bin/sh -c #(nop) ADD file:aca501360d0937b...   188 MB 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这是一个基于&lt;strong&gt;Ubuntu&lt;/strong&gt;的docker image，这其中还包含了一个&lt;strong&gt;Jupyter notebook&lt;/strong&gt;和一些python packages。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;docker image history —no-trunc $IMAGE_ID&lt;/code&gt;命令可以看到每一层的详细信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启动TensorFlow&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;直接在docker中启动。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;docker run -it -d -p 8888:8888 -p 6006:6006 --name tf-dev cargo.caicloud.io/tensorflow/tensorflow:0.12.0 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动后进入&lt;code&gt;localhost:8888&lt;/code&gt;页面，发现登陆jupyter居然还要输入密码，书中没说要输入密码啊，也没说密码是什么，密码在哪里呢？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如何获取Jupyter的登录密码书中没有介绍。其实没必要修改镜像活着进入容器中需钙jupyter的配置，直接查看刚启动的&lt;code&gt;tf-dev&lt;/code&gt;容器的日志即可，里面包含了登录密码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;docker logs tf-dev
[I 10:52:46.200 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret
[W 10:52:46.244 NotebookApp] WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended.
[I 10:52:46.267 NotebookApp] Serving notebooks from local directory: /notebooks
[I 10:52:46.267 NotebookApp] 0 active kernels 
[I 10:52:46.267 NotebookApp] The Jupyter Notebook is running at: http://[all ip addresses on your system]:8888/?token=e64afc31eec843717733d6e4527aecf833ce18383214dc47
[I 10:52:46.267 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).
Starting TensorBoard 39 on port 6006
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到了吗，&lt;code&gt;tf-dev&lt;/code&gt;容器的日志输出里就包括了密码，我的容器的jupyter的密码是&lt;strong&gt;token后面的那个字符串&lt;/strong&gt;e64afc31eec843717733d6e4527aecf833ce18383214dc47。&lt;/p&gt;

&lt;p&gt;现在用刚才从日志里看到的密码就可以登录了，Jupyter页面上可以看到本书所有章节的代码了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-practice-chapter2-jupyter-web.jpg&#34; alt=&#34;jupyter页面&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用pip安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外我在mac上也用pip方式安装了。我安装的是最新版的1.0.1的CPU-only，加上&lt;code&gt;—user -U&lt;/code&gt;是为了规避mac上的各种权限问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip install --upgrade tensorflow --user -U
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载的整个软件包只有39.3MB，速度还是很快的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>容器的应用场景</title>
      <link>http://rootsongjc.github.io/talks/container-applications-scenarios/</link>
      <pubDate>Thu, 23 Mar 2017 15:26:11 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/talks/container-applications-scenarios/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/2014080101.jpg&#34; alt=&#34;深圳大梅沙&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：深圳大梅沙 Aug 1,2014）&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你对容器到底有什么用存在疑惑的话，推荐你看下我今天碰到的一篇阿里云的&lt;a href=&#34;https://help.aliyun.com/document_detail/25977.html?spm=5176.2020520152.201.2.Oc3baB&#34;&gt;容器服务-产品简介-应用场景&lt;/a&gt;的文章，觉得比较好，把容器的典型应用场景都概括了，容器对于互联网的弹性扩展和微服务架构有很好的应用场景，P.S这里不是在帮阿里云做广告，这里的推荐搭配确实是很多常用的配置选项。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;devops-持续交付&#34;&gt;DevOps 持续交付&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;最优化的持续交付流程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配合 Jenkins 帮您自动完成从代码提交到应用部署的 DevOps 完整流程，确保只有通过自动测试的代码才能交付和部署，高效替代业内部署复杂、迭代缓慢的传统方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;能够实现：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DevOps 自动化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现从代码变更到代码构建，镜像构建和应用部署的全流程自动化。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;环境一致性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;容器技术让您交付的不仅是代码，还有基于不可变架构的运行环境。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;持续反馈&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每次集成或交付，都会第一时间将结果实时反馈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐搭配使用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;云服务器 ECS + 容器服务&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/25977/cn_zh/1488845113820/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1---%E6%9E%B6%E6%9E%84%E5%9B%BE---DevOps.png&#34; alt=&#34;1&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;基于高性能计算的机器学习&#34;&gt;基于高性能计算的机器学习&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;专注机器学习本身，快速实现从 0 到 1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;帮助数据工程师在 HPC 集群上轻松部署机器学习应用，跟踪试验和训练、发布模型，数据部署在分布式存储，无需关心繁琐部署运维，专注核心业务，快速从 0 到 1。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;能够实现：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;快速弹性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一键部署机器学习应用，秒级启动和弹性伸缩。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简单可控&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一行配置轻松获取 GPU 计算能力，并且可以监控 GPU 的资源。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;深度整合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;无缝接入阿里云存储、日志监控和安全基础架构能力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐搭配使用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;高性能计算 (Alibaba Cloud HPC) + 容器服务 + 阿里云文件存储 NAS + 对象存储 OSS&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/25977/cn_zh/1488845332018/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%20-%20%E6%9E%B6%E6%9E%84%E5%9B%BE%20-%20%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97HPC.png&#34; alt=&#34;2&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;微服务架构&#34;&gt;微服务架构&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;实现敏捷开发和部署落地，加速企业业务迭代&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;企业生产环境中，通过合理微服务拆分，将每个微服务应用存储在阿里云镜像仓库帮您管理。您只需迭代每个微服务应用，由阿里云提供调度、编排、部署和灰度发布能力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;能够实现：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;负载均衡和服务发现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;支持 4 层和 7 层的请求转发和后端绑定。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;丰富的调度和异常恢复策略&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;支持服务级别的亲和性调度，支持跨可用区的高可用和灾难恢复。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;微服务监控和弹性伸缩&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;支持微服务和容器级别的监控，支持微服务的自动伸缩。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐搭配使用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;云服务器 ECS + 云数据库 RDS 版 + 对象存储 OSS + 容器服务&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/25977/cn_zh/1488846287403/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1---%E6%9E%B6%E6%9E%84%E5%9B%BE---%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png&#34; alt=&#34;3&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;混合云架构&#34;&gt;混合云架构&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;统一运维多个云端资源&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在容器服务控制台上同时管理云上云下的资源，不需在多中云管理控制台中反复切换。基于容器基础设施无关的特性，使用同一套镜像和编排同时在云上云下部署应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;能够实现：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在云上伸缩应用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;业务高峰期，在云端快速扩容，把一些业务流量引到云端。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;云上容灾&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;业务系统同时部署到云上和云下，云下提供服务，云上容灾。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;云下开发测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;云下开发测试后的应用无缝发布到云上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐搭配使用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;云服务器 ECS + 专有网络 VPC + 高速通道（ExpressConnect）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/25977/cn_zh/1488846639288/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%20-%20%E6%9E%B6%E6%9E%84%E5%9B%BE%20-%20%E6%B7%B7%E5%90%88%E4%BA%91.png&#34; alt=&#34;4&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;弹性伸缩架构&#34;&gt;弹性伸缩架构&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;根据业务流量自动对业务扩容/缩容&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;容器服务可以根据业务流量自动对业务扩容/缩容，不需要人工干预，避免流量激增扩容不及时导致系统挂掉，以及平时大量闲置资源造成浪费。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;能够实现：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;快速响应&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;业务流量达到扩容指标，秒级触发容器扩容操作。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全自动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整个扩容/缩容过程完全自动化，无需人工干预。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;低成本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;流量降低自动缩容，避免资源浪费。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐搭配使用：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;云服务器 ECS + 云监控&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/25977/cn_zh/1488846792028/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1---%E6%9E%B6%E6%9E%84%E5%9B%BE---%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9.png&#34; alt=&#34;5&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TensorFlow实战（才云郑泽宇著）读书笔记——第一章深度学习简介</title>
      <link>http://rootsongjc.github.io/blogs/tensorflow-practice-01/</link>
      <pubDate>Mon, 20 Mar 2017 22:04:33 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/tensorflow-practice-01/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/tensorflow-book-page.jpg&#34; alt=&#34;tensorflow实战图书封面&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：TensofFlow实战图书封面）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;🙏电子工业出版社编辑赠书，能够这么快的拿到这本书，也🙏&lt;a href=&#34;www.caicloud.io&#34;&gt;才云科技&lt;/a&gt;的郑泽宇大哥耐心的写了这本书，能够让我等小白一窥深度学习的真容。另外要强烈推荐下这本书，这是本TensorFlow深度学习很好的入门书。书中提供的代码&lt;a href=&#34;https://github.com/caicloud/tensorflow-tutorial&#34;&gt;下载地址&lt;/a&gt;，整本书的笔记归档在&lt;a href=&#34;http://rootsongjc.github.io/tags/tensorflow-practice-reading-notes&#34;&gt;这里&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;P.S 本书的&lt;strong&gt;官方读者交流微信群（作者也在群里）&lt;/strong&gt;已经超过100人，您可以先加我微信后我拉您进去，我的二维码在&lt;a href=&#34;rootsongjc.github.io/about&#34;&gt;这里&lt;/a&gt;，或者直接搜索我的微信号jimmysong。&lt;/p&gt;

&lt;h2 id=&#34;1-1-人工智能-机器学习与深度学习&#34;&gt;1.1 人工智能、机器学习与深度学习&lt;/h2&gt;

&lt;p&gt;这一节是讲解三者之间的关系。&lt;/p&gt;

&lt;p&gt;首先以&lt;strong&gt;垃圾邮件分类问题&lt;/strong&gt;引入机器学习的&lt;strong&gt;逻辑回归算法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;逻辑回归算法的准确性取决于训练数据中的特征的提取，以及训练的数据数量。&lt;/p&gt;

&lt;p&gt;文章中又提了一个从实体中提取特征的例子：通过笛卡尔坐标系活极角坐标系来表示不同颜色的点，看看能否用一条直线划分。这个例子用来说明&lt;strong&gt;一旦解决了数据表达和特征提取，很多人工智能的问题就能迎刃而解&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;深度学习是机器学习的一个分支，除了能够学习特征和任务之间的关联之外，还能&lt;strong&gt;自动从简单特征中提取更加复杂的特征&lt;/strong&gt;，这是其区别于机器学习的关键点。&lt;/p&gt;

&lt;p&gt;总的来说，人工智能&amp;gt;机器学习&amp;gt;深度学习。&lt;/p&gt;

&lt;h2 id=&#34;1-2深度学习的发展历程&#34;&gt;1.2深度学习的发展历程&lt;/h2&gt;

&lt;p&gt;本节介绍了深度网络历史的三个发展阶段。&lt;/p&gt;

&lt;p&gt;2012年的&lt;strong&gt;ImageNet&lt;/strong&gt;图像分类竞赛上，深度学习系统&lt;strong&gt;AlexNet&lt;/strong&gt;赢得冠军，自此深度学习作为深层神经网络的代名词而被人熟知。&lt;/p&gt;

&lt;h2 id=&#34;1-3深度学习的应用&#34;&gt;1.3深度学习的应用&lt;/h2&gt;

&lt;p&gt;这一节讲的是深度学习的应用，首先还是从ImageNet的图像识别开始，应用到了OCR（提到了卷积神经网络）、语音识别（提到了混合搞高斯模型）、自然语言处理（提到了语料库、单词向量、机器翻译、情感分析）、人机对弈（提到了AlphaGO）。&lt;/p&gt;

&lt;h2 id=&#34;1-4-深度学习工具介绍与对比&#34;&gt;1.4 深度学习工具介绍与对比&lt;/h2&gt;

&lt;p&gt;TensorFlow的渊源是Google大脑团队在2011年开发，在内部使用的&lt;strong&gt;DistBelief&lt;/strong&gt;，并赢得了ImageNet 2014年的比赛，TF是其开源版本，还发表了一篇论文&lt;code&gt;TensorFlow: Large-Scale Machine Learning on Heteogeneous Distributed systems&lt;/code&gt;，这就跟当年的&lt;strong&gt;HDFS&lt;/strong&gt;、&lt;strong&gt;MapReduce&lt;/strong&gt;一个套路啊。&lt;/p&gt;

&lt;p&gt;Google还把它用来做&lt;strong&gt;RankBrain&lt;/strong&gt;和很多其他的产品线上使用。&lt;/p&gt;

&lt;p&gt;当然，还有很多其他的深度学习工具，比如&lt;strong&gt;Caffe&lt;/strong&gt;、&lt;strong&gt;Deeplearning4j&lt;/strong&gt;、&lt;strong&gt;Torch&lt;/strong&gt;等不一而足。从各种指标来看，TensorFlow都是目前最受关注的深度学习框架。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker源码分析第一篇——代码结构</title>
      <link>http://rootsongjc.github.io/blogs/docker-source-code-analysis-code-structure/</link>
      <pubDate>Sun, 19 Mar 2017 23:00:29 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/docker-source-code-analysis-code-structure/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20151001042.jpg&#34; alt=&#34;八达岭长城&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(题图：北京八达岭长城  Oct 1,2015)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;之前陆陆续续看过一点&lt;strong&gt;docker&lt;/strong&gt;的源码，都未成体系，最近在研究&lt;strong&gt;Docker-17.03-CE&lt;/strong&gt;，趁此机会研究下docker的源码，在网上找到一些相关资料，都比较过时了，发现*孙宏亮*大哥写过一本书叫《Docker源码分析》，而且之前也在&lt;strong&gt;InfoQ&lt;/strong&gt;上陆续发过一些文章，虽然文章都比较老了，基于老的docker版本，但我认为依然有阅读的价值。起码能有这三方面收获：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一是培养阅读源码的思维方式，为自己阅读docker源码提供借鉴。&lt;/li&gt;
&lt;li&gt;二是可以了解docker版本的来龙去脉。&lt;/li&gt;
&lt;li&gt;三还可以作为Go语言项目开发作为借鉴。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;下载地址&#34;&gt;下载地址&lt;/h3&gt;

&lt;p&gt;鉴于这本书已经发行一年半了了，基于的docker版本还是&lt;strong&gt;1.2.0&lt;/strong&gt;，而如今都到了&lt;strong&gt;1.13.0&lt;/strong&gt;（docker17.03的老版本号），应该很少有人买了吧，可以说这本书的纸质版本的生命周期也差不多了吧。如果有人感兴趣可以下载pdf版本看看，&lt;a href=&#34;http://olz1di9xf.bkt.clouddn.com/Docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AD%99%E5%AE%8F%E4%BA%AE%E8%91%97.pdf&#34;&gt;Docker源码解析-机械工业出版社-孙宏亮著-2015年8月&lt;/a&gt;（完整文字版，大小25.86M），&lt;a href=&#34;http://olz1di9xf.bkt.clouddn.com/Docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%AD%99%E5%AE%8F%E4%BA%AE-%E7%9C%8B%E4%BA%91%E7%89%88.pdf&#34;&gt;Docker源码解析-看云整理版&lt;/a&gt;（文字版，有缩略，大小7.62M）。&lt;/p&gt;

&lt;h2 id=&#34;out-of-date&#34;&gt;Out-of-date&lt;/h2&gt;

&lt;p&gt;有一点必须再次强调一下，这本书中的docker源码分析是基于&lt;strong&gt;docker1.2.0&lt;/strong&gt;，而这个版本的docker源码在github上已经无法下载到了，github上available的最低版本的docker源码是&lt;strong&gt;1.4.1&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;顺便感叹一句，科技行业发展实在太快了，尤其是互联网，一本书能连续用上三年都不过时，如果这样的话那么这门技术恐怕都就要被淘汰了吧？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;总体架构&#34;&gt;总体架构&lt;/h2&gt;

&lt;p&gt;Docker总体上是用的是&lt;strong&gt;Client/Server&lt;/strong&gt;模式，所有的命令都可以通过RESTful接口传递。&lt;/p&gt;

&lt;p&gt;整个Docker软件的架构中可以分成三个角色：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Daemon&lt;/strong&gt;：常驻后台运行的进程，接收客户端请求，管理docker容器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clien&lt;/strong&gt;t：命令行终端，包装命令发送API请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Engine&lt;/strong&gt;：真正处理客户端请求的后端程序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;代码结构&#34;&gt;代码结构&lt;/h2&gt;

&lt;p&gt;Docker的代码结构比较清晰，分成的目录比较多，有以下这些：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;api&lt;/strong&gt;：定义API，使用了&lt;strong&gt;Swagger2.0&lt;/strong&gt;这个工具来生成API，配置文件在&lt;code&gt;api/swagger.yaml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;builder&lt;/strong&gt;：用来build docker镜像的包，看来历史比较悠久了&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bundles&lt;/strong&gt;：这个包是在进行&lt;a href=&#34;http://rootsongjc.github.io/blogs/docker-dev-env/&#34;&gt;docker源码编译和开发环境搭建&lt;/a&gt;的时候用到的，编译生成的二进制文件都在这里。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cli&lt;/strong&gt;：使用&lt;a href=&#34;http://www.github.com/spf13/cobra&#34;&gt;cobra&lt;/a&gt;工具生成的docker客户端命令行解析器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;client&lt;/strong&gt;：接收&lt;code&gt;cli&lt;/code&gt;的请求，调用RESTful API中的接口，向server端发送http请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cmd&lt;/strong&gt;：其中包括&lt;code&gt;docker&lt;/code&gt;和&lt;code&gt;dockerd&lt;/code&gt;两个包，他们分别包含了客户端和服务端的main函数入口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;container&lt;/strong&gt;：容器的配置管理，对不同的platform适配。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;contrib&lt;/strong&gt;：这个目录包括一些有用的脚本、镜像和其他非docker core中的部分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;daemon&lt;/strong&gt;：这个包中将docker deamon运行时状态expose出来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;distribution&lt;/strong&gt;：负责docker镜像的pull、push和镜像仓库的维护。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dockerversion&lt;/strong&gt;：编译的时候自动生成的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docs&lt;/strong&gt;：文档。这个目录已经不再维护，文档在另一个仓库里&lt;a href=&#34;https://github.com/docker/docker.github.io/。&#34;&gt;https://github.com/docker/docker.github.io/。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;experimental&lt;/strong&gt;：从docker1.13.0版本起开始增加了实验特性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hack&lt;/strong&gt;：创建docker开发环境和编译打包时用到的脚本和配置文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;image&lt;/strong&gt;：用于构建docker镜像的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;integration-cli&lt;/strong&gt;：集成测试&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;layer&lt;/strong&gt;：管理 union file system driver上的read-only和read-write mounts。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;libcontainerd&lt;/strong&gt;：访问内核中的容器系统调用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;man&lt;/strong&gt;：生成man pages。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;migrate&lt;/strong&gt;：将老版本的graph目录转换成新的metadata。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;oci&lt;/strong&gt;：Open Container Interface库&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;opts&lt;/strong&gt;：命令行的选项库。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pkg&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;plugin&lt;/strong&gt;：docker插件后端实现包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;profiles&lt;/strong&gt;：里面有apparmor和seccomp两个目录。用于内核访问控制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;project&lt;/strong&gt;：项目管理的一些说明文档。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reference&lt;/strong&gt;：处理docker store中镜像的reference。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;registry&lt;/strong&gt;：docker registry的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;restartmanager&lt;/strong&gt;：处理重启后的动作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;runconfig&lt;/strong&gt;：配置格式解码和校验。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vendor&lt;/strong&gt;：各种依赖包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volume&lt;/strong&gt;：docker volume的实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下一篇将讲解docker的各个功能模块和原理。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>http://rootsongjc.github.io/about/</link>
      <pubDate>Sat, 18 Mar 2017 20:10:56 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/about/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/jimmy.jpg&#34; alt=&#34;myself&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;about-me&#34;&gt;About me&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Jimmy Song&lt;/li&gt;
&lt;li&gt;Beijing, China&lt;/li&gt;
&lt;li&gt;rootsongjc@gmail.com&lt;/li&gt;
&lt;li&gt;Wechat: jimmysong&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;what-i-like&#34;&gt;What I like&lt;/h2&gt;

&lt;p&gt;Movie, Kubrick, Miyazaki, animation, Akira Kurosawa, photography, Daido Moriyama, potato, sony, apple, orange, Fellini, douban, google, Netease cloud music, Jay Chou, badminton, travelling, programming, golang, Java, Python, sea, blue, Henri Cartier-Bresson, Command &amp;amp; Conqure, Italy, Mac, pinao.&lt;/p&gt;

&lt;h2 id=&#34;what-i-dislike&#34;&gt;What I dislike&lt;/h2&gt;

&lt;p&gt;Chattering, Chemical fiber clothes, noise.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/wechat_qrcode.jpg&#34; alt=&#34;wechat_qrcode&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React入门</title>
      <link>http://rootsongjc.github.io/talks/react-tryout/</link>
      <pubDate>Sat, 18 Mar 2017 10:07:13 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/talks/react-tryout/</guid>
      <description>

&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;

&lt;p&gt;前端无疑是2016年最火热的技术，没有之一，2017年依然🔥。现在不会点前端技术都不好意思出去见人。&lt;/p&gt;

&lt;p&gt;各种前端mvc框架层出不穷，angular js，vue，&lt;a href=&#34;http://lib.csdn.net/base/react&#34;&gt;React&lt;/a&gt;，前端组件化开发概念已经深入人心。作为开发者，学习下前端设计也是有必要的，一来页面有些小的设计问题可以自己解决，同时还能提高自己的审美，提高网站的ui设计水平。&lt;/p&gt;

&lt;p&gt;今天看到一本书《React Up and Running》的中文版本《React快速上手开发》出版了，英文版可以在&lt;a href=&#34;http://olz1di9xf.bkt.clouddn.com/React_Up_and_Running.pdf&#34;&gt;这里&lt;/a&gt;下载。最近我在翻译的书&lt;a href=&#34;rootsongjc.github.io/talks/cloud-native-go/&#34;&gt;Cloud Native Go&lt;/a&gt;中的实例也使用了React来构建Web应用程序，因此在网上找了一些React资料学习下。&lt;/p&gt;

&lt;h2 id=&#34;必备基础技能&#34;&gt;必备基础技能&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/JacksonTian/fks&#34;&gt;前端技能汇总&lt;/a&gt;这个项目详细记录
了前端工程师牵涉到的各方面知识。在具备基本技能之后可以在里面找到学习
的方向，完善技能和知识面。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/dypsilon/frontend-dev-bookmarks&#34;&gt;frontend-dev-bookmarks&lt;/a&gt;是老外总结的&lt;a href=&#34;http://lib.csdn.net/base/javascript&#34;&gt;前端开发&lt;/a&gt;资源。覆盖面非常广。包括各种知识点、工具、技术，非常全面。&lt;/p&gt;

&lt;p&gt;以下是个人觉得入门阶段应该熟练掌握的基础技能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3.org/TR/html401/cover.html#minitoc&#34;&gt;HTML4&lt;/a&gt;，&lt;a href=&#34;http://www.w3.org/TR/html5/#contents&#34;&gt;HTML5&lt;/a&gt;语法、标签、语义&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3.org/TR/CSS2/#minitoc&#34;&gt;CSS2.1&lt;/a&gt;，&lt;a href=&#34;http://www.w3.org/TR/2001/WD-css3-roadmap-20010523/#table&#34;&gt;CSS3&lt;/a&gt;规范，与HTML结合实现各种布局、效果&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&#34;&gt;Ecma-262&lt;/a&gt;定义的javascript的语言核心，原生&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API&#34;&gt;客户端javascript&lt;/a&gt;，&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&#34;&gt;DOM操作&lt;/a&gt;，&lt;a href=&#34;https://developer.mozilla.org/en/docs/web/Guide/HTML/HTML5&#34;&gt;HTML5新增功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一个成熟的客户端javascript库，推荐&lt;a href=&#34;http://jquery.com/&#34;&gt;jquery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一门服务器端语言：如果有服务器端开发经验，使用已经会的语言即可，如果没有服务器端开发经验，熟悉Java可以选择Servlet，不熟悉的可以选PHP，能实现简单登陆注册功能就足够支持前端开发了，后续可能需要继续学习，最基本要求是实现简单的功能模拟，&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616.html&#34;&gt;HTTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在掌握以上基础技能之后，工作中遇到需要的技术也能快速学习。&lt;/p&gt;

&lt;h2 id=&#34;基本开发工具&#34;&gt;基本开发工具&lt;/h2&gt;

&lt;p&gt;恰当的工具能有效提高学习效率，将重点放在知识本身，在出现问题时能快速定位并
解决问题，以下是个人觉得必备的前端开发工具：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文本编辑器：推荐&lt;a href=&#34;http://www.sublimetext.com/&#34;&gt;Sublime Text&lt;/a&gt;，支持各种插件、主题、设置，使用方便&lt;/li&gt;
&lt;li&gt;浏览器：推荐&lt;a href=&#34;http://www.google.cn/chrome/?hl=zh-CN&amp;amp;standalone=1&#34;&gt;Google Chrome&lt;/a&gt;，更新快，对前端各种标准提供了非常好的支持&lt;/li&gt;
&lt;li&gt;调试工具：推荐Chrome自带的&lt;a href=&#34;https://developer.chrome.com/devtools&#34;&gt;Chrome develop tools&lt;/a&gt;，可以轻松查看DOM结构、样式，通过控制台输出调试信息，调试javascript，查看网络等&lt;/li&gt;
&lt;li&gt;辅助工具：PhotoShop编辑图片、取色，fireworks量尺寸，AlloyDesigner对比尺寸，以及前面的到的Chrome develop tools，&lt;/li&gt;
&lt;li&gt;翻墙工具：Shadowsocks、云梯VPN&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;学习方法和学习目标&#34;&gt;学习方法和学习目标&lt;/h2&gt;

&lt;p&gt;方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;入门阶段反复阅读经典书籍的中文版，书籍中的每一个例子都动手实现并在浏览器中查看效果&lt;/li&gt;
&lt;li&gt;在具备一定基础之后可以上网搜各种教程、demo，了解各种功能的实际用法和常见功能的实现方法&lt;/li&gt;
&lt;li&gt;阅读HTML，CSS，Javascript标准全面完善知识点&lt;/li&gt;
&lt;li&gt;阅读前端牛人的博客、文章提升对知识的理解&lt;/li&gt;
&lt;li&gt;善用搜索引擎&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目标：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;熟记前面知识点部分的重要概念，结合学习经历得到自己的理解&lt;/li&gt;
&lt;li&gt;熟悉常见功能的实现方法，如常见CSS布局，Tab控件等。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;入门之路&#34;&gt;入门之路&lt;/h2&gt;

&lt;p&gt;以下是入门阶段不错的书籍和资料&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;HTML先看&lt;a href=&#34;http://www.amazon.cn/gp/product/B00BMK4GKW/ref=s9_simh_gw_p14_d0_i2?pf_rd_m=A1AJ19PSB66TGU&amp;amp;pf_rd_s=center-2&amp;amp;pf_rd_r=1AH2NF64STS19GY8GR54&amp;amp;pf_rd_t=101&amp;amp;pf_rd_p=108773272&amp;amp;pf_rd_i=899254051&#34;&gt;《HTML &amp;amp; CSS: Design and Build Websites》&lt;/a&gt;1-9章，然后&lt;a href=&#34;http://www.amazon.cn/HTML5%E7%A7%98%E7%B1%8D-Matthew-MacDonald/dp/B009DFCZAQ/ref=sr_1_1?ie=UTF8&amp;amp;qid=1414740812&amp;amp;sr=8-1&amp;amp;keywords=html5+the+missing+manual&#34;&gt;《HTML5: The Missing Manual》&lt;/a&gt;1-4章。&lt;/li&gt;
&lt;li&gt;CSS先看&lt;a href=&#34;http://www.amazon.cn/CSS-The-Missing-Manual-Mcfarland-David-Sawyer/dp/0596802447/ref=sr_1_1?ie=UTF8&amp;amp;qid=1414742710&amp;amp;sr=8-1&amp;amp;keywords=css+the+missing+manual+2&#34;&gt;《CSS: The Missing Manual》&lt;/a&gt;，然后&lt;a href=&#34;http://www.amazon.cn/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E8%BF%88%E8%80%B6/dp/B0011F5SIC/ref=sr_1_1?ie=UTF8&amp;amp;qid=1414744248&amp;amp;sr=8-1&amp;amp;keywords=css+%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97&#34;&gt;《CSS权威指南》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;javascript先看&lt;a href=&#34;http://www.amazon.cn/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%B3%BD%E5%8D%A1%E6%96%AF/dp/B007OQQVMY/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1414744358&amp;amp;sr=1-1&amp;amp;keywords=javascript+%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&#34;&gt;《javascript高级程序设计》&lt;/a&gt;，然后&lt;a href=&#34;http://www.amazon.cn/O-Reilly%E7%B2%BE%E5%93%81%E5%9B%BE%E4%B9%A6%E7%B3%BB%E5%88%97-JavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E5%BC%97%E5%85%B0%E7%BA%B3%E6%A0%B9/dp/B007VISQ1Y/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1414744401&amp;amp;sr=1-1&amp;amp;keywords=javascript+%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97&#34;&gt;《javascript权威指南》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;HTTP看&lt;a href=&#34;http://www.amazon.cn/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E5%90%89%E5%B0%94%E5%88%A9/dp/B008XFDQ14/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1414744440&amp;amp;sr=1-1&amp;amp;keywords=HTTP+%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97&#34;&gt;HTTP权威指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在整个学习过程中HTML CSS JavaScript会有很多地方需要互相结合，实际工作中也是这样，一个简单的功能模块都需要三者结合才能实现。&lt;/li&gt;
&lt;li&gt;动手是学习的重要组成部分，书籍重点讲解知识点，例子可能不是很充足，这就需要利用搜索引擎寻找一些简单教程，照着教程实现功能。以下是一些比较好的教程网址

&lt;ul&gt;
&lt;li&gt;可以搜索各大公司前端校招笔试面试题作为练习题或者他人总结的&lt;a href=&#34;https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Translations/Chinese&#34;&gt;前端面试题&lt;/a&gt;还有&lt;a href=&#34;https://github.com/qiu-deqing/FE-interview&#34;&gt;个人总结的面试题&lt;/a&gt;（带参考答案）&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://code.tutsplus.com/&#34;&gt;http://code.tutsplus.com&lt;/a&gt;有各种各样的教程&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web&#34;&gt;MDN&lt;/a&gt;也有很多教程，更重要的是里面有详细的文档，需要查找某个功能时在Google搜索：&lt;code&gt;xxx site:https://developer.mozilla.org&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.html5rocks.com/zh/&#34;&gt;http://www.html5rocks.com/zh/&lt;/a&gt;也有很多优质教程&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sitepoint.com/&#34;&gt;http://www.sitepoint.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://alistapart.com/&#34;&gt;http://alistapart.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;原生javascript是需要重点掌握的技能，在掌握原生javascript的基础上推荐熟练掌握jQuery，在实际工作中用处很大，这方面的书籍有&lt;a href=&#34;http://www.amazon.com/Learning-jQuery-Fourth-Jonathan-Chaffer/dp/178216314X/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=1410099243&amp;amp;sr=1-1&amp;amp;keywords=learning+jquery&#34;&gt;《Learning jQuery》&lt;/a&gt;或者去&lt;a href=&#34;http://learn.jquery.com/&#34;&gt;jQuery官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;建一个&lt;a href=&#34;https://github.com/&#34;&gt;https://github.com/&lt;/a&gt;账号，保存平时学习中的各种代码和项目。&lt;/li&gt;
&lt;li&gt;有了一定基础之后可以搭建一个个人博客，记录学习过程中遇到的问题和解决方法，方便自己查阅也为其他人提供了帮助。也可以去&lt;a href=&#34;http://www.cnblogs.com/&#34;&gt;http://www.cnblogs.com/&lt;/a&gt;或者&lt;a href=&#34;http://www.csdn.net/&#34;&gt;http://www.csdn.net/&lt;/a&gt;这样的网站注册账号，方便实用&lt;/li&gt;
&lt;li&gt;经常实用Google搜索英文资料应该经常找到来自&lt;a href=&#34;http://stackoverflow.com/&#34;&gt;http://stackoverflow.com/&lt;/a&gt;的高质量答案，与到问题可以直接在这里搜索，如果有精力，注册一个账号为别人解答问题也能极大提高个人能力。&lt;/li&gt;
&lt;li&gt;经典书籍熟读之后，可以打开前面必备基础技能部分的链接。认真读对应标准，全面掌握知识&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;继续提高&#34;&gt;继续提高&lt;/h2&gt;

&lt;p&gt;有了前面的基础之后，前端基本算是入门了，这时候可能每个人心中都有了一些学习方向，如果还是没有。
可以参考前面必备技能部分提到的那两个项目，从里面选一些进行发展学习。以下是一些不错的方面：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gruntjs.com/&#34;&gt;Grunt&lt;/a&gt;：前端自动化工具，提高工作效率&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lesscss.org/&#34;&gt;less css&lt;/a&gt;：优秀的CSS预处理器&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://getbootstrap.com/&#34;&gt;bootstrap&lt;/a&gt;：优秀的CSS框架，对没有设计师的团队很不错，与less结合使用效果完美&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://requirejs.org/&#34;&gt;requirejs&lt;/a&gt;：AMD规范的模块加载器，前端模块化趋势的必备工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nodejs.org/&#34;&gt;Node.js&lt;/a&gt;：JavaScript也可以做后台，前端工程师地位更上一步&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://angularjs.org/&#34;&gt;AngularJS&lt;/a&gt;：做Single Page Application的好工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Guide/Mobile&#34;&gt;移动端web开发&lt;/a&gt;：智能手机的普及让移动端的流量正在逐步赶超PC端&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.chrome.com/devtools/docs/javascript-memory-profiling?hl=figoogle&#34;&gt;Javascript内存管理&lt;/a&gt;：SPA长期运行需要注意内存泄露的问题&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.amazon.com/Performance-JavaScript-Faster-Application-Interfaces/dp/059680279X/ref=sr_1_1?s=books&amp;amp;ie=UTF8&amp;amp;qid=undefined&amp;amp;sr=1-1&amp;amp;keywords=high+performance+javascript&#34;&gt;High Performance JavaScript(Build Faster Web Application Interfaces)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.yahoo.com/performance/rules.html&#34;&gt;Best Practices for Speeding Up Your Web Site&lt;/a&gt;：重要技能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;react开发环境配置&#34;&gt;React开发环境配置&lt;/h2&gt;

&lt;p&gt;我在Mac下安装node支持。参考这篇文档：&lt;a href=&#34;http://www.jianshu.com/p/20ea93641bda&#34;&gt;http://www.jianshu.com/p/20ea93641bda&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;直接执行一条命名就可以安装好环境：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$brew install node &amp;amp;&amp;amp; \
npm install -g grunt-cli &amp;amp;&amp;amp; \
npm install -g webpack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装好了之后就可以Get started了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.jianshu.com/p/418e48e0cef1&#34;&gt;React+Webpack快速上手指南&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://tianxiangbing.github.io/react-cn/docs/getting-started.html&#34;&gt;React native中文资料&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2015/03/react.html&#34;&gt;阮一峰的react实例教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;未完待续。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>零基础使用Hugo和GitHub Pages创建自己的博客</title>
      <link>http://rootsongjc.github.io/talks/building-github-pages-with-hugo/</link>
      <pubDate>Fri, 17 Mar 2017 22:08:25 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/talks/building-github-pages-with-hugo/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20151005061.jpg&#34; alt=&#34;鹰&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：🦅 北京动物园 Oct 5,2015）&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;亲，你还在为虚拟主机、域名、空间而发愁吗？你想拥有自己的网站吗？你想拥有一个分享知识、留住感动，为开源事业而奋斗终身吗？那么赶快拿起你手中的📱拨打&lt;del&gt;16899168&lt;/del&gt;，不对，是看这篇文章吧，不用998，也不用168，这一切都是免费的，是的&lt;strong&gt;你没看错，真的不要钱！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;准备&#34;&gt;准备&lt;/h2&gt;

&lt;p&gt;当然还是需要你有一点电脑基础的，会不会编程不要紧，还要会一点英文，你需要先申请一下几个账号和安装一些软件环境：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.github.com&#34;&gt;GitHub&lt;/a&gt; &lt;strong&gt;这是必需的&lt;/strong&gt;，因为你需要使用&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;来托管你的网站。而且你还需要安装git工具。创建一个以自己用户名命名的username.github.io的project。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.qiniu.com/&#34;&gt;七牛云存储&lt;/a&gt; &lt;strong&gt;非必需&lt;/strong&gt;，为了存储文件方便，建议申请一个，免费10G的存储空间，存储照片和一些小文件是足够的，可以用来做外链，方便存储和管理，这样你就不用把图片也托管到Github上了。流量也是不限的。我没有收七牛的一点好处，以为是我自己用的，所以推荐给大家，七牛还有命令行客户端，方便你上传和同步文件。如上的题图都是存储在七牛云中的。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;tongji.baidu.com&#34;&gt;百度统计&lt;/a&gt; &lt;strong&gt;非必需&lt;/strong&gt;，基本的网站数据分析，免费的，质量还行。还有微信公众号可以查看，这一点我发现腾讯分析居然都没有微信公众号，自家的产品咋都不推出微信客户端呢。顺便提一下，这个统计账号跟你的百度账号不是同一个东西，两者是两套体系，当然你可以和自己的百度账号关联。只需要在Web的Header中植入一段JS代码即可。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gohugo.io&#34;&gt;Hugo&lt;/a&gt; &lt;strong&gt;必需的&lt;/strong&gt;，静态网站生成工具，用来编译静态网站的。跟Hexo比起来我更喜欢这个工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://typora.io/&#34;&gt;Typro&lt;/a&gt; &lt;strong&gt;非必需&lt;/strong&gt;，但是强烈推荐，我最喜欢的免费的Markdown编辑器，hugo可以编译markdown格式为HTML，所以用它来写博客是最合适不过了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;好了注册好Github后你现在可以尽情的玩耍了！😄&lt;/p&gt;

&lt;h2 id=&#34;let-s-rock-roll&#34;&gt;Let&amp;rsquo;s rock&amp;amp;roll!&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;首先介绍下Hugo&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hugo是一种通用的网站框架。严格来说，Hugo应该被称作静态网站生成器。&lt;/p&gt;

&lt;p&gt;静态网站生成器从字面上来理解，就是将你的内容生成静态网站。所谓“静态”的含义其实反映在网站页面的生成的时间。一般的web服务器（WordPress, Ghost, Drupal等等）在收到页面请求时，需要调用数据库生成页面（也就是HTML代码），再返回给用户请求。而静态网站则不需要在收到请求后生成页面，而是在整个网站建立起之前就将所有的页面全部生成完成，页面一经生成便称为静态文件，访问时直接返回现成的静态页面，不需要数据库的参与。&lt;/p&gt;

&lt;p&gt;采用静态网站的维护也相当简单，实际上你根本不需要什么维护，完全不用考虑复杂的运行时间，依赖和数据库的问题。再有也不用担心安全性的问题，没有数据库，网站注入什么的也无从下手。&lt;/p&gt;

&lt;p&gt;静态网站最大好处就是访问快速，不用每次重新生成页面。当然，一旦网站有任何更改，静态网站生成器需要重新生成所有的与更改相关的页面。然而对于小型的个人网站，项目主页等等，网站规模很小，重新生成整个网站也是非常快的。Hugo在速度方面做得非常好，Dan Hersam在他这个&lt;a href=&#34;https://www.udemy.com/build-static-sites-in-seconds-with-hugo/&#34;&gt;Hugo教程&lt;/a&gt;里提到，5000篇文章的博客，Hugo生成整个网站只花了6秒，而很多其他的静态网站生成器则需要几分钟的时间。我的博客目前文章只有几十篇，用Hugo生成整个网站只需要0.1秒。官方文档提供的数据是每篇页面的生成时间不到1ms。&lt;/p&gt;

&lt;p&gt;认为对于个人博客来说，应该将时间花在内容上而不是各种折腾网站。Hugo会将Markdown格式的内容和设置好模版一起，生成漂亮干净的页面。挑选折腾好一个喜爱的模版，在Sublime Text里用Markdown写博客，再敲一行命令生成同步到服务器就OK了。整个体验是不是非常优雅简单还有点geek的味道呢？&lt;/p&gt;

&lt;h3 id=&#34;了解hugo&#34;&gt;了解Hugo&lt;/h3&gt;

&lt;p&gt;首先建立自己的网站，mysite是网站的路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后进入该路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在该目录下你可以看到以下几个目录和&lt;code&gt;config.toml&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ▸ archetypes/ 
 ▸ content/
 ▸ layouts/
 ▸ static/
   config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;config.toml&lt;/code&gt;是网站的配置文件，包括&lt;code&gt;baseurl&lt;/code&gt;, &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;copyright&lt;/code&gt;等等网站参数。&lt;/p&gt;

&lt;p&gt;这几个文件夹的作用分别是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;archetypes：包括内容类型，在创建新内容时自动生成内容的配置&lt;/li&gt;
&lt;li&gt;content：包括网站内容，全部使用markdown格式&lt;/li&gt;
&lt;li&gt;layouts：包括了网站的模版，决定内容如何呈现&lt;/li&gt;
&lt;li&gt;static：包括了css, js, fonts, media等，决定网站的外观&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hugo提供了一些完整的主题可以使用，下载这些主题：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/spf13/hugoThemes themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时现成的主题存放在&lt;code&gt;themes/&lt;/code&gt;文件夹中。&lt;/p&gt;

&lt;p&gt;现在我们先熟悉一下Hugo，创建新页面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入&lt;code&gt;content/&lt;/code&gt;文件夹可以看到，此时多了一个markdown格式的文件&lt;code&gt;about.md&lt;/code&gt;，打开文件可以看到时间和文件名等信息已经自动加到文件开头，包括创建时间，页面名，是否为草稿等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
+++
date = &amp;quot;2015-02-01T18:19:54+08:00&amp;quot;
draft = true
title = &amp;quot;about&amp;quot;
Tag = [&amp;quot;blog&amp;quot;,&amp;quot;post&amp;quot;]

+++

# About me
- Jimmy Song
- rootsongjc@gmail.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我在页面中加入了一些内容，然后运行Hugo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server -t hyde --buildDrafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-t&lt;/code&gt;参数的意思是使用hyde主题渲染我们的页面，注意到&lt;code&gt;about.md&lt;/code&gt;目前是作为草稿，即&lt;code&gt;draft&lt;/code&gt;参数设置为&lt;code&gt;true&lt;/code&gt;，运行Hugo时要加上&lt;code&gt;--buildDrafts&lt;/code&gt;参数才会生成被标记为草稿的页面。 在浏览器输入localhost:1313，就可以看到我们刚刚创建的页面。&lt;/p&gt;

&lt;p&gt;注意观察当前目录下多了一个文件夹&lt;code&gt;public/&lt;/code&gt;，这里面是Hugo生成的整个静态网站，如果使用Github pages来作为博客的Host，你只需要将&lt;code&gt;public/&lt;/code&gt;里的文件上传就可以，这相当于是Hugo的输出。&lt;/p&gt;

&lt;p&gt;详细说明请看这位朋友的文章：&lt;a href=&#34;http://nanshu.wang/post/2015-01-31/&#34;&gt;http://nanshu.wang/post/2015-01-31/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;hugo new&lt;/code&gt;命令生成的文章前面的加号中包括的那几行，是用来设置文章属性的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;date&lt;/strong&gt; 自动增加时间标签，页面上默认显示n篇最新的文章。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;draft&lt;/strong&gt; 设置为false的时候会被编译为HTML，true则不会编译和发表，在本地修改文章时候用true。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;title&lt;/strong&gt; 设置文章标题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tags&lt;/strong&gt; 数组，可以设置多个标签，都好隔开，hugo会自动在你博客主页下生成标签的子URL，通过这个URL可以看到所有具有该标签的文章。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Category&lt;/strong&gt; 文章分类，跟Tag功能差不多。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今天先说到这里，再次声明下，&lt;a href=&#34;http://rootsongjc.github.io&#34;&gt;Jimmy&amp;rsquo;s blog&lt;/a&gt;就是用👆得步骤建立的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Jimmy&amp;rsquo;s blog的页面比较简陋，你可以在&lt;a href=&#34;themes.gohugo.io&#34;&gt;这里&lt;/a&gt;找到更多可爱的模版。另外我打算给我翻译的书&lt;a href=&#34;http://rootsongjc.github.io/talks/cloud-native-go/&#34;&gt;Cloude Native Go&lt;/a&gt;做一个静态页面，用来发表图书信息、勘误、讨论等，现在已经有了&lt;a href=&#34;http://rootsongjc.github.io/cloud-native-go/&#34;&gt;雏形&lt;/a&gt;，欢迎大家关注。🙏&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Contiv Ultimate-Docker17.03CE下思科docker网络插件contiv趟坑终极版</title>
      <link>http://rootsongjc.github.io/blogs/contiv-ultimate/</link>
      <pubDate>Fri, 17 Mar 2017 17:52:37 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/contiv-ultimate/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20140810001.jpg&#34; alt=&#34;广州石牌桥&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：广州石牌桥 Aug 10,2014）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;前几天写的几篇&lt;a href=&#34;http://rootsongjc.github.io/tags/contiv/&#34;&gt;关于Contiv的文章&lt;/a&gt;已经把引入坑了😂&lt;/p&gt;

&lt;p&gt;今天这篇文章将带领大家用正确的姿势编译和打包一个&lt;strong&gt;contiv netplugin&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;请一定要在&lt;strong&gt;Linux&lt;/strong&gt;环境中编译。docker中编译也会报错，最好还是搞个虚拟🐔吧，最好还有VPN能翻墙。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;环境准备&#34;&gt;环境准备&lt;/h2&gt;

&lt;p&gt;我使用的是docker17.03-CE、安装了open vSwitch(这个包redhat的源里没有，需要自己的编译安装)，如果你懒得编译可以用我编译的rpm包，&lt;a href=&#34;http://olz1di9xf.bkt.clouddn.com/openvswitch-2.5.0-2.el7.x86_64.rpm&#34;&gt;点这里下载&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;

&lt;p&gt;这一步是很容易失败的，有人提过&lt;a href=&#34;https://github.com/contiv/netplugin/issues/779&#34;&gt;issue-779&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;具体步骤&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建一个link &lt;strong&gt;/go&lt;/strong&gt;链接到你的GOPATH目录，下面编译的时候要用。&lt;/li&gt;
&lt;li&gt;将源码的&lt;strong&gt;vender&lt;/strong&gt;目录下的文件拷贝到$GOPATH/src目录。&lt;/li&gt;
&lt;li&gt;执行编译&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在netplugin目录下执行以下命令能够编译出二进制文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NET_CONTAINER_BUILD=1 make build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在你的&lt;strong&gt;/$GOPATH/bin&lt;/strong&gt;目录下应该会有如下几个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;contivk8s  github-release  godep  golint  misspell  modelgen  netcontiv  netctl  netmaster  netplugin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;⚠️编译过程中可能会遇到 有些包不存在或者需要翻墙下载。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;打包&#34;&gt;打包&lt;/h2&gt;

&lt;p&gt;我们将其打包为docker plugin。&lt;/p&gt;

&lt;p&gt;Makefile里用于创建plugin rootfs的命令是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Makefile&#34;&gt;host-pluginfs-create:
        @echo dev: creating a docker v2plugin rootfs ...
        sh scripts/v2plugin_rootfs.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;v2plugin_rootfs.sh&lt;/strong&gt;这个脚本的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;#!/bin/bash
# Script to create the docker v2 plugin
# run this script from contiv/netplugin directory

echo &amp;quot;Creating rootfs for v2plugin &amp;quot;, ${CONTIV_V2PLUGIN_NAME}
cat install/v2plugin/config.template | grep -v &amp;quot;##&amp;quot; &amp;gt; install/v2plugin/config.json
sed -i &amp;quot;s%PluginName%${CONTIV_V2PLUGIN_NAME}%&amp;quot; install/v2plugin/config.json
cp bin/netplugin bin/netmaster bin/netctl install/v2plugin
docker build -t contivrootfs install/v2plugin
id=$(docker create contivrootfs true)
mkdir -p install/v2plugin/rootfs
sudo docker export &amp;quot;${id}&amp;quot; | sudo tar -x -C install/v2plugin/rootfs
docker rm -vf &amp;quot;${id}&amp;quot;
docker rmi contivrootfs
rm install/v2plugin/netplugin install/v2plugin/netmaster install/v2plugin/netctl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先把&lt;code&gt;$GOPATH/bin&lt;/code&gt;下生成的&lt;code&gt;netplugin&lt;/code&gt;、&lt;code&gt;netmaster&lt;/code&gt;、&lt;code&gt;netctl&lt;/code&gt;、&lt;code&gt;netplugin&lt;/code&gt;这几个二进制文件拷贝到netplugin源码的bin目录下。&lt;/p&gt;

&lt;p&gt;这里面用语创建contivrootfs镜像的Dockerfile内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;# Docker v2plugin container with OVS / netplugin / netmaster 

FROM alpine:3.5
MAINTAINER Cisco Contiv (http://contiv.github.io/)

RUN mkdir -p /run/docker/plugins /etc/openvswitch /var/run/contiv/log \
    &amp;amp;&amp;amp; echo &#39;http://dl-cdn.alpinelinux.org/alpine/v3.4/main&#39; &amp;gt;&amp;gt; /etc/apk/repositories \
    &amp;amp;&amp;amp; apk update &amp;amp;&amp;amp; apk add openvswitch=2.5.0-r0 iptables

COPY netplugin netmaster netctl startcontiv.sh /

ENTRYPOINT [&amp;quot;/startcontiv.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行&lt;code&gt;make host-pluginfs-create&lt;/code&gt;创建rootfs。&lt;/p&gt;

&lt;p&gt;创建出了rootfs后，然后执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Shell&#34;&gt;docker plugin create localhost:5000/contiv/netplugin .
docker push localhost:5000/contiv/netplugin
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;注：我们将插件push到docker registry的镜像仓库中，当前&lt;a href=&#34;www.github.com/vmware/harbor&#34;&gt;Harbor&lt;/a&gt;还不支持docker插件的push。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Install plugin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面是编译和安装我自己生成v2plugin的过程。&lt;/p&gt;

&lt;p&gt;修改&lt;strong&gt;config.json&lt;/strong&gt;文件中的&lt;code&gt;plugin_name&lt;/code&gt;字段的值为插件的名称。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$docker plugin install localhost:5000/contiv/v2plugin 
Plugin &amp;quot;localhost:5000/contiv/v2plugin&amp;quot; is requesting the following privileges:
 - network: [host]
 - mount: [/etc/openvswitch]
 - mount: [/var/log/openvswitch]
 - mount: [/var/run]
 - mount: [/lib/modules]
 - capabilities: [CAP_SYS_ADMIN CAP_NET_ADMIN CAP_SYS_MODULE]
Do you grant the above permissions? [y/N] y
latest: Pulling from contiv/v2plugin
fd87a71d9090: Download complete 
Digest: sha256:b13ad7930f771c9602acf562c2ae147482466f4d94e708692a215935663215a6
Status: Downloaded newer image for localhost:5000/contiv/v2plugin:latest
Installed plugin localhost:5000/contiv/v2plugin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自己create的插件enable的时候从docker daemon的日志中依然可以看到之前看到找不到socket的错误，实际上也确实是没有生成。如果直接使用&lt;code&gt;docker plugin install store/contiv/v2plugin:1.0.0-beta.3&lt;/code&gt;的方式安装插件是没有问题的。&lt;/p&gt;

&lt;h2 id=&#34;docker17-03-ce中插件机制存在的问题&#34;&gt;Docker17.03-CE中插件机制存在的问题&lt;/h2&gt;

&lt;p&gt;Docker17.03的插件机制是为了docker公司的商业化策略而实行的，所有的docker插件都运行在自己的namespace和rootfs中，插件接口&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Plugin backend接口&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// Backend for Plugin
type Backend interface {
	Disable(name string, config *enginetypes.PluginDisableConfig) error
	Enable(name string, config *enginetypes.PluginEnableConfig) error
	List(filters.Args) ([]enginetypes.Plugin, error)
	Inspect(name string) (*enginetypes.Plugin, error)
	Remove(name string, config *enginetypes.PluginRmConfig) error
	Set(name string, args []string) error
	Privileges(ctx context.Context, ref reference.Named, metaHeaders http.Header, authConfig *enginetypes.AuthConfig) (enginetypes.PluginPrivileges, error)
	Pull(ctx context.Context, ref reference.Named, name string, metaHeaders http.Header, authConfig *enginetypes.AuthConfig, privileges enginetypes.PluginPrivileges, outStream io.Writer) error
	Push(ctx context.Context, name string, metaHeaders http.Header, authConfig *enginetypes.AuthConfig, outStream io.Writer) error
	Upgrade(ctx context.Context, ref reference.Named, name string, metaHeaders http.Header, authConfig *enginetypes.AuthConfig, privileges enginetypes.PluginPrivileges, outStream io.Writer) error
	CreateFromContext(ctx context.Context, tarCtx io.ReadCloser, options *enginetypes.PluginCreateOptions) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从Plugin的后端接口中可以看到，没有像镜像一样的两个常用方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有修改plugin名字的方法，因为没有这个方法，就无法push plugin到自己的镜像仓库，另外&lt;strong&gt;Harbor&lt;/strong&gt;还是不支持&lt;code&gt;docker plugin push&lt;/code&gt; &lt;a href=&#34;https://github.com/vmware/harbor/issues/1532&#34;&gt;Issue-1532&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;没有导出plugin的方法，这样就只能在联网的主机上安装docker plugin了，对于无法联网的主机只好束手无策了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;估计docker官方也不会开放这两个接口吧。毕竟这是&lt;strong&gt;Docker EE&lt;/strong&gt; 的一个重要卖点：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Docker EE&amp;rsquo;s Certified Plugins&lt;/strong&gt; provide networking and volume plugins and easy to download and install containers to the Docker EE environment.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;疑问&#34;&gt;疑问&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;为什么一定要使用docker plugin install&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为&lt;code&gt;docker plugin install&lt;/code&gt;的时候会申请一些访问权限。&lt;/p&gt;

&lt;p&gt;这一块在上面的步骤中可以看到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么docker plugin不能改名字？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们看下Plugin的结构体（在api/types/plugin.go中定义）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Plugin A plugin for the Engine API
// swagger:model Plugin
type Plugin struct {

	// config
	// Required: true
	Config PluginConfig `json:&amp;quot;Config&amp;quot;`

	// True when the plugin is running. False when the plugin is not running, only installed.
	// Required: true
	Enabled bool `json:&amp;quot;Enabled&amp;quot;`

	// Id
	ID string `json:&amp;quot;Id,omitempty&amp;quot;`

	// name
	// Required: true
	Name string `json:&amp;quot;Name&amp;quot;`

	// plugin remote reference used to push/pull the plugin
	PluginReference string `json:&amp;quot;PluginReference,omitempty&amp;quot;`

	// settings
	// Required: true
	Settings PluginSettings `json:&amp;quot;Settings&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意其中有一个&lt;code&gt;PluginReference&lt;/code&gt;结构体，它的方法有：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type pluginReference struct {
	name     reference.Named
	pluginID digest.Digest
}

func (r *pluginReference) References(id digest.Digest) []reference.Named {
	if r.pluginID != id {
		return nil
	}
	return []reference.Named{r.name}
}

func (r *pluginReference) ReferencesByName(ref reference.Named) []refstore.Association {
	return []refstore.Association{
		{
			Ref: r.name,
			ID:  r.pluginID,
		},
	}
}

func (r *pluginReference) Get(ref reference.Named) (digest.Digest, error) {
	if r.name.String() != ref.String() {
		return digest.Digest(&amp;quot;&amp;quot;), refstore.ErrDoesNotExist
	}
	return r.pluginID, nil
}

func (r *pluginReference) AddTag(ref reference.Named, id digest.Digest, force bool) error {
	// Read only, ignore
	return nil
}
func (r *pluginReference) AddDigest(ref reference.Canonical, id digest.Digest, force bool) error {
	// Read only, ignore
	return nil
}
func (r *pluginReference) Delete(ref reference.Named) (bool, error) {
	// Read only, ignore
	return false, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意其中有三个方法&lt;code&gt;AddTag&lt;/code&gt;、&lt;code&gt;AddDigest&lt;/code&gt;、&lt;code&gt;Delete&lt;/code&gt;方法都是只读的。在&lt;code&gt;migrate/v1/migratev1.go&lt;/code&gt;中有引用到了这个。&lt;/p&gt;

&lt;p&gt;再看下&lt;strong&gt;Reference&lt;/strong&gt;的的定义（vendor/github.com/docker/distribution/reference/reference.go）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// Package reference provides a general type to represent any way of referencing images within the registry.
// Its main purpose is to abstract tags and digests (content-addressable hash).
//
// Grammar
//
// 	reference                       := name [ &amp;quot;:&amp;quot; tag ] [ &amp;quot;@&amp;quot; digest ]
//	name                            := [domain &#39;/&#39;] path-component [&#39;/&#39; path-component]*
//	domain                          := domain-component [&#39;.&#39; domain-component]* [&#39;:&#39; port-number]
//	domain-component                := /([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])/
//	port-number                     := /[0-9]+/
//	path-component                  := alpha-numeric [separator alpha-numeric]*
// 	alpha-numeric                   := /[a-z0-9]+/
//	separator                       := /[_.]|__|[-]*/
//
//	tag                             := /[\w][\w.-]{0,127}/
//
//	digest                          := digest-algorithm &amp;quot;:&amp;quot; digest-hex
//	digest-algorithm                := digest-algorithm-component [ digest-algorithm-separator digest-algorithm-component ]
//	digest-algorithm-separator      := /[+.-_]/
//	digest-algorithm-component      := /[A-Za-z][A-Za-z0-9]*/
//	digest-hex                      := /[0-9a-fA-F]{32,}/ ; At least 128 bit digest value
//
//	identifier                      := /[a-f0-9]{64}/
//	short-identifier                := /[a-f0-9]{6,64}/
// Reference is an opaque object reference identifier that may include
// modifiers such as a hostname, name, tag, and digest.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改plugin的名字的方法是不是还没实现？&lt;/p&gt;

&lt;h2 id=&#34;解决方法&#34;&gt;解决方法&lt;/h2&gt;

&lt;p&gt;在代码存在bug的情况下，可以先用下面的方法暂时创建plugin。&lt;/p&gt;

&lt;p&gt;虽然docker代码里没有提供&lt;strong&gt;rename plugin&lt;/strong&gt;的接口，但是使用&lt;strong&gt;docker install&lt;/strong&gt;命令安装的plugin会存储在&lt;code&gt;/var/lib/docker/plugins/${PLUGIN_ID}&lt;/code&gt;目录下。&lt;/p&gt;

&lt;p&gt;可以在这个目录下使用&lt;strong&gt;docker plugin create&lt;/strong&gt;命令创建你自己想要的名称的docker plugin。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;docker plugin set&lt;/code&gt;命令修改plugin中的属性:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;cluster_store&lt;/li&gt;
&lt;li&gt;plugin_role&lt;/li&gt;
&lt;li&gt;plugin_name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;插件调试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;日志地址&lt;code&gt;/run/contiv/log/&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;从非master节点的netplugin启动日志&lt;code&gt;netplugin_bootup.log&lt;/code&gt;中可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;V2 Plugin logs
Loading OVS
Starting OVS
Starting Netplugin 
/netplugin -debug -plugin-mode docker -vlan-if  -cluster-store etcd://172.20.0.113:2379  
Not starting netmaster as plugin role is none
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Netplugin启动的时候是正确的解析了&lt;strong&gt;etcd&lt;/strong&gt;的配置了。&lt;/p&gt;

&lt;p&gt;但是我们再看一下&lt;code&gt;netplugin.log&lt;/code&gt;的日志后就会发现，启动还是失败了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;time=&amp;quot;Mar 21 03:20:37.537954358&amp;quot; level=debug msg=&amp;quot;Got link list(16): [0xc4203fe200 0xc4203fe300 0xc4203fe400 0xc4203fe500 0xc420420000 0xc420420090 0xc420420120 0xc4204201b0 0xc420420240 0xc4204202d0 0xc420420360 0xc4204203f0 0xc420420480 0xc420420510 0xc4203feb80 0xc4203fec80]&amp;quot;
time=&amp;quot;Mar 21 03:20:37.538576647&amp;quot; level=error msg=&amp;quot;Failed to connect to etcd. Err: client: etcd cluster is unavailable or misconfigured&amp;quot;
time=&amp;quot;Mar 21 03:20:37.538599827&amp;quot; level=error msg=&amp;quot;Error creating client etcd to url 127.0.0.1:2379. Err: client: etcd cluster is unavailable or misconfigured&amp;quot;
time=&amp;quot;Mar 21 03:20:37.538612813&amp;quot; level=fatal msg=&amp;quot;Error initializing cluster. Err: client: etcd cluster is unavailable or misconfigured&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;netplugin&lt;/code&gt;没有正确的解析etcd的地址。这到底是为什么呢？bootup的日志里不是写的解析到了吗？这个问题还得研究下源码，也许是一个bug。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker17.03-CE插件开发-举个🌰</title>
      <link>http://rootsongjc.github.io/blogs/docker-plugin-develop/</link>
      <pubDate>Wed, 15 Mar 2017 13:57:26 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/docker-plugin-develop/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20161016022.jpg&#34; alt=&#34;杭州吴山&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：杭州吴山步道旁的墙壁 Oct 16,2016）&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当你看到这篇文章时，如果你也正在进行docker1.13+版本下的plugin开发，恭喜你也入坑了，如果你趟出坑，麻烦告诉你的方法，感恩不尽🙏&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看了文章后你可能会觉得，官网上的可能是个假🌰。&lt;strong&gt;虽然官网上的文档写的有点不对，不过你使用docker-ssh-volume的开源代码自己去构建plugin的还是可以成功的！&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;docker-plugin开发文档&#34;&gt;Docker plugin开发文档&lt;/h3&gt;

&lt;p&gt;首先docker官方给出了一个&lt;a href=&#34;https://docs.docker.com/engine/extend/legacy_plugins/&#34;&gt;docker legacy plugin文档&lt;/a&gt;，这篇文章基本就是告诉你docker目前支持哪些插件，罗列了一系列连接，不过对不起，这些不是docker官方插件，有问题去找它们的开发者去吧😂&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker plugin貌似开始使用了新的v2 plugin了，legacy版本的plugin可以能在后期被废弃。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从docker的源码&lt;strong&gt;plugin/store.go&lt;/strong&gt;中可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;/* allowV1PluginsFallback determines daemon&#39;s support for V1 plugins.
 * When the time comes to remove support for V1 plugins, flipping
 * this bool is all that will be needed.
 */
const allowV1PluginsFallback bool = true

/* defaultAPIVersion is the version of the plugin API for volume, network,
   IPAM and authz. This is a very stable API. When we update this API, then
   pluginType should include a version. e.g. &amp;quot;networkdriver/2.0&amp;quot;.
*/
const defaultAPIVersion string = &amp;quot;1.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;随着docker公司是的战略调整，推出了docker-CE和docker-EE之后，未来有些插件就可能要收费了，v2版本的插件都是在docker store中下载了，而这种插件在创建的时候都是打包成docker image，如果不开放源码的话，你即使pull下来插件也无法修改和导出的，&lt;strong&gt;docker plugin目前没有导出接口&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;真正要开发一个docker plugin还是得看&lt;a href=&#34;https://docs.docker.com/engine/extend/plugin_api/&#34;&gt;docker plugin API&lt;/a&gt;，这篇文档告诉我们：&lt;/p&gt;

&lt;h4 id=&#34;插件发现&#34;&gt;插件发现&lt;/h4&gt;

&lt;p&gt;当你开发好一个插件&lt;strong&gt;docker engine&lt;/strong&gt;怎么才能发现它们呢？有三种方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;.sock&lt;/strong&gt;，linux下放在/run/docker/plugins目录下，或该目录下的子目录比如&lt;a href=&#34;https://github.com/ClusterHQ/flocker&#34;&gt;flocker&lt;/a&gt;插件的&lt;code&gt;.sock&lt;/code&gt;文件放在&lt;code&gt;/run/docker/plugins/flocker/flocker.sock&lt;/code&gt;下&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.spec&lt;/strong&gt;，比如&lt;strong&gt;convoy&lt;/strong&gt;插件在&lt;code&gt;/etc/docker/plugins/convoy.spec&lt;/code&gt;定义，内容为&lt;code&gt;unix:///var/run/convoy/convoy.sock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.json&lt;/strong&gt;，比如&lt;strong&gt;infinit&lt;/strong&gt;插件在&lt;code&gt;/usr/lib/docker/plugins/infinit.json&lt;/code&gt;定义，内容为&lt;code&gt;{&amp;quot;Addr&amp;quot;:&amp;quot;https://infinit.sh&amp;quot;,&amp;quot;Name&amp;quot;:&amp;quot;infinit&amp;quot;}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文章中的其它部分&lt;strong&gt;貌似都过时&lt;/strong&gt;了，新的插件不是作为&lt;strong&gt;systemd&lt;/strong&gt;进程运行的，而是完全通过&lt;strong&gt;docker plugin&lt;/strong&gt;命令来管理的。&lt;/p&gt;

&lt;p&gt;当你使用&lt;strong&gt;docker plugin enable &lt;plugin_name&gt;&lt;/strong&gt;来激活了插件后，理应在&lt;code&gt;/run/docker/plugins&lt;/code&gt;目录下生成插件的&lt;code&gt;.sock&lt;/code&gt;文件，但是现在只有一个以runc ID命名的目录，这个问题下面有详细的叙述过程，你也可以跳过，直接看&lt;a href=&#34;https://github.com/docker/docker/issues/31723&#34;&gt;issue-31723&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/engine/extend/&#34;&gt;docker plugin管理&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;创建sshfs-volume-plugin&#34;&gt;创建sshfs volume plugin&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/docker/docker/blob/17.03.x/docs/extend/index.md#developing-a-plugin&#34;&gt;官方示例文档&lt;/a&gt;（这个文档有问题）&lt;a href=&#34;https://github.com/docker/docker/issues/29886&#34;&gt;docker-issue29886&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;官方以开发一个&lt;strong&gt;sshfs&lt;/strong&gt;的volume plugin为例。&lt;/p&gt;

&lt;p&gt;执行&lt;code&gt;docker plugin create&lt;/code&gt;命令的目录下必须包含以下内容：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;config.json&lt;/strong&gt;文件，里面是插件的配置信息，&lt;a href=&#34;https://github.com/docker/docker/blob/17.03.x/docs/extend/config.md&#34;&gt;plugin config参考文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rootfs&lt;/strong&gt;目录，插件镜像解压后的目录。v2版本的docker plugin都是以docker镜像的方式包装的。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/vieux/docker-volume-sshfs
$ cd docker-volume-sshfs
$ go get github.com/docker/go-plugins-helpers/volume
$ go build -o docker-volume-sshfs main.go  
$ docker build -t rootfsimage .
$ id=$(docker create rootfsimage true) # id was cd851ce43a403 when the image was created
$ sudo mkdir -p myplugin/rootfs
$ sudo docker export &amp;quot;$id&amp;quot; | sudo tar -x -C myplugin/rootfs
$ docker rm -vf &amp;quot;$id&amp;quot;
$ docker rmi rootfsimage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到&lt;strong&gt;sshfs&lt;/strong&gt;的Dockerfile是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM alpine

RUN apk update &amp;amp;&amp;amp; apk add sshfs

RUN mkdir -p /run/docker/plugins /mnt/state /mnt/volumes

COPY docker-volume-sshfs docker-volume-sshfs

CMD [&amp;quot;docker-volume-sshfs&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上是编译好的可执行文件复制到alpine linux容器中运行。&lt;/p&gt;

&lt;p&gt;编译rootfsimage镜像的过程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t rootfsimage .
Sending build context to Docker daemon 11.71 MB
Step 1/5 : FROM alpine
 ---&amp;gt; 4a415e366388
Step 2/5 : RUN apk update &amp;amp;&amp;amp; apk add sshfs
 ---&amp;gt; Running in 1551ecc1c847
fetch http://dl-cdn.alpinelinux.org/alpine/v3.5/main/x86_64/APKINDEX.tar.gz
fetch http://dl-cdn.alpinelinux.org/alpine/v3.5/community/x86_64/APKINDEX.tar.gz
v3.5.2-2-ge626ce8c3c [http://dl-cdn.alpinelinux.org/alpine/v3.5/main]
v3.5.1-71-gc7bb9a04f0 [http://dl-cdn.alpinelinux.org/alpine/v3.5/community]
OK: 7959 distinct packages available
(1/10) Installing openssh-client (7.4_p1-r0)
(2/10) Installing fuse (2.9.7-r0)
(3/10) Installing libffi (3.2.1-r2)
(4/10) Installing libintl (0.19.8.1-r0)
(5/10) Installing libuuid (2.28.2-r1)
(6/10) Installing libblkid (2.28.2-r1)
(7/10) Installing libmount (2.28.2-r1)
(8/10) Installing pcre (8.39-r0)
(9/10) Installing glib (2.50.2-r0)
(10/10) Installing sshfs (2.8-r0)
Executing busybox-1.25.1-r0.trigger
Executing glib-2.50.2-r0.trigger
OK: 11 MiB in 21 packages
 ---&amp;gt; 1a73c501f431
Removing intermediate container 1551ecc1c847
Step 3/5 : RUN mkdir -p /run/docker/plugins /mnt/state /mnt/volumes
 ---&amp;gt; Running in 032af3b2595a
 ---&amp;gt; 30c7e8463e96
Removing intermediate container 032af3b2595a
Step 4/5 : COPY docker-volume-sshfs docker-volume-sshfs
 ---&amp;gt; a924c6fcc1e4
Removing intermediate container ffc5e3c97707
Step 5/5 : CMD docker-volume-sshfs
 ---&amp;gt; Running in 0dc938fe4f4e
 ---&amp;gt; 0fd2e3d94860
Removing intermediate container 0dc938fe4f4e
Successfully built 0fd2e3d94860
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写&lt;code&gt;config.json&lt;/code&gt;文档&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Json&#34;&gt;{
    &amp;quot;description&amp;quot;: &amp;quot;sshFS plugin for Docker&amp;quot;,
    &amp;quot;documentation&amp;quot;: &amp;quot;https://docs.docker.com/engine/extend/plugins/&amp;quot;,
    &amp;quot;entrypoint&amp;quot;: [
        &amp;quot;/docker-volume-sshfs&amp;quot;
    ],
    &amp;quot;env&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;DEBUG&amp;quot;,
            &amp;quot;settable&amp;quot;: [
                &amp;quot;value&amp;quot;
            ],
            &amp;quot;value&amp;quot;: &amp;quot;0&amp;quot;
        }
    ],
    &amp;quot;interface&amp;quot;: {
        &amp;quot;socket&amp;quot;: &amp;quot;sshfs.sock&amp;quot;,
        &amp;quot;types&amp;quot;: [
            &amp;quot;docker.volumedriver/1.0&amp;quot;
        ]
    },
    &amp;quot;linux&amp;quot;: {
        &amp;quot;capabilities&amp;quot;: [
            &amp;quot;CAP_SYS_ADMIN&amp;quot;
        ],
        &amp;quot;devices&amp;quot;: [
            {
                &amp;quot;path&amp;quot;: &amp;quot;/dev/fuse&amp;quot;
            }
        ]
    },
    &amp;quot;mounts&amp;quot;: [
        {
            &amp;quot;destination&amp;quot;: &amp;quot;/mnt/state&amp;quot;,
            &amp;quot;options&amp;quot;: [
                &amp;quot;rbind&amp;quot;
            ],
            &amp;quot;source&amp;quot;: &amp;quot;/var/lib/docker/plugins/&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;bind&amp;quot;
        }
    ],
    &amp;quot;network&amp;quot;: {
        &amp;quot;type&amp;quot;: &amp;quot;host&amp;quot;
    },
    &amp;quot;propagatedmount&amp;quot;: &amp;quot;/mnt/volumes&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该插件使用host网络类型，使用/run/docker/plugins/sshfs.sock接口与docker engine通信。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意官网上的这个文档有问题，config.json与代码里的不符，尤其是Entrypoint的二进制文件的位置不对。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意&lt;strong&gt;socket&lt;/strong&gt;配置的地址不要写详细地址，默认会在/run/docker/plugins目录下生成socket文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;创建plugin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;docker plugin create &amp;lt;plugin_name&amp;gt; /path/to/plugin/data/&lt;/code&gt;命令创建插件。&lt;/p&gt;

&lt;p&gt;具体到sshfs插件，在myplugin目录下使用如下命令创建插件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker plugin create jimmmysong/sshfs:latest .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在就可以看到刚创建的插件了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker plugin ls
ID                  NAME                 DESCRIPTION               ENABLED
8aa1f6098fca        jimmysong/sshfs:latest   sshFS plugin for Docker   true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;push plugin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先登录你的docker hub账户，然后使用&lt;code&gt;docker plugin push jimmysong/sshfs:latest&lt;/code&gt;即可以推送docker plugin到docker hub中。&lt;/p&gt;

&lt;p&gt;目前推送到&lt;strong&gt;harbor&lt;/strong&gt;镜像仓库有问题，报错信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;c08c951b53b7: Preparing 
denied: requested access to the resource is denied
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;已给harbor提&lt;a href=&#34;https://github.com/vmware/harbor/issues/1532&#34;&gt;issue-1532&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;plugin的使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有发现了个问题&lt;a href=&#34;https://github.com/docker/docker/issues/31723&#34;&gt;docker issue-31723&lt;/a&gt;，使用plugin创建volume的时候居然找不到&lt;code&gt;sshfs.sock&lt;/code&gt;文件！😢刚开始手动创建plugin的时候测试了下是正常的，不知道为啥弄到这台测试机器上出问题了。&lt;/p&gt;

&lt;h3 id=&#34;关于docker-plugin-enable失败的问题&#34;&gt;关于docker plugin enable失败的问题&lt;/h3&gt;

&lt;p&gt;当docker  plugin创建成功并enable的时候docker并没有报错，这与docker plugin的&lt;strong&gt;activate&lt;/strong&gt;机制有关，只有当你最终使用该plugin的时候才会激活它。&lt;/p&gt;

&lt;p&gt;使用&lt;strong&gt;sshfs&lt;/strong&gt;插件创建volume。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker volume create -d jimmysong/sshfs --name sshvolume -o sshcmd=1.2.3.4:/remote -o password=password
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;报错如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error response from daemon: create sshvolume: Post http://%2Frun%2Fdocker%2Fplugins%2F8f7b8f931b38a4ef53d0e4f8d738e26e8f10ef8bd26c8244f4b8dcc7276b685f%2Fsshfs.sock/VolumeDriver.Create: dial unix /run/docker/plugins/8f7b8f931b38a4ef53d0e4f8d738e26e8f10ef8bd26c8244f4b8dcc7276b685f/sshfs.sock: connect: no such file or directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Docker daemon在enable这个插件的时候会寻找这个&lt;strong&gt;.sock&lt;/strong&gt;文件，然后在自己的plugindb中注册它，相关代码在这个文件里：&lt;a href=&#34;https://github.com/docker/docker/blob/17.03.x/plugin/manager_linux.go&#34;&gt;https://github.com/docker/docker/blob/17.03.x/plugin/manager_linux.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;相关代码片段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func (pm *Manager) enable(p *v2.Plugin, c *controller, force bool) error {
	...
	return pm.pluginPostStart(p, c)
}

func (pm *Manager) pluginPostStart(p *v2.Plugin, c *controller) error {
    //这里需要获取.sock文件的地址 
    //pm.conifg.ExecRoot就是/run/docker/plugins
    //p.GetID()返回的就是很长的那串plugin ID
	sockAddr := filepath.Join(pm.config.ExecRoot, p.GetID(), p.GetSocket())
	client, err := plugins.NewClientWithTimeout(&amp;quot;unix://&amp;quot;+sockAddr, nil, c.timeoutInSecs)
	if err != nil {
		c.restart = false
		shutdownPlugin(p, c, pm.containerdClient)
		return errors.WithStack(err)
	}

	p.SetPClient(client)

	maxRetries := 3
	var retries int
	for {
		time.Sleep(3 * time.Second)
		retries++

		if retries &amp;gt; maxRetries {
			logrus.Debugf(&amp;quot;error net dialing plugin: %v&amp;quot;, err)
			c.restart = false
			shutdownPlugin(p, c, pm.containerdClient)
			return err
		}

		// net dial into the unix socket to see if someone&#39;s listening.
		conn, err := net.Dial(&amp;quot;unix&amp;quot;, sockAddr)
		if err == nil {
			conn.Close()
			break
		}
	}
	pm.config.Store.SetState(p, true)
	pm.config.Store.CallHandler(p)

	return pm.save(p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意这段代码里的&lt;strong&gt;sockAddr := filepath.Join(pm.config.ExecRoot, p.GetID(), p.GetSocket())&lt;/strong&gt;，我在上面添加了注释。&lt;/p&gt;

&lt;p&gt;这个&lt;strong&gt;.sock&lt;/strong&gt;文件应该有docker plugin来生成，具体怎样生成的呢？还以&lt;strong&gt;docker-volume-ssh&lt;/strong&gt;这个插件为例。&lt;/p&gt;

&lt;p&gt;整个项目就一个&lt;strong&gt;main.go&lt;/strong&gt;文件，里面最后一行生成了&lt;strong&gt;/run/docker/plugins/sshfs.sock&lt;/strong&gt;这个sock。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;logrus.Error(h.ServeUnix(socketAddress, 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这行代码调用&lt;strong&gt;docker/go-plugin-helpers/sdk/handler.go&lt;/strong&gt;中的:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// ServeUnix makes the handler to listen for requests in a unix socket.
// It also creates the socket file on the right directory for docker to read.
func (h Handler) ServeUnix(addr string, gid int) error {
	l, spec, err := newUnixListener(addr, gid)
	if err != nil {
		return err
	}
	if spec != &amp;quot;&amp;quot; {
		defer os.Remove(spec)
	}
	return h.Serve(l)
}

// Serve sets up the handler to serve requests on the passed in listener
func (h Handler) Serve(l net.Listener) error {
	server := http.Server{
		Addr:    l.Addr().String(),
		Handler: h.mux,
	}
	return server.Serve(l)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;//unix_listener_unsupoorted.go
func newUnixListener(pluginName string, gid int) (net.Listener, string, error) {
	return nil, &amp;quot;&amp;quot;, errOnlySupportedOnLinuxAndFreeBSD
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看了上面这这些，你看出socket文件是怎么创建的吗？&lt;/p&gt;

&lt;p&gt;这又是一个&lt;a href=&#34;https://github.com/vieux/docker-volume-sshfs/issues/19&#34;&gt;issue-19&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果你修改&lt;strong&gt;config.json&lt;/strong&gt;文件，将其中的&lt;strong&gt;interfaces - socket&lt;/strong&gt;指定为&lt;code&gt;/run/docker/plugins/sshfs.sock&lt;/code&gt;然后创建plugin，则能成功生成socket文件，但是当你enable它的时候又会报错&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Error response from daemon: Unix socket path &amp;quot;/run/docker/plugins/ac34f7b246ac6c029023b1ebd48e166eadcdd2c9d0cc682cadca0336951d72f7/run/docker/plugins/sshfs.sock&amp;quot; is too long
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从docker daemon的日志里可以看到详细报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Mar 13 17:15:20 sz-pg-oam-docker-test-001.tendcloud.com dockerd[51757]: time=&amp;quot;2017-03-13T17:15:20+08:00&amp;quot; level=info msg=&amp;quot;standard_init_linux.go:178: exec user process caused \&amp;quot;no such file or directory\&amp;quot;&amp;quot; plugin=ac34f7b246ac6c029023b1ebd48e166eadcdd2c9d0cc682cadca0336951d72f7
Mar 13 17:15:20 sz-pg-oam-docker-test-001.tendcloud.com dockerd[51757]: time=&amp;quot;2017-03-13T17:15:20.321277088+08:00&amp;quot; level=error msg=&amp;quot;Sending SIGTERM to plugin failed with error: rpc error: code = 2 desc = no such process&amp;quot;
Mar 13 17:15:20 sz-pg-oam-docker-test-001.tendcloud.com dockerd[51757]: time=&amp;quot;2017-03-13T17:15:20.321488680+08:00&amp;quot; level=error msg=&amp;quot;Handler for POST /v1.26/plugins/sshfs/enable returned error: Unix socket path \&amp;quot;/run/docker/plugins/ac34f7b246ac6c029023b1ebd48e166eadcdd2c9d0cc682cadca0336951d72f7/run/docker/plugins/sshfs.sock\&amp;quot; is too long\ngithub.com/docker/docker/plugin.(*Manager).pluginPostStart\n\t/root/rpmbuild/BUILD/docker-engine/.gopath/src/github.com/docker/docker/plugin/manager_linux.go:84\ngithub.com/docker/docker/plugin.(*Manager).enable\n\t/root/rpmbuild/BUILD/docker-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正好验证了上面的&lt;strong&gt;enable&lt;/strong&gt;代码，docker默认是到&lt;code&gt;/run/docker/plugins&lt;/code&gt;目录下找&lt;strong&gt;sshfs.sock&lt;/strong&gt;这个文件的。&lt;/p&gt;

&lt;p&gt;我在docker daemon中发现一个很诡异的错误，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Mar 13 17:29:41 sz-pg-oam-docker-test-001.tendcloud.com dockerd[51757]: time=&amp;quot;2017-03-13T17:29:41+08:00&amp;quot; level=info msg=&amp;quot;standard_init_linux.go:178: exec user process caused \&amp;quot;no such file or directory\&amp;quot;&amp;quot; plugin=85760810b4850009fc965f5c20d8534dc9aba085340a2ac0b4b9167a6fef7d53
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我查看了下&lt;code&gt;github.com/libnetwork/vendor/github.com/opencontainers/run/libcontainer/standard_init_linux.go&lt;/code&gt;文件，这个那个文件只有114行，见这里&lt;a href=&#34;https://github.com/docker/libnetwork/blob/master/vendor/github.com/opencontainers/runc/libcontainer/standard_init_linux.go&#34;&gt;https://github.com/docker/libnetwork/blob/master/vendor/github.com/opencontainers/runc/libcontainer/standard_init_linux.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;但是在&lt;strong&gt;opencontainers&lt;/strong&gt;的github项目里才有那么多行，见这里：&lt;a href=&#34;https://github.com/opencontainers/runc/blob/master/libcontainer/standard_init_linux.go&#34;&gt;https://github.com/opencontainers/runc/blob/master/libcontainer/standard_init_linux.go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个报错前后的函数是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// PR_SET_NO_NEW_PRIVS isn&#39;t exposed in Golang so we define it ourselves copying the value
// the kernel
const PR_SET_NO_NEW_PRIVS = 0x26

func (l *linuxStandardInit) Init() error {
	if !l.config.Config.NoNewKeyring {
		ringname, keepperms, newperms := l.getSessionRingParams()

		// do not inherit the parent&#39;s session keyring
		sessKeyId, err := keys.JoinSessionKeyring(ringname)
		if err != nil {
			return err
		}
		// make session keyring searcheable
		if err := keys.ModKeyringPerm(sessKeyId, keepperms, newperms); err != nil {
			return err
		}
	}

...
	}
	if l.config.Config.Seccomp != nil &amp;amp;&amp;amp; l.config.NoNewPrivileges {
         //下面这行是第178行
		if err := seccomp.InitSeccomp(l.config.Config.Seccomp); err != nil {
			return newSystemErrorWithCause(err, &amp;quot;init seccomp&amp;quot;)
		}
	}
	// close the statedir fd before exec because the kernel resets dumpable in the wrong order
	// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318
	syscall.Close(l.stateDirFD)
	if err := syscall.Exec(name, l.config.Args[0:], os.Environ()); err != nil {
		return newSystemErrorWithCause(err, &amp;quot;exec user process&amp;quot;)
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结论&#34;&gt;&lt;del&gt;结论&lt;/del&gt;&lt;/h2&gt;

&lt;p&gt;&lt;del&gt;到此了问题还没解决。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;del&gt;问题的关键是执行&lt;strong&gt;docker create plugin&lt;/strong&gt;之后&lt;strong&gt;.sock&lt;/strong&gt;文件创建到哪里去了？为什么在&lt;strong&gt;config.json&lt;/strong&gt;指定成&lt;code&gt;/run/docker/plugins/sshfs.sock&lt;/code&gt;就可以在指定的目录下创建出.sock文件，说明&lt;strong&gt;创建socket的定义和get socket时寻找的路径不一样&lt;/strong&gt;，创建socket时就是固定在/run/docker/plugins目录下创建，而enable plugin的时候，Get socket的时候还要加上docker plugin的ID，可是按照官网的配置在本地create plugin后并没有在/run/docker/plugins目录下生成插件的socket文件，直到enable插件的时候才会生成以plugin ID命名的目录，但是socket文件没有！☹️&lt;/del&gt;&lt;/p&gt;

&lt;h2 id=&#34;问题解决&#34;&gt;问题解决&lt;/h2&gt;

&lt;p&gt;之所以出现上面的那些问题，是因为create docker plugin的时候有问题，也就是那个二进制文件有问题，我在&lt;strong&gt;Mac&lt;/strong&gt;上build的image，而且还没有用&lt;strong&gt;Dockerfile.dev&lt;/strong&gt;这个专门用来搭建二进制文件编译环境的Dockerfile来创建golang的编译环境，虽然docker plugin是创建成功了，但是当docker plugin enable的时候，这个热紧张文件不能正确的运行，所以就没能生成&lt;strong&gt;sshfs.sock&lt;/strong&gt;文件。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;请在Linux环境下使用&lt;strong&gt;make all&lt;/strong&gt;命令来创建plugin。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Docker 17.03-CE create plugin源码解析</title>
      <link>http://rootsongjc.github.io/blogs/docker-create-plugin/</link>
      <pubDate>Wed, 15 Mar 2017 12:09:26 +0800</pubDate>
      
      <guid>http://rootsongjc.github.io/blogs/docker-create-plugin/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://olz1di9xf.bkt.clouddn.com/20160403050.jpg&#34; alt=&#34;故宫博物院&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;（题图：故宫 Apr 3,2016）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;继续上一篇&lt;a href=&#34;http://rootsongjc.github.io/blogs/docker-plugin-develop/&#34;&gt;Docker17.03-CE插件开发的🌰&lt;/a&gt;，今天来看下&lt;strong&gt;docker create plugin&lt;/strong&gt;的源码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;cli/command/plugin/create.go&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Docker命令行&lt;code&gt;docker plugin create&lt;/code&gt;调用的，使用的是&lt;a href=&#34;http://github.com/spf13/cobra&#34;&gt;cobra&lt;/a&gt;，这个命令行工具开发包很好用，推荐下。&lt;/p&gt;

&lt;p&gt;执行这两个函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func newCreateCommand(dockerCli *command.DockerCli) *cobra.Command 
//调用下面的函数，拼装成URL调用RESTful API接口
func runCreate(dockerCli *command.DockerCli, options pluginCreateOptions) error {
  ...
  if err = dockerCli.Client().PluginCreate(ctx, createCtx, createOptions); err != nil {
		return err
	}
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;strong&gt;api/server/router/plugin/plugin_routes.go&lt;/strong&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (pr *pluginRouter) createPlugin(ctx context.Context, w http.ResponseWriter, r *http.Request, vars map[string]string) error {
  ...
  if err := pr.backend.CreateFromContext(ctx, r.Body, options); err != nil {
		return err
	}
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;createPlugin&lt;/strong&gt;这个方法定义在api/server/route/plugin/backen.go的&lt;strong&gt;Backend&lt;/strong&gt;接口中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PluginCreate&lt;/strong&gt;这个方法定义在docker/docker/client/Interface.go的&lt;strong&gt;PluginAPIClient&lt;/strong&gt;接口中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker/client/plugin_create.go&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PluginCreate creates a plugin
func (cli *Client) PluginCreate(ctx context.Context, createContext io.Reader, createOptions types.PluginCreateOptions) error {
	headers := http.Header(make(map[string][]string))
	headers.Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/x-tar&amp;quot;)

	query := url.Values{}
	query.Set(&amp;quot;name&amp;quot;, createOptions.RepoName)

	resp, err := cli.postRaw(ctx, &amp;quot;/plugins/create&amp;quot;, query, createContext, headers)
	if err != nil {
		return err
	}
	ensureReaderClosed(resp)
	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;plugin在后端接收到请求后会执行下面的方法。最终&lt;strong&gt;create plugin&lt;/strong&gt;的实现在plugin/backend_linux.go下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// CreateFromContext creates a plugin from the given pluginDir which contains
// both the rootfs and the config.json and a repoName with optional tag.
func (pm *Manager) CreateFromContext(ctx context.Context, tarCtx io.ReadCloser, options *types.PluginCreateOptions) (err error) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至于docker create plugin时docker后台究竟做了什么，就看👆那个文件。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>