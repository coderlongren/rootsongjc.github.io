<!DOCTYPE html>
<html class="no-js" lang="en-US" prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#">
<head>
	<meta name="generator" content="Hugo 0.18.1" />
    <meta charset="utf-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="description" content="">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="keywords" content="">

 
<meta property="og:type" content="article"/>
<meta property="og:description" content=""/>
<meta property="og:title" content="Jimmy Song&#39;s Blog : rootsongjc.github.io"/>
<meta property="og:site_name" content="rootsongjc is Jimmy Song"/>
<meta property="og:image" content="" />
<meta property="og:image:type" content="image/jpeg" />
<meta property="og:image:width" content="" />
<meta property="og:image:height" content="" />
<meta property="og:url" content="http://rootsongjc.github.io/">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2017-04-11"/>
<meta property="article:modified_time" content="2017-04-11"/>





<meta name="twitter:card" content="summary">

<meta name="twitter:site" content="@rootsongjc">
<meta name="twitter:title" content="Jimmy Song&#39;s Blog : rootsongjc.github.io">
<meta name="twitter:creator" content="@rootsongjc">
<meta name="twitter:description" content="">
<meta name="twitter:image:src" content="">
<meta name="twitter:domain" content="rootsongjc.github.io">


    <base href="http://rootsongjc.github.io/">
    <title>Jimmy Song&#39;s Blog</title>
    <link rel="canonical" href="http://rootsongjc.github.io/">
    <link href="http://rootsongjc.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Jimmy Song&#39;s Blog" />

    
<link rel="stylesheet" href="/static/css/style.css">
<script src="https://yandex.st/highlightjs/8.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://yandex.st/highlightjs/8.0/styles/default.min.css">
<script>hljs.initHighlightingOnLoad();</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?11f7d254cfa4e0ca44b175c66d379ecc";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

</head>
<body lang="en">

<header id="header">
    <figure>
      <a href="/" border=0 id="logolink"><div class="icon-octocat" id="logo"> </div></a>
    </figure>
    <div id="byline">by Jimmy Song</div>
    <nav id="nav">
            <ul id="mainnav">
            <li>
                <a href="/blogs/">
                <span class="icon"> <i aria-hidden="true" class="icon-quill"></i></span>
                <span> blogs </span>
            </a>
            </li>
            <li>
            <a href="/projects/">
                <span class="icon"> <i aria-hidden="true" class="icon-console"></i></span>
                <span> projects </span>
            </a>
            </li>
            <li>
            <a href="/talks/">
                <span class="icon"> <i aria-hidden="true" class="icon-stats"></i></span>
                <span> talks </span>
            </a>
            </li>
            <li>
            <a href="http://www.linkedin.com/in/rootsongjc">
                <span class="icon"> <i aria-hidden="true" class="icon-linkedin"></i></span>
                <span> me </span>
            </a>
            </li>
        </ul>

            <ul id="social">
            <li id="share">
                <span class="icon icon-bubbles"> </span>
                <span class="title"> share </span>
                <div class="dropdown share">
                    <ul class="social">
                      <li> <a href="https://twitter.com/intent/tweet?status=Jimmy%20Song%27s%20Blog-http%3a%2f%2frootsongjc.github.io%2f" target="_blank" title="Follow me on Twitter" class="twitter"><span class="icon icon-twitter"></span>Twitter</a> </li>
                        <li> <a href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2frootsongjc.github.io%2f" target="_blank" title="Join me on Facebook" class="facebook"><span class="icon icon-facebook"></span>Facebook</a> </li>
                        <li> <a href="https://plus.google.com/share?url=http%3a%2f%2frootsongjc.github.io%2f" target="_blank" title="Google+" class="googleplus"><span class="icon icon-google-plus"></span>Google+</a> </li>
                        <li> <a href="http://www.linkedin.com/shareArticle?mini=true&url=http%3a%2f%2frootsongjc.github.io%2f&title=Jimmy%20Song%27s%20Blog&source=spf13" target="_blank" title="LinkedIn" class="linkedin"><span class="icon icon-linkedin"></span>LinkedIn</a> </li>
                        <li> <a href="http://del.icio.us/post?url=http%3a%2f%2frootsongjc.github.io%2f" target="_blank" title="Delicious" class="delicious"><span class="icon icon-delicious"></span>Delicious</a> </li>
                        <li> <a href="http://www.reddit.com/submit?url=http%3a%2f%2frootsongjc.github.io%2f" target="_blank" title="Reddit" class="reddit"><span class="icon icon-reddit"></span>Reddit</a> </li>
                    </ul>
                    <span class="subcount">sharing is caring</span>
                </div>
            </li>
            <li id="follow">
                <span class="icon icon-rocket"> </span>
                <span class="title"> follow </span>
                <div class="dropdown follow">
                    <ul class="social">
                        <li> <a href="http://www.twitter.com/rootsongjc" target="_blank" title="Follow me on Twitter" class="twitter"><span class="icon icon-twitter"></span>Twitter</a> </li>
                        <li> <a href="http://www.facebook.com/rootsongjc" target="_blank" title="Join me on Facebook" class="facebook"><span class="icon icon-facebook"></span>Facebook</a> </li>
                        <li> <a href="http://www.linkedin.com/in/rootsongjc" target="_blank" title="LinkedIn" class="linkedin"><span class="icon icon-linkedin"></span>LinkedIn</a> </li>
                        <li> <a href="http://github.com/rootsongjc" target="_blank" title="GitHub" class="github"><span class="icon icon-github"></span>GitHub</a> </li>
                        <li> <a href="https://www.douban.com/people/deamonj/" target="_blank" title="豆瓣" class="facebook"><span class="icon icon-idea"></span>Douban</a> </li>
                        <li> <a href="https://tuchong.com/1425795/" target="_blank" title="图虫" class="github"><span class="icon icon-cc-2"></span>Tuchong</a> </li>                    </ul>
                    <span class="subcount">join 10k+ subscribers &amp; followers</span>
                </div>
            </li>
          </ul>

    </nav>
</header>


<section id="main">
  <div>
      <h1 id="title">Jimmy Song&#39;s Blog</h1>
    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/kubernetes-node-installation/">Kubernetes node节点安装 </a> </h2>
      <div class="post-meta">Tue, Apr 11, 2017 </div>
    </header>

    （题图：太阳宫桥@北京东北三环 Dec 11,2016）
前言 这是和我一步步部署kubernetes集群项目((fork自opsnull))中的一篇文章，下文是结合我之前部署kubernetes的过程产生的kuberentes环境，部署node节点上的kube-proxy和kubelet，同时对之前部署的flannel改造。
安装环境配置信息
 CentOS7.2.1511 Docker 1.12.5 Flannel 0.7 Kubernetes 1.6.0  部署kubernetes node节点 kubernetes node 节点包含如下组件：
 Flanneld：参考我之前写的文章Kubernetes基于Flannel的网络配置，之前没有配置TLS，现在需要在serivce配置文件中增加TLS配置。 Docker1.12.5：docker的安装很简单，这里也不说了。 kubelet kube-proxy  下面着重讲kubelet和kube-proxy的安装，同时还要将之前安装的flannel集成TLS验证。
目录和文件 我们再检查一下三个节点上，经过前几步操作生成的配置文件。
$ ls /etc/kubernetes/ssl admin-key.pem admin.pem ca-key.pem ca.pem kube-proxy-key.pem kube-proxy.pem kubernetes-key.pem kubernetes.pem $ ls /etc/kubernetes/ apiserver bootstrap.kubeconfig config controller-manager kubelet kube-proxy.kubeconfig proxy scheduler ssl token.csv  配置Flanneld 参考我之前写的文章Kubernetes基于Flannel的网络配置，之前没有配置TLS，现在需要在serivce配置文件中增加TLS配置。
service配置文件/usr/lib/systemd/system/flanneld.service。
[Unit] Description=Flanneld overlay address etcd agent After=network.target After=network-online.target Wants=network-online.target After=etcd.service Before=docker.service [Service] Type=notify EnvironmentFile=/etc/sysconfig/flanneld EnvironmentFile=-/etc/sysconfig/docker-network ExecStart=/usr/bin/flanneld-start $FLANNEL_OPTIONS ExecStartPost=/usr/libexec/flannel/mk-docker-opts.
    <footer>
        <a href='http://rootsongjc.github.io/blogs/kubernetes-node-installation/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/kubernetes-ha-master-installation/">Kubernetes高可用master节点安装 </a> </h2>
      <div class="post-meta">Tue, Apr 11, 2017 </div>
    </header>

    （题图：鬼见愁@北京西山 Sep 14,2015）
前言 这是和我一步步部署kubernetes集群项目((fork自opsnull))中的一篇文章，下文是结合我之前部署kubernetes的过程产生的kuberentes环境，部署master节点的kube-apiserver、kube-controller-manager和kube-scheduler的过程。
高可用kubernetes master节点安装 kubernetes master 节点包含的组件：
 kube-apiserver kube-scheduler kube-controller-manager  目前这三个组件需要部署在同一台机器上。
 kube-scheduler、kube-controller-manager 和 kube-apiserver 三者的功能紧密相关； 同时只能有一个 kube-scheduler、kube-controller-manager 进程处于工作状态，如果运行多个，则需要通过选举产生一个 leader；  本文档记录部署一个三个节点的高可用 kubernetes master 集群步骤。（后续创建一个 load balancer 来代理访问 kube-apiserver 的请求）
TLS 证书文件 pem和token.csv证书文件我们在TLS证书和秘钥这一步中已经创建过了。我们再检查一下。
$ ls /etc/kubernetes/ssl admin-key.pem admin.pem ca-key.pem ca.pem kube-proxy-key.pem kube-proxy.pem kubernetes-key.pem kubernetes.pem  下载最新版本的二进制文件 有两种下载方式
方式一
从 github release 页面 下载发布版 tarball，解压后再执行下载脚本
$ wget https://github.com/kubernetes/kubernetes/releases/download/v1.6.0/kubernetes.tar.gz $ tar -xzvf kubernetes.tar.gz ... $ cd kubernetes $ .
    <footer>
        <a href='http://rootsongjc.github.io/blogs/kubernetes-ha-master-installation/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/kubernetes-etcd-ha-config/">Kubernetes安装之etcd高可用配置 </a> </h2>
      <div class="post-meta">Tue, Apr 11, 2017 </div>
    </header>

    （题图：北京夜景@西山）
前言 这是和我一步步部署kubernetes集群项目((fork自opsnull))中的一篇文章，下文是结合我之前部署kubernetes的过程产生的kuberentes环境，生成kubeconfig文件的过程。
创建高可用 etcd 集群 kuberntes 系统使用 etcd 存储所有数据，本文档介绍部署一个三节点高可用 etcd 集群的步骤，这三个节点复用 kubernetes master 机器，分别命名为sz-pg-oam-docker-test-001.tendcloud.com、sz-pg-oam-docker-test-002.tendcloud.com、sz-pg-oam-docker-test-003.tendcloud.com：
 sz-pg-oam-docker-test-001.tendcloud.com：172.20.0.113 sz-pg-oam-docker-test-002.tendcloud.com：172.20.0.114 sz-pg-oam-docker-test-003.tendcloud.com：172.20.0.115  TLS 认证文件 需要为 etcd 集群创建加密通信的 TLS 证书，这里复用以前创建的 kubernetes 证书
$ cp ca.pem kubernetes-key.pem kubernetes.pem /etc/kubernetes/ssl   kubernetes 证书的 hosts 字段列表中包含上面三台机器的 IP，否则后续证书校验会失败；  下载二进制文件 到 https://github.com/coreos/etcd/releases 页面下载最新版本的二进制文件
$ https://github.com/coreos/etcd/releases/download/v3.1.5/etcd-v3.1.5-linux-amd64.tar.gz $ tar -xvf etcd-v3.1.4-linux-amd64.tar.gz $ sudo mv etcd-v3.1.4-linux-amd64/etcd* /root/local/bin  创建 etcd 的 systemd unit 文件 注意替换 ETCD_NAME 和 INTERNAL_IP 变量的值；
    <footer>
        <a href='http://rootsongjc.github.io/blogs/kubernetes-etcd-ha-config/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/kubernetes-create-kubeconfig/">Kubernetes安装之创建kubeconfig文件 </a> </h2>
      <div class="post-meta">Tue, Apr 11, 2017 </div>
    </header>

    (题图：北海公园 May 8,2016)
前言 这是和我一步步部署kubernetes集群项目((fork自opsnull))中的一篇文章，下文是结合我之前部署kubernetes的过程产生的kuberentes环境，生成kubeconfig文件的过程。 kubelet、kube-proxy 等 Node 机器上的进程与 Master 机器的 kube-apiserver 进程通信时需要认证和授权； kubernetes 1.4 开始支持由 kube-apiserver 为客户端生成 TLS 证书的 TLS Bootstrapping 功能，这样就不需要为每个客户端生成证书了；该功能当前仅支持为 kubelet 生成证书。
创建 TLS Bootstrapping Token Token auth file
Token可以是任意的包涵128 bit的字符串，可以使用安全的随机数发生器生成。
export BOOTSTRAP_TOKEN=$(head -c 16 /dev/urandom | od -An -t x | tr -d ' ') cat &gt; token.csv &lt;&lt;EOF ${BOOTSTRAP_TOKEN},kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot; EOF   后三行是一句，直接复制上面的脚本运行即可。
 将token.csv发到所有机器（Master 和 Node）的 /etc/kubernetes/ 目录。
$cp token.csv /etc/kubernetes/  创建 kubelet bootstrapping kubeconfig 文件 $ cd /etc/kubernetes $ export KUBE_APISERVER=&quot;https://172.
    <footer>
        <a href='http://rootsongjc.github.io/blogs/kubernetes-create-kubeconfig/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/fabric8-introduction/">开源微服务管理平台fabric8简介 </a> </h2>
      <div class="post-meta">Mon, Apr 10, 2017 </div>
    </header>

    前言 无意中发现Fabric8这个对于Java友好的开源微服务管理平台。
其实这在这里发现的Achieving CI/CD with Kubernetes（by Ramit Surana,on February 17, 2017），其实是先在slideshare上看到的，pdf可以在此下载，大小2.04M。
大家可能以前听过一个叫做fabric的工具，那是一个 Python (2.5-2.7) 库和命令行工具，用来流水线化执行 SSH 以部署应用或系统管理任务。所以大家不要把fabric8跟fabric搞混，虽然它们之间有一些共同点，但两者完全不是同一个东西，fabric8不是fabric的一个版本。Fabric是用python开发的，fabric8是java开发的。
如果你想了解简化Fabric可以看它的中文官方文档。
Fabric8简介 fabric8是一个开源集成开发平台，为基于Kubernetes和Jenkins的微服务提供持续发布。
使用fabric可以很方便的通过Continuous Delivery pipelines创建、编译、部署和测试微服务，然后通过Continuous Improvement和ChatOps运行和管理他们。
Fabric8微服务平台提供：
 Developer Console，是一个富web应用，提供一个单页面来创建、编辑、编译、部署和测试微服务。 Continuous Integration and Continous Delivery，使用 Jenkins with a Jenkins Workflow Library更快和更可靠的交付软件。 Management，集中式管理Logging、Metrics, ChatOps、Chaos Monkey，使用Hawtio和Jolokia管理Java Containers。 Integration Integration Platform As A Service with deep visualisation of your Apache Camel integration services, an API Registry to view of all your RESTful and SOAP APIs and Fabric8 MQ provides Messaging As A Service based on Apache ActiveMQ。 Java Tools 帮助Java应用使用Kubernetes:  Maven Plugin for working with Kubernetes ，这真是极好的 Integration and System Testing of Kubernetes resources easily inside JUnit with Arquillian Java Libraries and support for CDI extensions for working with Kubernetes.
    <footer>
        <a href='http://rootsongjc.github.io/blogs/fabric8-introduction/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/kubernetes-tls-certificate/">Kubernetes安装之证书验证 </a> </h2>
      <div class="post-meta">Mon, Apr 10, 2017 </div>
    </header>

    （题图：铜牛@颐和园 Aug 25,2014）
前言 昨晚（Apr 9,2017）金山软件的opsnull发布了一个开源项目和我一步步部署kubernetes集群，下文是结合我之前部署kubernetes的过程打造的kubernetes环境和opsnull的文章创建 kubernetes 各组件 TLS 加密通信的证书和秘钥的实践。之前安装过程中一直使用的是非加密方式，一直到后来使用Fluentd和ElasticSearch收集Kubernetes集群日志时发现有权限验证问题，所以为了深入研究kubernentes。
Kubernentes中的身份验证 kubernetes 系统的各组件需要使用 TLS 证书对通信进行加密，本文档使用 CloudFlare 的 PKI 工具集 cfssl 来生成 Certificate Authority (CA) 和其它证书；
生成的 CA 证书和秘钥文件如下：
 ca-key.pem ca.pem kubernetes-key.pem kubernetes.pem kube-proxy.pem kube-proxy-key.pem admin.pem admin-key.pem  使用证书的组件如下：
 etcd：使用 ca.pem、kubernetes-key.pem、kubernetes.pem； kube-apiserver：使用 ca.pem、kubernetes-key.pem、kubernetes.pem； kubelet：使用 ca.pem； kube-proxy：使用 ca.pem、kube-proxy-key.pem、kube-proxy.pem； kubectl：使用 ca.pem、admin-key.pem、admin.pem；  kube-controller、kube-scheduler 当前需要和 kube-apiserver 部署在同一台机器上且使用非安全端口通信，故不需要证书。
安装 CFSSL 方式一：直接使用二进制源码包安装
$ wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 $ chmod +x cfssl_linux-amd64 $ sudo mv cfssl_linux-amd64 /root/local/bin/cfssl $ wget https://pkg.
    <footer>
        <a href='http://rootsongjc.github.io/blogs/kubernetes-tls-certificate/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/cloud-computing-architecture-practice/">《云计算技术架构与实践（第二版）》读后感 </a> </h2>
      <div class="post-meta">Sat, Apr 8, 2017 </div>
    </header>

    （题图：长江三峡大坝@湖北宜昌 Apr 6,2015）
前言 最近（2017年3月）友人推荐了一本书，是华为的工程师写的《云计算架构与实践第二版》，正好在网上找到了这本书的pdf，分享给大家，点这里下载，书是文字版的，大小13.04MB，除了章节顺序有点问题外没有其他什么问题。这是该书的第二版，第一版2014年9月出版，第二版2016年9月出版，第二版的编者团队居然有50人之多😓
第二版分享了华为在云计算核心竞争力构建与价值转换方面的经验与建议，并补充了业界在公有云、私有云、行业云以及电信网络云化商用落地与技术应用方面的成功优秀实践。增加了对Docker容器与微服务敏捷迭代、大数据与数据库云化、行业建模与机器学习算法、混合云与管理自动化编排、云生态建设等方面的介绍。
第1章 云计算的商业动力与技术趋势 ​
​
​
​
​
​
    <footer>
        <a href='http://rootsongjc.github.io/blogs/cloud-computing-architecture-practice/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/kubernetes-fluentd-elasticsearch-installation/">使用Fluentd和ElasticSearch收集Kubernetes集群日志 </a> </h2>
      <div class="post-meta">Fri, Apr 7, 2017 </div>
    </header>

    （题图：码头@古北水镇 Apr 30,2016）
前言 在安装好了Kubernetes集群、配置好了flannel网络、安装了Kubernetes Dashboard和配置Heapster监控插件后，还有一项重要的工作，为了调试和故障排查，还需要进行日志收集工作。
官方文档
Kubernetes Logging and Monitoring Cluster Activity
Logging Using Elasticsearch and Kibana：不过这篇文章是在GCE上配置的，参考价值不大。
容器日志的存在形式 目前容器日志有两种输出形式：
stdout,stderr标准输出
这种形式的日志输出我们可以直接使用docker logs查看日志，kubernetes集群中同样可以使用kubectl logs类似的形式查看日志。
日志文件记录
这种日志输出我们无法从以上方法查看日志内容，只能tail日志文件查看。
Fluentd介绍 Fluentd是使用Ruby编写的，通过在后端系统之间提供统一的日志记录层来从后端系统中解耦数据源。 此层允许开发人员和数据分析人员在生成日志时使用多种类型的日志。 统一的日志记录层可以让您和您的组织更好地使用数据，并更快地在您的软件上进行迭代。 也就是说fluentd是一个面向多种数据来源以及面向多种数据出口的日志收集器。另外它附带了日志转发的功能。
Fluentd收集的event由以下几个方面组成：
 Tag：字符串，中间用点隔开，如myapp.access Time：UNIX时间格式 Record：JSON格式  Fluentd特点  部署简单灵活 开源 经过验证的可靠性和性能 社区支持，插件较多 使用json格式事件格式 可拔插的架构设计 低资源要求 内置高可靠性  安装 查看cluster/addons/fluentd-elasticsearch插件目录，获取到需要用到的docker镜像名称。
$grep -rn &quot;gcr.io&quot; *.yaml es-controller.yaml:24: - image: gcr.io/google_containers/elasticsearch:v2.4.1-2 fluentd-es-ds.yaml:26: image: gcr.io/google_containers/fluentd-elasticsearch:1.22 kibana-controller.yaml:22: image: gcr.io/google_containers/kibana:v4.6.1-1  需要用到的镜像
 gcr.io/google_containers/kibana:v4.6.1-1 gcr.io/google_containers/elasticsearch:v2.4.1-2 gcr.
    <footer>
        <a href='http://rootsongjc.github.io/blogs/kubernetes-fluentd-elasticsearch-installation/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/kubernetes-configmap-introduction/">Kubernetes的ConfigMap解析 </a> </h2>
      <div class="post-meta">Thu, Apr 6, 2017 </div>
    </header>

    （题图：龙形灯笼@古北水镇 Apr 30,2016）
前言 为什么要翻译这篇文章，是因为我在使用Fluentd和ElasticSearch收集Kubernetes集群日志的时候遇到了需要修改镜像中配置的问题，fluent-plugin-kubernetes_metadata里的需要的td-agent.conf文件。
其实ConfigMap功能在Kubernetes1.2版本的时候就有了，许多应用程序会从配置文件、命令行参数或环境变量中读取配置信息。这些配置信息需要与docker image解耦，你总不能每修改一个配置就重做一个image吧？ConfigMap API给我们提供了向容器中注入配置信息的机制，ConfigMap可以被用来保存单个属性，也可以用来保存整个配置文件或者JSON二进制大对象。
ConfigMap概览 The ConfigMap API resource holds key-value pairs of configuration data that can be consumed in pods or used to store configuration data for system components such as controllers. ConfigMap is similar to [Secrets](), but designed to more conveniently support working with strings that do not contain sensitive information.
ConfigMap API资源用来保存key-value pair配置数据，这个数据可以在pods里使用，或者被用来为像controller一样的系统组件存储配置数据。虽然ConfigMap跟Secrets类似，但是ConfigMap更方便的处理不含敏感信息的字符串。 注意：ConfigMaps不是属性配置文件的替代品。ConfigMaps只是作为多个properties文件的引用。你可以把它理解为Linux系统中的/etc目录，专门用来存储配置文件的目录。下面举个例子，使用ConfigMap配置来创建Kuberntes Volumes，ConfigMap中的每个data项都会成为一个新文件。
Note: ConfigMaps are not intended to act as a replacement for a properties file.
    <footer>
        <a href='http://rootsongjc.github.io/blogs/kubernetes-configmap-introduction/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
        <article class="post">
    <header>
      <h2><a href="http://rootsongjc.github.io/blogs/tensorflow-and-deep-learning-without-a-phd/">TensorFlow深度学习手写数字识别初体验 </a> </h2>
      <div class="post-meta">Wed, Apr 5, 2017 </div>
    </header>

    （题图：禾雀 @北京动物园 Apr 3,2017）
前言 TensorFlow学习曲线是陡峭的，不是所有的IT从业人员都很容易参与的，你需要有一定的数学专业知识，对于对深度学习没有经验的程序员，要想了解这门技术，最快捷的途径是先运行一个示例，我们认识事物都是先从感性、到理性的思辨过程。
下面我们来跟随Martin Gorner的TensorFlow and Deep Learing Without a PhD来编写我们的第一个TensorFlow程序——手写数字识别，这篇文章的中文版没有博士学位如何玩转TensorFlow和深度学习于2017年3月13日发表在发表在机器之心上。这篇文章也是根据3月8日-10日的Google Cloud NEXT&rsquo;17大会上Martin Gorner做的讲解整理而成的，教程 | 没有博士学位，照样玩转TensorFlow深度学习这篇文章是对Martin Gorner的简易教程的原文翻译，我们暂时不要求了解TensorFlow背后复杂的理论，我们先跟随这篇简易教程玩一把TensorFlow的手写数字识别。
如果你想深入了解这本后的原理的话，可以查看哈尔滨工业大学社会计算与信息检索研究中心翻译的《神经网络与深度学习》这本书，该书翻译自Neural Networks and Deep Learning的中文翻译，原文作者 Michael Nielsen，而且这还是一本免费的电子书，该书中系统讲解了使用神经网络识别手写数字背后的原理。该书托管在GitBook上，你可以点击这里直接下载该书中文版的PDF。
准备 下载代码
这个代码仓库里包含了手写数字识别和下载依赖的训练数据的代码，我们将只用到mnist_1.0_softmax.py这一个代码文件。整个mnist_1.0_softmax.py代码并不复杂，不算注释的话只有36行。
git clone https://github.com/martin-gorner/tensorflow-mnist-tutorial.git  下载完后，可以看到有一个INSTALL.txt，这篇文章是运行代码所必需的环境要求说明。
安装TensorFlow
我之前写过详细的TensorFlow安装教程TensorFlow实战（才云郑泽宇著）读书笔记——第二章TensorFlow环境搭建，这篇文章中主要讲怎样在docker里安装TensorFlow。
我使用的Mac而且还是python2.7，所以我这样安装：
pip install --upgrade tensorflow --user -U pip install --upgrade matplotlib --user -U  运行示例 运行手写数字训练示例。
python mnist_1.0_softmax.py  运行过程中你会看到一大段输出：
Collecting matplotlib Downloading matplotlib-2.0.0-cp27-cp27m-macosx_10_6_intel.macosx_10_9_intel.macosx_10_9_x86_64.macosx_10_10_intel.macosx_10_10_x86_64.whl (12.8MB) 100% |████████████████████████████████| 12.8MB 26kB/s Requirement already up-to-date: pyparsing!
    <footer>
        <a href='http://rootsongjc.github.io/blogs/tensorflow-and-deep-learning-without-a-phd/'><nobr>Read more →</nobr></a>
    </footer>
</article>

    
  </div>
</section>

<aside id="meta"> </aside>

<footer>
  <div>
    <p>
    &copy; 2013-2017 <span itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Jimmy Song</span></span>
    Powered by <a href="http://gohugo.io">Hugo</a>.
    </p>
  </div>
</footer>
</body>
</html>

